// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types/v1/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_types_2fv1_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_types_2fv1_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gnostic/openapi/v3/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_types_2fv1_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_types_2fv1_2ftypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_types_2fv1_2ftypes_2eproto;
namespace types {
namespace v1 {
class BlockCompaction;
struct BlockCompactionDefaultTypeInternal;
extern BlockCompactionDefaultTypeInternal _BlockCompaction_default_instance_;
class BlockInfo;
struct BlockInfoDefaultTypeInternal;
extern BlockInfoDefaultTypeInternal _BlockInfo_default_instance_;
class Exemplar;
struct ExemplarDefaultTypeInternal;
extern ExemplarDefaultTypeInternal _Exemplar_default_instance_;
class GetProfileStatsRequest;
struct GetProfileStatsRequestDefaultTypeInternal;
extern GetProfileStatsRequestDefaultTypeInternal _GetProfileStatsRequest_default_instance_;
class GetProfileStatsResponse;
struct GetProfileStatsResponseDefaultTypeInternal;
extern GetProfileStatsResponseDefaultTypeInternal _GetProfileStatsResponse_default_instance_;
class GoPGO;
struct GoPGODefaultTypeInternal;
extern GoPGODefaultTypeInternal _GoPGO_default_instance_;
class HeatmapSeries;
struct HeatmapSeriesDefaultTypeInternal;
extern HeatmapSeriesDefaultTypeInternal _HeatmapSeries_default_instance_;
class HeatmapSlot;
struct HeatmapSlotDefaultTypeInternal;
extern HeatmapSlotDefaultTypeInternal _HeatmapSlot_default_instance_;
class LabelNamesRequest;
struct LabelNamesRequestDefaultTypeInternal;
extern LabelNamesRequestDefaultTypeInternal _LabelNamesRequest_default_instance_;
class LabelNamesResponse;
struct LabelNamesResponseDefaultTypeInternal;
extern LabelNamesResponseDefaultTypeInternal _LabelNamesResponse_default_instance_;
class LabelPair;
struct LabelPairDefaultTypeInternal;
extern LabelPairDefaultTypeInternal _LabelPair_default_instance_;
class LabelValuesRequest;
struct LabelValuesRequestDefaultTypeInternal;
extern LabelValuesRequestDefaultTypeInternal _LabelValuesRequest_default_instance_;
class LabelValuesResponse;
struct LabelValuesResponseDefaultTypeInternal;
extern LabelValuesResponseDefaultTypeInternal _LabelValuesResponse_default_instance_;
class Labels;
struct LabelsDefaultTypeInternal;
extern LabelsDefaultTypeInternal _Labels_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class ProfileAnnotation;
struct ProfileAnnotationDefaultTypeInternal;
extern ProfileAnnotationDefaultTypeInternal _ProfileAnnotation_default_instance_;
class ProfileType;
struct ProfileTypeDefaultTypeInternal;
extern ProfileTypeDefaultTypeInternal _ProfileType_default_instance_;
class Series;
struct SeriesDefaultTypeInternal;
extern SeriesDefaultTypeInternal _Series_default_instance_;
class StackTraceSelector;
struct StackTraceSelectorDefaultTypeInternal;
extern StackTraceSelectorDefaultTypeInternal _StackTraceSelector_default_instance_;
}  // namespace v1
}  // namespace types
PROTOBUF_NAMESPACE_OPEN
template<> ::types::v1::BlockCompaction* Arena::CreateMaybeMessage<::types::v1::BlockCompaction>(Arena*);
template<> ::types::v1::BlockInfo* Arena::CreateMaybeMessage<::types::v1::BlockInfo>(Arena*);
template<> ::types::v1::Exemplar* Arena::CreateMaybeMessage<::types::v1::Exemplar>(Arena*);
template<> ::types::v1::GetProfileStatsRequest* Arena::CreateMaybeMessage<::types::v1::GetProfileStatsRequest>(Arena*);
template<> ::types::v1::GetProfileStatsResponse* Arena::CreateMaybeMessage<::types::v1::GetProfileStatsResponse>(Arena*);
template<> ::types::v1::GoPGO* Arena::CreateMaybeMessage<::types::v1::GoPGO>(Arena*);
template<> ::types::v1::HeatmapSeries* Arena::CreateMaybeMessage<::types::v1::HeatmapSeries>(Arena*);
template<> ::types::v1::HeatmapSlot* Arena::CreateMaybeMessage<::types::v1::HeatmapSlot>(Arena*);
template<> ::types::v1::LabelNamesRequest* Arena::CreateMaybeMessage<::types::v1::LabelNamesRequest>(Arena*);
template<> ::types::v1::LabelNamesResponse* Arena::CreateMaybeMessage<::types::v1::LabelNamesResponse>(Arena*);
template<> ::types::v1::LabelPair* Arena::CreateMaybeMessage<::types::v1::LabelPair>(Arena*);
template<> ::types::v1::LabelValuesRequest* Arena::CreateMaybeMessage<::types::v1::LabelValuesRequest>(Arena*);
template<> ::types::v1::LabelValuesResponse* Arena::CreateMaybeMessage<::types::v1::LabelValuesResponse>(Arena*);
template<> ::types::v1::Labels* Arena::CreateMaybeMessage<::types::v1::Labels>(Arena*);
template<> ::types::v1::Location* Arena::CreateMaybeMessage<::types::v1::Location>(Arena*);
template<> ::types::v1::Point* Arena::CreateMaybeMessage<::types::v1::Point>(Arena*);
template<> ::types::v1::ProfileAnnotation* Arena::CreateMaybeMessage<::types::v1::ProfileAnnotation>(Arena*);
template<> ::types::v1::ProfileType* Arena::CreateMaybeMessage<::types::v1::ProfileType>(Arena*);
template<> ::types::v1::Series* Arena::CreateMaybeMessage<::types::v1::Series>(Arena*);
template<> ::types::v1::StackTraceSelector* Arena::CreateMaybeMessage<::types::v1::StackTraceSelector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace types {
namespace v1 {

enum TimeSeriesAggregationType : int {
  TIME_SERIES_AGGREGATION_TYPE_SUM = 0,
  TIME_SERIES_AGGREGATION_TYPE_AVERAGE = 1,
  TimeSeriesAggregationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TimeSeriesAggregationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TimeSeriesAggregationType_IsValid(int value);
constexpr TimeSeriesAggregationType TimeSeriesAggregationType_MIN = TIME_SERIES_AGGREGATION_TYPE_SUM;
constexpr TimeSeriesAggregationType TimeSeriesAggregationType_MAX = TIME_SERIES_AGGREGATION_TYPE_AVERAGE;
constexpr int TimeSeriesAggregationType_ARRAYSIZE = TimeSeriesAggregationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeSeriesAggregationType_descriptor();
template<typename T>
inline const std::string& TimeSeriesAggregationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeSeriesAggregationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeSeriesAggregationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeSeriesAggregationType_descriptor(), enum_t_value);
}
inline bool TimeSeriesAggregationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeSeriesAggregationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeSeriesAggregationType>(
    TimeSeriesAggregationType_descriptor(), name, value);
}
enum ExemplarType : int {
  EXEMPLAR_TYPE_UNSPECIFIED = 0,
  EXEMPLAR_TYPE_NONE = 1,
  EXEMPLAR_TYPE_INDIVIDUAL = 2,
  EXEMPLAR_TYPE_SPAN = 3,
  ExemplarType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExemplarType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExemplarType_IsValid(int value);
constexpr ExemplarType ExemplarType_MIN = EXEMPLAR_TYPE_UNSPECIFIED;
constexpr ExemplarType ExemplarType_MAX = EXEMPLAR_TYPE_SPAN;
constexpr int ExemplarType_ARRAYSIZE = ExemplarType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExemplarType_descriptor();
template<typename T>
inline const std::string& ExemplarType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExemplarType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExemplarType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExemplarType_descriptor(), enum_t_value);
}
inline bool ExemplarType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExemplarType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExemplarType>(
    ExemplarType_descriptor(), name, value);
}
// ===================================================================

class LabelPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.LabelPair) */ {
 public:
  inline LabelPair() : LabelPair(nullptr) {}
  ~LabelPair() override;
  explicit PROTOBUF_CONSTEXPR LabelPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelPair(const LabelPair& from);
  LabelPair(LabelPair&& from) noexcept
    : LabelPair() {
    *this = ::std::move(from);
  }

  inline LabelPair& operator=(const LabelPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelPair& operator=(LabelPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelPair* internal_default_instance() {
    return reinterpret_cast<const LabelPair*>(
               &_LabelPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LabelPair& a, LabelPair& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelPair& from) {
    LabelPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.LabelPair";
  }
  protected:
  explicit LabelPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1 [(.gnostic.openapi.v3.property) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2 [(.gnostic.openapi.v3.property) = {
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:types.v1.LabelPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ProfileType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.ProfileType) */ {
 public:
  inline ProfileType() : ProfileType(nullptr) {}
  ~ProfileType() override;
  explicit PROTOBUF_CONSTEXPR ProfileType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileType(const ProfileType& from);
  ProfileType(ProfileType&& from) noexcept
    : ProfileType() {
    *this = ::std::move(from);
  }

  inline ProfileType& operator=(const ProfileType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileType& operator=(ProfileType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProfileType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileType* internal_default_instance() {
    return reinterpret_cast<const ProfileType*>(
               &_ProfileType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProfileType& a, ProfileType& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProfileType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProfileType& from) {
    ProfileType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.ProfileType";
  }
  protected:
  explicit ProfileType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kNameFieldNumber = 2,
    kSampleTypeFieldNumber = 4,
    kSampleUnitFieldNumber = 5,
    kPeriodTypeFieldNumber = 6,
    kPeriodUnitFieldNumber = 7,
  };
  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string sample_type = 4;
  void clear_sample_type();
  const std::string& sample_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sample_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sample_type();
  PROTOBUF_NODISCARD std::string* release_sample_type();
  void set_allocated_sample_type(std::string* sample_type);
  private:
  const std::string& _internal_sample_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sample_type(const std::string& value);
  std::string* _internal_mutable_sample_type();
  public:

  // string sample_unit = 5;
  void clear_sample_unit();
  const std::string& sample_unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sample_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sample_unit();
  PROTOBUF_NODISCARD std::string* release_sample_unit();
  void set_allocated_sample_unit(std::string* sample_unit);
  private:
  const std::string& _internal_sample_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sample_unit(const std::string& value);
  std::string* _internal_mutable_sample_unit();
  public:

  // string period_type = 6;
  void clear_period_type();
  const std::string& period_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_period_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_period_type();
  PROTOBUF_NODISCARD std::string* release_period_type();
  void set_allocated_period_type(std::string* period_type);
  private:
  const std::string& _internal_period_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_period_type(const std::string& value);
  std::string* _internal_mutable_period_type();
  public:

  // string period_unit = 7;
  void clear_period_unit();
  const std::string& period_unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_period_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_period_unit();
  PROTOBUF_NODISCARD std::string* release_period_unit();
  void set_allocated_period_unit(std::string* period_unit);
  private:
  const std::string& _internal_period_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_period_unit(const std::string& value);
  std::string* _internal_mutable_period_unit();
  public:

  // @@protoc_insertion_point(class_scope:types.v1.ProfileType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sample_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sample_unit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr period_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr period_unit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Labels final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.Labels) */ {
 public:
  inline Labels() : Labels(nullptr) {}
  ~Labels() override;
  explicit PROTOBUF_CONSTEXPR Labels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Labels(const Labels& from);
  Labels(Labels&& from) noexcept
    : Labels() {
    *this = ::std::move(from);
  }

  inline Labels& operator=(const Labels& from) {
    CopyFrom(from);
    return *this;
  }
  inline Labels& operator=(Labels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Labels& default_instance() {
    return *internal_default_instance();
  }
  static inline const Labels* internal_default_instance() {
    return reinterpret_cast<const Labels*>(
               &_Labels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Labels& a, Labels& b) {
    a.Swap(&b);
  }
  inline void Swap(Labels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Labels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Labels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Labels>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Labels& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Labels& from) {
    Labels::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Labels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.Labels";
  }
  protected:
  explicit Labels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
  };
  // repeated .types.v1.LabelPair labels = 1;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::types::v1::LabelPair* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
      mutable_labels();
  private:
  const ::types::v1::LabelPair& _internal_labels(int index) const;
  ::types::v1::LabelPair* _internal_add_labels();
  public:
  const ::types::v1::LabelPair& labels(int index) const;
  ::types::v1::LabelPair* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
      labels() const;

  // @@protoc_insertion_point(class_scope:types.v1.Labels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair > labels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Series final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.Series) */ {
 public:
  inline Series() : Series(nullptr) {}
  ~Series() override;
  explicit PROTOBUF_CONSTEXPR Series(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Series(const Series& from);
  Series(Series&& from) noexcept
    : Series() {
    *this = ::std::move(from);
  }

  inline Series& operator=(const Series& from) {
    CopyFrom(from);
    return *this;
  }
  inline Series& operator=(Series&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Series& default_instance() {
    return *internal_default_instance();
  }
  static inline const Series* internal_default_instance() {
    return reinterpret_cast<const Series*>(
               &_Series_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Series& a, Series& b) {
    a.Swap(&b);
  }
  inline void Swap(Series* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Series* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Series* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Series>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Series& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Series& from) {
    Series::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Series* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.Series";
  }
  protected:
  explicit Series(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
    kPointsFieldNumber = 2,
  };
  // repeated .types.v1.LabelPair labels = 1;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::types::v1::LabelPair* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
      mutable_labels();
  private:
  const ::types::v1::LabelPair& _internal_labels(int index) const;
  ::types::v1::LabelPair* _internal_add_labels();
  public:
  const ::types::v1::LabelPair& labels(int index) const;
  ::types::v1::LabelPair* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
      labels() const;

  // repeated .types.v1.Point points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::types::v1::Point* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Point >*
      mutable_points();
  private:
  const ::types::v1::Point& _internal_points(int index) const;
  ::types::v1::Point* _internal_add_points();
  public:
  const ::types::v1::Point& points(int index) const;
  ::types::v1::Point* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Point >&
      points() const;

  // @@protoc_insertion_point(class_scope:types.v1.Series)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair > labels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Point > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnotationsFieldNumber = 3,
    kExemplarsFieldNumber = 4,
    kValueFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated .types.v1.ProfileAnnotation annotations = 3;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  ::types::v1::ProfileAnnotation* mutable_annotations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::ProfileAnnotation >*
      mutable_annotations();
  private:
  const ::types::v1::ProfileAnnotation& _internal_annotations(int index) const;
  ::types::v1::ProfileAnnotation* _internal_add_annotations();
  public:
  const ::types::v1::ProfileAnnotation& annotations(int index) const;
  ::types::v1::ProfileAnnotation* add_annotations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::ProfileAnnotation >&
      annotations() const;

  // repeated .types.v1.Exemplar exemplars = 4;
  int exemplars_size() const;
  private:
  int _internal_exemplars_size() const;
  public:
  void clear_exemplars();
  ::types::v1::Exemplar* mutable_exemplars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >*
      mutable_exemplars();
  private:
  const ::types::v1::Exemplar& _internal_exemplars(int index) const;
  ::types::v1::Exemplar* _internal_add_exemplars();
  public:
  const ::types::v1::Exemplar& exemplars(int index) const;
  ::types::v1::Exemplar* add_exemplars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >&
      exemplars() const;

  // double value = 1;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::ProfileAnnotation > annotations_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar > exemplars_;
    double value_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ProfileAnnotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.ProfileAnnotation) */ {
 public:
  inline ProfileAnnotation() : ProfileAnnotation(nullptr) {}
  ~ProfileAnnotation() override;
  explicit PROTOBUF_CONSTEXPR ProfileAnnotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileAnnotation(const ProfileAnnotation& from);
  ProfileAnnotation(ProfileAnnotation&& from) noexcept
    : ProfileAnnotation() {
    *this = ::std::move(from);
  }

  inline ProfileAnnotation& operator=(const ProfileAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileAnnotation& operator=(ProfileAnnotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProfileAnnotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileAnnotation* internal_default_instance() {
    return reinterpret_cast<const ProfileAnnotation*>(
               &_ProfileAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProfileAnnotation& a, ProfileAnnotation& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileAnnotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileAnnotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileAnnotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileAnnotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProfileAnnotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProfileAnnotation& from) {
    ProfileAnnotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileAnnotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.ProfileAnnotation";
  }
  protected:
  explicit ProfileAnnotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:types.v1.ProfileAnnotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class LabelValuesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.LabelValuesRequest) */ {
 public:
  inline LabelValuesRequest() : LabelValuesRequest(nullptr) {}
  ~LabelValuesRequest() override;
  explicit PROTOBUF_CONSTEXPR LabelValuesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelValuesRequest(const LabelValuesRequest& from);
  LabelValuesRequest(LabelValuesRequest&& from) noexcept
    : LabelValuesRequest() {
    *this = ::std::move(from);
  }

  inline LabelValuesRequest& operator=(const LabelValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelValuesRequest& operator=(LabelValuesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelValuesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelValuesRequest* internal_default_instance() {
    return reinterpret_cast<const LabelValuesRequest*>(
               &_LabelValuesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LabelValuesRequest& a, LabelValuesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelValuesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelValuesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelValuesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelValuesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelValuesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelValuesRequest& from) {
    LabelValuesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelValuesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.LabelValuesRequest";
  }
  protected:
  explicit LabelValuesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchersFieldNumber = 2,
    kNameFieldNumber = 1,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // repeated string matchers = 2;
  int matchers_size() const;
  private:
  int _internal_matchers_size() const;
  public:
  void clear_matchers();
  const std::string& matchers(int index) const;
  std::string* mutable_matchers(int index);
  void set_matchers(int index, const std::string& value);
  void set_matchers(int index, std::string&& value);
  void set_matchers(int index, const char* value);
  void set_matchers(int index, const char* value, size_t size);
  std::string* add_matchers();
  void add_matchers(const std::string& value);
  void add_matchers(std::string&& value);
  void add_matchers(const char* value);
  void add_matchers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& matchers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_matchers();
  private:
  const std::string& _internal_matchers(int index) const;
  std::string* _internal_add_matchers();
  public:

  // string name = 1 [(.gnostic.openapi.v3.property) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 start = 3 [(.gnostic.openapi.v3.property) = {
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 end = 4 [(.gnostic.openapi.v3.property) = {
  void clear_end();
  int64_t end() const;
  void set_end(int64_t value);
  private:
  int64_t _internal_end() const;
  void _internal_set_end(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.LabelValuesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> matchers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t start_;
    int64_t end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class LabelValuesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.LabelValuesResponse) */ {
 public:
  inline LabelValuesResponse() : LabelValuesResponse(nullptr) {}
  ~LabelValuesResponse() override;
  explicit PROTOBUF_CONSTEXPR LabelValuesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelValuesResponse(const LabelValuesResponse& from);
  LabelValuesResponse(LabelValuesResponse&& from) noexcept
    : LabelValuesResponse() {
    *this = ::std::move(from);
  }

  inline LabelValuesResponse& operator=(const LabelValuesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelValuesResponse& operator=(LabelValuesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelValuesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelValuesResponse* internal_default_instance() {
    return reinterpret_cast<const LabelValuesResponse*>(
               &_LabelValuesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LabelValuesResponse& a, LabelValuesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelValuesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelValuesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelValuesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelValuesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelValuesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelValuesResponse& from) {
    LabelValuesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelValuesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.LabelValuesResponse";
  }
  protected:
  explicit LabelValuesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 1,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // @@protoc_insertion_point(class_scope:types.v1.LabelValuesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class LabelNamesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.LabelNamesRequest) */ {
 public:
  inline LabelNamesRequest() : LabelNamesRequest(nullptr) {}
  ~LabelNamesRequest() override;
  explicit PROTOBUF_CONSTEXPR LabelNamesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelNamesRequest(const LabelNamesRequest& from);
  LabelNamesRequest(LabelNamesRequest&& from) noexcept
    : LabelNamesRequest() {
    *this = ::std::move(from);
  }

  inline LabelNamesRequest& operator=(const LabelNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelNamesRequest& operator=(LabelNamesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelNamesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelNamesRequest* internal_default_instance() {
    return reinterpret_cast<const LabelNamesRequest*>(
               &_LabelNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LabelNamesRequest& a, LabelNamesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelNamesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelNamesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelNamesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelNamesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelNamesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelNamesRequest& from) {
    LabelNamesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelNamesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.LabelNamesRequest";
  }
  protected:
  explicit LabelNamesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchersFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // repeated string matchers = 1;
  int matchers_size() const;
  private:
  int _internal_matchers_size() const;
  public:
  void clear_matchers();
  const std::string& matchers(int index) const;
  std::string* mutable_matchers(int index);
  void set_matchers(int index, const std::string& value);
  void set_matchers(int index, std::string&& value);
  void set_matchers(int index, const char* value);
  void set_matchers(int index, const char* value, size_t size);
  std::string* add_matchers();
  void add_matchers(const std::string& value);
  void add_matchers(std::string&& value);
  void add_matchers(const char* value);
  void add_matchers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& matchers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_matchers();
  private:
  const std::string& _internal_matchers(int index) const;
  std::string* _internal_add_matchers();
  public:

  // int64 start = 2 [(.gnostic.openapi.v3.property) = {
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 end = 3 [(.gnostic.openapi.v3.property) = {
  void clear_end();
  int64_t end() const;
  void set_end(int64_t value);
  private:
  int64_t _internal_end() const;
  void _internal_set_end(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.LabelNamesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> matchers_;
    int64_t start_;
    int64_t end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class LabelNamesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.LabelNamesResponse) */ {
 public:
  inline LabelNamesResponse() : LabelNamesResponse(nullptr) {}
  ~LabelNamesResponse() override;
  explicit PROTOBUF_CONSTEXPR LabelNamesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelNamesResponse(const LabelNamesResponse& from);
  LabelNamesResponse(LabelNamesResponse&& from) noexcept
    : LabelNamesResponse() {
    *this = ::std::move(from);
  }

  inline LabelNamesResponse& operator=(const LabelNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelNamesResponse& operator=(LabelNamesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelNamesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelNamesResponse* internal_default_instance() {
    return reinterpret_cast<const LabelNamesResponse*>(
               &_LabelNamesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LabelNamesResponse& a, LabelNamesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelNamesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelNamesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelNamesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelNamesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelNamesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelNamesResponse& from) {
    LabelNamesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelNamesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.LabelNamesResponse";
  }
  protected:
  explicit LabelNamesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 1,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // @@protoc_insertion_point(class_scope:types.v1.LabelNamesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BlockInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.BlockInfo) */ {
 public:
  inline BlockInfo() : BlockInfo(nullptr) {}
  ~BlockInfo() override;
  explicit PROTOBUF_CONSTEXPR BlockInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockInfo(const BlockInfo& from);
  BlockInfo(BlockInfo&& from) noexcept
    : BlockInfo() {
    *this = ::std::move(from);
  }

  inline BlockInfo& operator=(const BlockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockInfo& operator=(BlockInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockInfo* internal_default_instance() {
    return reinterpret_cast<const BlockInfo*>(
               &_BlockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BlockInfo& a, BlockInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockInfo& from) {
    BlockInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.BlockInfo";
  }
  protected:
  explicit BlockInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 5,
    kUlidFieldNumber = 1,
    kCompactionFieldNumber = 4,
    kMinTimeFieldNumber = 2,
    kMaxTimeFieldNumber = 3,
  };
  // repeated .types.v1.LabelPair labels = 5;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::types::v1::LabelPair* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
      mutable_labels();
  private:
  const ::types::v1::LabelPair& _internal_labels(int index) const;
  ::types::v1::LabelPair* _internal_add_labels();
  public:
  const ::types::v1::LabelPair& labels(int index) const;
  ::types::v1::LabelPair* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
      labels() const;

  // string ulid = 1;
  void clear_ulid();
  const std::string& ulid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ulid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ulid();
  PROTOBUF_NODISCARD std::string* release_ulid();
  void set_allocated_ulid(std::string* ulid);
  private:
  const std::string& _internal_ulid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ulid(const std::string& value);
  std::string* _internal_mutable_ulid();
  public:

  // .types.v1.BlockCompaction compaction = 4;
  bool has_compaction() const;
  private:
  bool _internal_has_compaction() const;
  public:
  void clear_compaction();
  const ::types::v1::BlockCompaction& compaction() const;
  PROTOBUF_NODISCARD ::types::v1::BlockCompaction* release_compaction();
  ::types::v1::BlockCompaction* mutable_compaction();
  void set_allocated_compaction(::types::v1::BlockCompaction* compaction);
  private:
  const ::types::v1::BlockCompaction& _internal_compaction() const;
  ::types::v1::BlockCompaction* _internal_mutable_compaction();
  public:
  void unsafe_arena_set_allocated_compaction(
      ::types::v1::BlockCompaction* compaction);
  ::types::v1::BlockCompaction* unsafe_arena_release_compaction();

  // int64 min_time = 2;
  void clear_min_time();
  int64_t min_time() const;
  void set_min_time(int64_t value);
  private:
  int64_t _internal_min_time() const;
  void _internal_set_min_time(int64_t value);
  public:

  // int64 max_time = 3;
  void clear_max_time();
  int64_t max_time() const;
  void set_max_time(int64_t value);
  private:
  int64_t _internal_max_time() const;
  void _internal_set_max_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.BlockInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair > labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ulid_;
    ::types::v1::BlockCompaction* compaction_;
    int64_t min_time_;
    int64_t max_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BlockCompaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.BlockCompaction) */ {
 public:
  inline BlockCompaction() : BlockCompaction(nullptr) {}
  ~BlockCompaction() override;
  explicit PROTOBUF_CONSTEXPR BlockCompaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockCompaction(const BlockCompaction& from);
  BlockCompaction(BlockCompaction&& from) noexcept
    : BlockCompaction() {
    *this = ::std::move(from);
  }

  inline BlockCompaction& operator=(const BlockCompaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockCompaction& operator=(BlockCompaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockCompaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockCompaction* internal_default_instance() {
    return reinterpret_cast<const BlockCompaction*>(
               &_BlockCompaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BlockCompaction& a, BlockCompaction& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockCompaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockCompaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockCompaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockCompaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockCompaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockCompaction& from) {
    BlockCompaction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockCompaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.BlockCompaction";
  }
  protected:
  explicit BlockCompaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 2,
    kParentsFieldNumber = 3,
    kLevelFieldNumber = 1,
  };
  // repeated string sources = 2;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  const std::string& sources(int index) const;
  std::string* mutable_sources(int index);
  void set_sources(int index, const std::string& value);
  void set_sources(int index, std::string&& value);
  void set_sources(int index, const char* value);
  void set_sources(int index, const char* value, size_t size);
  std::string* add_sources();
  void add_sources(const std::string& value);
  void add_sources(std::string&& value);
  void add_sources(const char* value);
  void add_sources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sources();
  private:
  const std::string& _internal_sources(int index) const;
  std::string* _internal_add_sources();
  public:

  // repeated string parents = 3;
  int parents_size() const;
  private:
  int _internal_parents_size() const;
  public:
  void clear_parents();
  const std::string& parents(int index) const;
  std::string* mutable_parents(int index);
  void set_parents(int index, const std::string& value);
  void set_parents(int index, std::string&& value);
  void set_parents(int index, const char* value);
  void set_parents(int index, const char* value, size_t size);
  std::string* add_parents();
  void add_parents(const std::string& value);
  void add_parents(std::string&& value);
  void add_parents(const char* value);
  void add_parents(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& parents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_parents();
  private:
  const std::string& _internal_parents(int index) const;
  std::string* _internal_add_parents();
  public:

  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.BlockCompaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> parents_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class StackTraceSelector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.StackTraceSelector) */ {
 public:
  inline StackTraceSelector() : StackTraceSelector(nullptr) {}
  ~StackTraceSelector() override;
  explicit PROTOBUF_CONSTEXPR StackTraceSelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StackTraceSelector(const StackTraceSelector& from);
  StackTraceSelector(StackTraceSelector&& from) noexcept
    : StackTraceSelector() {
    *this = ::std::move(from);
  }

  inline StackTraceSelector& operator=(const StackTraceSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackTraceSelector& operator=(StackTraceSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StackTraceSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const StackTraceSelector* internal_default_instance() {
    return reinterpret_cast<const StackTraceSelector*>(
               &_StackTraceSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StackTraceSelector& a, StackTraceSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(StackTraceSelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackTraceSelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StackTraceSelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StackTraceSelector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StackTraceSelector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StackTraceSelector& from) {
    StackTraceSelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StackTraceSelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.StackTraceSelector";
  }
  protected:
  explicit StackTraceSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallSiteFieldNumber = 1,
    kGoPgoFieldNumber = 2,
  };
  // repeated .types.v1.Location call_site = 1;
  int call_site_size() const;
  private:
  int _internal_call_site_size() const;
  public:
  void clear_call_site();
  ::types::v1::Location* mutable_call_site(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Location >*
      mutable_call_site();
  private:
  const ::types::v1::Location& _internal_call_site(int index) const;
  ::types::v1::Location* _internal_add_call_site();
  public:
  const ::types::v1::Location& call_site(int index) const;
  ::types::v1::Location* add_call_site();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Location >&
      call_site() const;

  // .types.v1.GoPGO go_pgo = 2;
  bool has_go_pgo() const;
  private:
  bool _internal_has_go_pgo() const;
  public:
  void clear_go_pgo();
  const ::types::v1::GoPGO& go_pgo() const;
  PROTOBUF_NODISCARD ::types::v1::GoPGO* release_go_pgo();
  ::types::v1::GoPGO* mutable_go_pgo();
  void set_allocated_go_pgo(::types::v1::GoPGO* go_pgo);
  private:
  const ::types::v1::GoPGO& _internal_go_pgo() const;
  ::types::v1::GoPGO* _internal_mutable_go_pgo();
  public:
  void unsafe_arena_set_allocated_go_pgo(
      ::types::v1::GoPGO* go_pgo);
  ::types::v1::GoPGO* unsafe_arena_release_go_pgo();

  // @@protoc_insertion_point(class_scope:types.v1.StackTraceSelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Location > call_site_;
    ::types::v1::GoPGO* go_pgo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:types.v1.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class GoPGO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.GoPGO) */ {
 public:
  inline GoPGO() : GoPGO(nullptr) {}
  ~GoPGO() override;
  explicit PROTOBUF_CONSTEXPR GoPGO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GoPGO(const GoPGO& from);
  GoPGO(GoPGO&& from) noexcept
    : GoPGO() {
    *this = ::std::move(from);
  }

  inline GoPGO& operator=(const GoPGO& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoPGO& operator=(GoPGO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoPGO& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoPGO* internal_default_instance() {
    return reinterpret_cast<const GoPGO*>(
               &_GoPGO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GoPGO& a, GoPGO& b) {
    a.Swap(&b);
  }
  inline void Swap(GoPGO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoPGO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoPGO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoPGO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GoPGO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GoPGO& from) {
    GoPGO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoPGO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.GoPGO";
  }
  protected:
  explicit GoPGO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeepLocationsFieldNumber = 1,
    kAggregateCalleesFieldNumber = 2,
  };
  // uint32 keep_locations = 1;
  void clear_keep_locations();
  uint32_t keep_locations() const;
  void set_keep_locations(uint32_t value);
  private:
  uint32_t _internal_keep_locations() const;
  void _internal_set_keep_locations(uint32_t value);
  public:

  // bool aggregate_callees = 2;
  void clear_aggregate_callees();
  bool aggregate_callees() const;
  void set_aggregate_callees(bool value);
  private:
  bool _internal_aggregate_callees() const;
  void _internal_set_aggregate_callees(bool value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.GoPGO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t keep_locations_;
    bool aggregate_callees_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class GetProfileStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:types.v1.GetProfileStatsRequest) */ {
 public:
  inline GetProfileStatsRequest() : GetProfileStatsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetProfileStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProfileStatsRequest(const GetProfileStatsRequest& from);
  GetProfileStatsRequest(GetProfileStatsRequest&& from) noexcept
    : GetProfileStatsRequest() {
    *this = ::std::move(from);
  }

  inline GetProfileStatsRequest& operator=(const GetProfileStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProfileStatsRequest& operator=(GetProfileStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProfileStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProfileStatsRequest* internal_default_instance() {
    return reinterpret_cast<const GetProfileStatsRequest*>(
               &_GetProfileStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetProfileStatsRequest& a, GetProfileStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProfileStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProfileStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProfileStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProfileStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetProfileStatsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetProfileStatsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.GetProfileStatsRequest";
  }
  protected:
  explicit GetProfileStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.v1.GetProfileStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class GetProfileStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.GetProfileStatsResponse) */ {
 public:
  inline GetProfileStatsResponse() : GetProfileStatsResponse(nullptr) {}
  ~GetProfileStatsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetProfileStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProfileStatsResponse(const GetProfileStatsResponse& from);
  GetProfileStatsResponse(GetProfileStatsResponse&& from) noexcept
    : GetProfileStatsResponse() {
    *this = ::std::move(from);
  }

  inline GetProfileStatsResponse& operator=(const GetProfileStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProfileStatsResponse& operator=(GetProfileStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProfileStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProfileStatsResponse* internal_default_instance() {
    return reinterpret_cast<const GetProfileStatsResponse*>(
               &_GetProfileStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetProfileStatsResponse& a, GetProfileStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProfileStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProfileStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProfileStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProfileStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProfileStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProfileStatsResponse& from) {
    GetProfileStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProfileStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.GetProfileStatsResponse";
  }
  protected:
  explicit GetProfileStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldestProfileTimeFieldNumber = 2,
    kNewestProfileTimeFieldNumber = 3,
    kDataIngestedFieldNumber = 1,
  };
  // int64 oldest_profile_time = 2;
  void clear_oldest_profile_time();
  int64_t oldest_profile_time() const;
  void set_oldest_profile_time(int64_t value);
  private:
  int64_t _internal_oldest_profile_time() const;
  void _internal_set_oldest_profile_time(int64_t value);
  public:

  // int64 newest_profile_time = 3;
  void clear_newest_profile_time();
  int64_t newest_profile_time() const;
  void set_newest_profile_time(int64_t value);
  private:
  int64_t _internal_newest_profile_time() const;
  void _internal_set_newest_profile_time(int64_t value);
  public:

  // bool data_ingested = 1;
  void clear_data_ingested();
  bool data_ingested() const;
  void set_data_ingested(bool value);
  private:
  bool _internal_data_ingested() const;
  void _internal_set_data_ingested(bool value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.GetProfileStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t oldest_profile_time_;
    int64_t newest_profile_time_;
    bool data_ingested_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Exemplar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.Exemplar) */ {
 public:
  inline Exemplar() : Exemplar(nullptr) {}
  ~Exemplar() override;
  explicit PROTOBUF_CONSTEXPR Exemplar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Exemplar(const Exemplar& from);
  Exemplar(Exemplar&& from) noexcept
    : Exemplar() {
    *this = ::std::move(from);
  }

  inline Exemplar& operator=(const Exemplar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Exemplar& operator=(Exemplar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Exemplar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Exemplar* internal_default_instance() {
    return reinterpret_cast<const Exemplar*>(
               &_Exemplar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Exemplar& a, Exemplar& b) {
    a.Swap(&b);
  }
  inline void Swap(Exemplar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Exemplar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Exemplar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Exemplar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Exemplar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Exemplar& from) {
    Exemplar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exemplar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.Exemplar";
  }
  protected:
  explicit Exemplar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 5,
    kProfileIdFieldNumber = 2,
    kSpanIdFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kValueFieldNumber = 4,
  };
  // repeated .types.v1.LabelPair labels = 5;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::types::v1::LabelPair* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
      mutable_labels();
  private:
  const ::types::v1::LabelPair& _internal_labels(int index) const;
  ::types::v1::LabelPair* _internal_add_labels();
  public:
  const ::types::v1::LabelPair& labels(int index) const;
  ::types::v1::LabelPair* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
      labels() const;

  // string profile_id = 2 [(.gnostic.openapi.v3.property) = {
  void clear_profile_id();
  const std::string& profile_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profile_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profile_id();
  PROTOBUF_NODISCARD std::string* release_profile_id();
  void set_allocated_profile_id(std::string* profile_id);
  private:
  const std::string& _internal_profile_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profile_id(const std::string& value);
  std::string* _internal_mutable_profile_id();
  public:

  // string span_id = 3 [(.gnostic.openapi.v3.property) = {
  void clear_span_id();
  const std::string& span_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_span_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_span_id();
  PROTOBUF_NODISCARD std::string* release_span_id();
  void set_allocated_span_id(std::string* span_id);
  private:
  const std::string& _internal_span_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_span_id(const std::string& value);
  std::string* _internal_mutable_span_id();
  public:

  // int64 timestamp = 1 [(.gnostic.openapi.v3.property) = {
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 value = 4 [(.gnostic.openapi.v3.property) = {
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.Exemplar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair > labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr span_id_;
    int64_t timestamp_;
    int64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class HeatmapSeries final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.HeatmapSeries) */ {
 public:
  inline HeatmapSeries() : HeatmapSeries(nullptr) {}
  ~HeatmapSeries() override;
  explicit PROTOBUF_CONSTEXPR HeatmapSeries(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeatmapSeries(const HeatmapSeries& from);
  HeatmapSeries(HeatmapSeries&& from) noexcept
    : HeatmapSeries() {
    *this = ::std::move(from);
  }

  inline HeatmapSeries& operator=(const HeatmapSeries& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeatmapSeries& operator=(HeatmapSeries&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeatmapSeries& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeatmapSeries* internal_default_instance() {
    return reinterpret_cast<const HeatmapSeries*>(
               &_HeatmapSeries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HeatmapSeries& a, HeatmapSeries& b) {
    a.Swap(&b);
  }
  inline void Swap(HeatmapSeries* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeatmapSeries* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeatmapSeries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeatmapSeries>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeatmapSeries& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeatmapSeries& from) {
    HeatmapSeries::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeatmapSeries* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.HeatmapSeries";
  }
  protected:
  explicit HeatmapSeries(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
    kSlotsFieldNumber = 2,
  };
  // repeated .types.v1.LabelPair labels = 1;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::types::v1::LabelPair* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
      mutable_labels();
  private:
  const ::types::v1::LabelPair& _internal_labels(int index) const;
  ::types::v1::LabelPair* _internal_add_labels();
  public:
  const ::types::v1::LabelPair& labels(int index) const;
  ::types::v1::LabelPair* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
      labels() const;

  // repeated .types.v1.HeatmapSlot slots = 2;
  int slots_size() const;
  private:
  int _internal_slots_size() const;
  public:
  void clear_slots();
  ::types::v1::HeatmapSlot* mutable_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::HeatmapSlot >*
      mutable_slots();
  private:
  const ::types::v1::HeatmapSlot& _internal_slots(int index) const;
  ::types::v1::HeatmapSlot* _internal_add_slots();
  public:
  const ::types::v1::HeatmapSlot& slots(int index) const;
  ::types::v1::HeatmapSlot* add_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::HeatmapSlot >&
      slots() const;

  // @@protoc_insertion_point(class_scope:types.v1.HeatmapSeries)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair > labels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::HeatmapSlot > slots_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class HeatmapSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.v1.HeatmapSlot) */ {
 public:
  inline HeatmapSlot() : HeatmapSlot(nullptr) {}
  ~HeatmapSlot() override;
  explicit PROTOBUF_CONSTEXPR HeatmapSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeatmapSlot(const HeatmapSlot& from);
  HeatmapSlot(HeatmapSlot&& from) noexcept
    : HeatmapSlot() {
    *this = ::std::move(from);
  }

  inline HeatmapSlot& operator=(const HeatmapSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeatmapSlot& operator=(HeatmapSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeatmapSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeatmapSlot* internal_default_instance() {
    return reinterpret_cast<const HeatmapSlot*>(
               &_HeatmapSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HeatmapSlot& a, HeatmapSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(HeatmapSlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeatmapSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeatmapSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeatmapSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeatmapSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeatmapSlot& from) {
    HeatmapSlot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeatmapSlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.v1.HeatmapSlot";
  }
  protected:
  explicit HeatmapSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYMinFieldNumber = 2,
    kCountsFieldNumber = 3,
    kExemplarsFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // repeated double y_min = 2;
  int y_min_size() const;
  private:
  int _internal_y_min_size() const;
  public:
  void clear_y_min();
  private:
  double _internal_y_min(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_y_min() const;
  void _internal_add_y_min(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_y_min();
  public:
  double y_min(int index) const;
  void set_y_min(int index, double value);
  void add_y_min(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      y_min() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_y_min();

  // repeated int32 counts = 3;
  int counts_size() const;
  private:
  int _internal_counts_size() const;
  public:
  void clear_counts();
  private:
  int32_t _internal_counts(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_counts() const;
  void _internal_add_counts(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_counts();
  public:
  int32_t counts(int index) const;
  void set_counts(int index, int32_t value);
  void add_counts(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      counts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_counts();

  // repeated .types.v1.Exemplar exemplars = 4;
  int exemplars_size() const;
  private:
  int _internal_exemplars_size() const;
  public:
  void clear_exemplars();
  ::types::v1::Exemplar* mutable_exemplars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >*
      mutable_exemplars();
  private:
  const ::types::v1::Exemplar& _internal_exemplars(int index) const;
  ::types::v1::Exemplar* _internal_add_exemplars();
  public:
  const ::types::v1::Exemplar& exemplars(int index) const;
  ::types::v1::Exemplar* add_exemplars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >&
      exemplars() const;

  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.v1.HeatmapSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > y_min_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > counts_;
    mutable std::atomic<int> _counts_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar > exemplars_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2fv1_2ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LabelPair

// string name = 1 [(.gnostic.openapi.v3.property) = {
inline void LabelPair::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LabelPair::name() const {
  // @@protoc_insertion_point(field_get:types.v1.LabelPair.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelPair::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.LabelPair.name)
}
inline std::string* LabelPair::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.v1.LabelPair.name)
  return _s;
}
inline const std::string& LabelPair::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LabelPair::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelPair::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelPair::release_name() {
  // @@protoc_insertion_point(field_release:types.v1.LabelPair.name)
  return _impl_.name_.Release();
}
inline void LabelPair::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.LabelPair.name)
}

// string value = 2 [(.gnostic.openapi.v3.property) = {
inline void LabelPair::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& LabelPair::value() const {
  // @@protoc_insertion_point(field_get:types.v1.LabelPair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelPair::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.LabelPair.value)
}
inline std::string* LabelPair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:types.v1.LabelPair.value)
  return _s;
}
inline const std::string& LabelPair::_internal_value() const {
  return _impl_.value_.Get();
}
inline void LabelPair::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelPair::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelPair::release_value() {
  // @@protoc_insertion_point(field_release:types.v1.LabelPair.value)
  return _impl_.value_.Release();
}
inline void LabelPair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.LabelPair.value)
}

// -------------------------------------------------------------------

// ProfileType

// string ID = 1;
inline void ProfileType::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ProfileType::id() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileType.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileType::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileType.ID)
}
inline std::string* ProfileType::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileType.ID)
  return _s;
}
inline const std::string& ProfileType::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ProfileType::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileType::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileType::release_id() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileType.ID)
  return _impl_.id_.Release();
}
inline void ProfileType::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileType.ID)
}

// string name = 2;
inline void ProfileType::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ProfileType::name() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileType::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileType.name)
}
inline std::string* ProfileType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileType.name)
  return _s;
}
inline const std::string& ProfileType::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ProfileType::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileType::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileType::release_name() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileType.name)
  return _impl_.name_.Release();
}
inline void ProfileType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileType.name)
}

// string sample_type = 4;
inline void ProfileType::clear_sample_type() {
  _impl_.sample_type_.ClearToEmpty();
}
inline const std::string& ProfileType::sample_type() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileType.sample_type)
  return _internal_sample_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileType::set_sample_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sample_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileType.sample_type)
}
inline std::string* ProfileType::mutable_sample_type() {
  std::string* _s = _internal_mutable_sample_type();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileType.sample_type)
  return _s;
}
inline const std::string& ProfileType::_internal_sample_type() const {
  return _impl_.sample_type_.Get();
}
inline void ProfileType::_internal_set_sample_type(const std::string& value) {
  
  _impl_.sample_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileType::_internal_mutable_sample_type() {
  
  return _impl_.sample_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileType::release_sample_type() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileType.sample_type)
  return _impl_.sample_type_.Release();
}
inline void ProfileType::set_allocated_sample_type(std::string* sample_type) {
  if (sample_type != nullptr) {
    
  } else {
    
  }
  _impl_.sample_type_.SetAllocated(sample_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sample_type_.IsDefault()) {
    _impl_.sample_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileType.sample_type)
}

// string sample_unit = 5;
inline void ProfileType::clear_sample_unit() {
  _impl_.sample_unit_.ClearToEmpty();
}
inline const std::string& ProfileType::sample_unit() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileType.sample_unit)
  return _internal_sample_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileType::set_sample_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sample_unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileType.sample_unit)
}
inline std::string* ProfileType::mutable_sample_unit() {
  std::string* _s = _internal_mutable_sample_unit();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileType.sample_unit)
  return _s;
}
inline const std::string& ProfileType::_internal_sample_unit() const {
  return _impl_.sample_unit_.Get();
}
inline void ProfileType::_internal_set_sample_unit(const std::string& value) {
  
  _impl_.sample_unit_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileType::_internal_mutable_sample_unit() {
  
  return _impl_.sample_unit_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileType::release_sample_unit() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileType.sample_unit)
  return _impl_.sample_unit_.Release();
}
inline void ProfileType::set_allocated_sample_unit(std::string* sample_unit) {
  if (sample_unit != nullptr) {
    
  } else {
    
  }
  _impl_.sample_unit_.SetAllocated(sample_unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sample_unit_.IsDefault()) {
    _impl_.sample_unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileType.sample_unit)
}

// string period_type = 6;
inline void ProfileType::clear_period_type() {
  _impl_.period_type_.ClearToEmpty();
}
inline const std::string& ProfileType::period_type() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileType.period_type)
  return _internal_period_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileType::set_period_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.period_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileType.period_type)
}
inline std::string* ProfileType::mutable_period_type() {
  std::string* _s = _internal_mutable_period_type();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileType.period_type)
  return _s;
}
inline const std::string& ProfileType::_internal_period_type() const {
  return _impl_.period_type_.Get();
}
inline void ProfileType::_internal_set_period_type(const std::string& value) {
  
  _impl_.period_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileType::_internal_mutable_period_type() {
  
  return _impl_.period_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileType::release_period_type() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileType.period_type)
  return _impl_.period_type_.Release();
}
inline void ProfileType::set_allocated_period_type(std::string* period_type) {
  if (period_type != nullptr) {
    
  } else {
    
  }
  _impl_.period_type_.SetAllocated(period_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.period_type_.IsDefault()) {
    _impl_.period_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileType.period_type)
}

// string period_unit = 7;
inline void ProfileType::clear_period_unit() {
  _impl_.period_unit_.ClearToEmpty();
}
inline const std::string& ProfileType::period_unit() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileType.period_unit)
  return _internal_period_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileType::set_period_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.period_unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileType.period_unit)
}
inline std::string* ProfileType::mutable_period_unit() {
  std::string* _s = _internal_mutable_period_unit();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileType.period_unit)
  return _s;
}
inline const std::string& ProfileType::_internal_period_unit() const {
  return _impl_.period_unit_.Get();
}
inline void ProfileType::_internal_set_period_unit(const std::string& value) {
  
  _impl_.period_unit_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileType::_internal_mutable_period_unit() {
  
  return _impl_.period_unit_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileType::release_period_unit() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileType.period_unit)
  return _impl_.period_unit_.Release();
}
inline void ProfileType::set_allocated_period_unit(std::string* period_unit) {
  if (period_unit != nullptr) {
    
  } else {
    
  }
  _impl_.period_unit_.SetAllocated(period_unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.period_unit_.IsDefault()) {
    _impl_.period_unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileType.period_unit)
}

// -------------------------------------------------------------------

// Labels

// repeated .types.v1.LabelPair labels = 1;
inline int Labels::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int Labels::labels_size() const {
  return _internal_labels_size();
}
inline void Labels::clear_labels() {
  _impl_.labels_.Clear();
}
inline ::types::v1::LabelPair* Labels::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.Labels.labels)
  return _impl_.labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
Labels::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.Labels.labels)
  return &_impl_.labels_;
}
inline const ::types::v1::LabelPair& Labels::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const ::types::v1::LabelPair& Labels::labels(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.Labels.labels)
  return _internal_labels(index);
}
inline ::types::v1::LabelPair* Labels::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline ::types::v1::LabelPair* Labels::add_labels() {
  ::types::v1::LabelPair* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:types.v1.Labels.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
Labels::labels() const {
  // @@protoc_insertion_point(field_list:types.v1.Labels.labels)
  return _impl_.labels_;
}

// -------------------------------------------------------------------

// Series

// repeated .types.v1.LabelPair labels = 1;
inline int Series::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int Series::labels_size() const {
  return _internal_labels_size();
}
inline void Series::clear_labels() {
  _impl_.labels_.Clear();
}
inline ::types::v1::LabelPair* Series::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.Series.labels)
  return _impl_.labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
Series::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.Series.labels)
  return &_impl_.labels_;
}
inline const ::types::v1::LabelPair& Series::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const ::types::v1::LabelPair& Series::labels(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.Series.labels)
  return _internal_labels(index);
}
inline ::types::v1::LabelPair* Series::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline ::types::v1::LabelPair* Series::add_labels() {
  ::types::v1::LabelPair* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:types.v1.Series.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
Series::labels() const {
  // @@protoc_insertion_point(field_list:types.v1.Series.labels)
  return _impl_.labels_;
}

// repeated .types.v1.Point points = 2;
inline int Series::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int Series::points_size() const {
  return _internal_points_size();
}
inline void Series::clear_points() {
  _impl_.points_.Clear();
}
inline ::types::v1::Point* Series::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.Series.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Point >*
Series::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.Series.points)
  return &_impl_.points_;
}
inline const ::types::v1::Point& Series::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::types::v1::Point& Series::points(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.Series.points)
  return _internal_points(index);
}
inline ::types::v1::Point* Series::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::types::v1::Point* Series::add_points() {
  ::types::v1::Point* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:types.v1.Series.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Point >&
Series::points() const {
  // @@protoc_insertion_point(field_list:types.v1.Series.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// Point

// double value = 1;
inline void Point::clear_value() {
  _impl_.value_ = 0;
}
inline double Point::_internal_value() const {
  return _impl_.value_;
}
inline double Point::value() const {
  // @@protoc_insertion_point(field_get:types.v1.Point.value)
  return _internal_value();
}
inline void Point::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void Point::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:types.v1.Point.value)
}

// int64 timestamp = 2;
inline void Point::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Point::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Point::timestamp() const {
  // @@protoc_insertion_point(field_get:types.v1.Point.timestamp)
  return _internal_timestamp();
}
inline void Point::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Point::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:types.v1.Point.timestamp)
}

// repeated .types.v1.ProfileAnnotation annotations = 3;
inline int Point::_internal_annotations_size() const {
  return _impl_.annotations_.size();
}
inline int Point::annotations_size() const {
  return _internal_annotations_size();
}
inline void Point::clear_annotations() {
  _impl_.annotations_.Clear();
}
inline ::types::v1::ProfileAnnotation* Point::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.Point.annotations)
  return _impl_.annotations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::ProfileAnnotation >*
Point::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.Point.annotations)
  return &_impl_.annotations_;
}
inline const ::types::v1::ProfileAnnotation& Point::_internal_annotations(int index) const {
  return _impl_.annotations_.Get(index);
}
inline const ::types::v1::ProfileAnnotation& Point::annotations(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.Point.annotations)
  return _internal_annotations(index);
}
inline ::types::v1::ProfileAnnotation* Point::_internal_add_annotations() {
  return _impl_.annotations_.Add();
}
inline ::types::v1::ProfileAnnotation* Point::add_annotations() {
  ::types::v1::ProfileAnnotation* _add = _internal_add_annotations();
  // @@protoc_insertion_point(field_add:types.v1.Point.annotations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::ProfileAnnotation >&
Point::annotations() const {
  // @@protoc_insertion_point(field_list:types.v1.Point.annotations)
  return _impl_.annotations_;
}

// repeated .types.v1.Exemplar exemplars = 4;
inline int Point::_internal_exemplars_size() const {
  return _impl_.exemplars_.size();
}
inline int Point::exemplars_size() const {
  return _internal_exemplars_size();
}
inline void Point::clear_exemplars() {
  _impl_.exemplars_.Clear();
}
inline ::types::v1::Exemplar* Point::mutable_exemplars(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.Point.exemplars)
  return _impl_.exemplars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >*
Point::mutable_exemplars() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.Point.exemplars)
  return &_impl_.exemplars_;
}
inline const ::types::v1::Exemplar& Point::_internal_exemplars(int index) const {
  return _impl_.exemplars_.Get(index);
}
inline const ::types::v1::Exemplar& Point::exemplars(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.Point.exemplars)
  return _internal_exemplars(index);
}
inline ::types::v1::Exemplar* Point::_internal_add_exemplars() {
  return _impl_.exemplars_.Add();
}
inline ::types::v1::Exemplar* Point::add_exemplars() {
  ::types::v1::Exemplar* _add = _internal_add_exemplars();
  // @@protoc_insertion_point(field_add:types.v1.Point.exemplars)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >&
Point::exemplars() const {
  // @@protoc_insertion_point(field_list:types.v1.Point.exemplars)
  return _impl_.exemplars_;
}

// -------------------------------------------------------------------

// ProfileAnnotation

// string key = 1;
inline void ProfileAnnotation::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ProfileAnnotation::key() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileAnnotation.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileAnnotation::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileAnnotation.key)
}
inline std::string* ProfileAnnotation::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileAnnotation.key)
  return _s;
}
inline const std::string& ProfileAnnotation::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ProfileAnnotation::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileAnnotation::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileAnnotation::release_key() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileAnnotation.key)
  return _impl_.key_.Release();
}
inline void ProfileAnnotation::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileAnnotation.key)
}

// string value = 2;
inline void ProfileAnnotation::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ProfileAnnotation::value() const {
  // @@protoc_insertion_point(field_get:types.v1.ProfileAnnotation.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileAnnotation::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.ProfileAnnotation.value)
}
inline std::string* ProfileAnnotation::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:types.v1.ProfileAnnotation.value)
  return _s;
}
inline const std::string& ProfileAnnotation::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ProfileAnnotation::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileAnnotation::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileAnnotation::release_value() {
  // @@protoc_insertion_point(field_release:types.v1.ProfileAnnotation.value)
  return _impl_.value_.Release();
}
inline void ProfileAnnotation::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.ProfileAnnotation.value)
}

// -------------------------------------------------------------------

// LabelValuesRequest

// string name = 1 [(.gnostic.openapi.v3.property) = {
inline void LabelValuesRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LabelValuesRequest::name() const {
  // @@protoc_insertion_point(field_get:types.v1.LabelValuesRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelValuesRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.LabelValuesRequest.name)
}
inline std::string* LabelValuesRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.v1.LabelValuesRequest.name)
  return _s;
}
inline const std::string& LabelValuesRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LabelValuesRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelValuesRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelValuesRequest::release_name() {
  // @@protoc_insertion_point(field_release:types.v1.LabelValuesRequest.name)
  return _impl_.name_.Release();
}
inline void LabelValuesRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.LabelValuesRequest.name)
}

// repeated string matchers = 2;
inline int LabelValuesRequest::_internal_matchers_size() const {
  return _impl_.matchers_.size();
}
inline int LabelValuesRequest::matchers_size() const {
  return _internal_matchers_size();
}
inline void LabelValuesRequest::clear_matchers() {
  _impl_.matchers_.Clear();
}
inline std::string* LabelValuesRequest::add_matchers() {
  std::string* _s = _internal_add_matchers();
  // @@protoc_insertion_point(field_add_mutable:types.v1.LabelValuesRequest.matchers)
  return _s;
}
inline const std::string& LabelValuesRequest::_internal_matchers(int index) const {
  return _impl_.matchers_.Get(index);
}
inline const std::string& LabelValuesRequest::matchers(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.LabelValuesRequest.matchers)
  return _internal_matchers(index);
}
inline std::string* LabelValuesRequest::mutable_matchers(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.LabelValuesRequest.matchers)
  return _impl_.matchers_.Mutable(index);
}
inline void LabelValuesRequest::set_matchers(int index, const std::string& value) {
  _impl_.matchers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelValuesRequest.matchers)
}
inline void LabelValuesRequest::set_matchers(int index, std::string&& value) {
  _impl_.matchers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.v1.LabelValuesRequest.matchers)
}
inline void LabelValuesRequest::set_matchers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.matchers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.v1.LabelValuesRequest.matchers)
}
inline void LabelValuesRequest::set_matchers(int index, const char* value, size_t size) {
  _impl_.matchers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.v1.LabelValuesRequest.matchers)
}
inline std::string* LabelValuesRequest::_internal_add_matchers() {
  return _impl_.matchers_.Add();
}
inline void LabelValuesRequest::add_matchers(const std::string& value) {
  _impl_.matchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.v1.LabelValuesRequest.matchers)
}
inline void LabelValuesRequest::add_matchers(std::string&& value) {
  _impl_.matchers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.v1.LabelValuesRequest.matchers)
}
inline void LabelValuesRequest::add_matchers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.matchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.v1.LabelValuesRequest.matchers)
}
inline void LabelValuesRequest::add_matchers(const char* value, size_t size) {
  _impl_.matchers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.v1.LabelValuesRequest.matchers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LabelValuesRequest::matchers() const {
  // @@protoc_insertion_point(field_list:types.v1.LabelValuesRequest.matchers)
  return _impl_.matchers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LabelValuesRequest::mutable_matchers() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.LabelValuesRequest.matchers)
  return &_impl_.matchers_;
}

// int64 start = 3 [(.gnostic.openapi.v3.property) = {
inline void LabelValuesRequest::clear_start() {
  _impl_.start_ = int64_t{0};
}
inline int64_t LabelValuesRequest::_internal_start() const {
  return _impl_.start_;
}
inline int64_t LabelValuesRequest::start() const {
  // @@protoc_insertion_point(field_get:types.v1.LabelValuesRequest.start)
  return _internal_start();
}
inline void LabelValuesRequest::_internal_set_start(int64_t value) {
  
  _impl_.start_ = value;
}
inline void LabelValuesRequest::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelValuesRequest.start)
}

// int64 end = 4 [(.gnostic.openapi.v3.property) = {
inline void LabelValuesRequest::clear_end() {
  _impl_.end_ = int64_t{0};
}
inline int64_t LabelValuesRequest::_internal_end() const {
  return _impl_.end_;
}
inline int64_t LabelValuesRequest::end() const {
  // @@protoc_insertion_point(field_get:types.v1.LabelValuesRequest.end)
  return _internal_end();
}
inline void LabelValuesRequest::_internal_set_end(int64_t value) {
  
  _impl_.end_ = value;
}
inline void LabelValuesRequest::set_end(int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelValuesRequest.end)
}

// -------------------------------------------------------------------

// LabelValuesResponse

// repeated string names = 1;
inline int LabelValuesResponse::_internal_names_size() const {
  return _impl_.names_.size();
}
inline int LabelValuesResponse::names_size() const {
  return _internal_names_size();
}
inline void LabelValuesResponse::clear_names() {
  _impl_.names_.Clear();
}
inline std::string* LabelValuesResponse::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:types.v1.LabelValuesResponse.names)
  return _s;
}
inline const std::string& LabelValuesResponse::_internal_names(int index) const {
  return _impl_.names_.Get(index);
}
inline const std::string& LabelValuesResponse::names(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.LabelValuesResponse.names)
  return _internal_names(index);
}
inline std::string* LabelValuesResponse::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.LabelValuesResponse.names)
  return _impl_.names_.Mutable(index);
}
inline void LabelValuesResponse::set_names(int index, const std::string& value) {
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelValuesResponse.names)
}
inline void LabelValuesResponse::set_names(int index, std::string&& value) {
  _impl_.names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.v1.LabelValuesResponse.names)
}
inline void LabelValuesResponse::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.v1.LabelValuesResponse.names)
}
inline void LabelValuesResponse::set_names(int index, const char* value, size_t size) {
  _impl_.names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.v1.LabelValuesResponse.names)
}
inline std::string* LabelValuesResponse::_internal_add_names() {
  return _impl_.names_.Add();
}
inline void LabelValuesResponse::add_names(const std::string& value) {
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.v1.LabelValuesResponse.names)
}
inline void LabelValuesResponse::add_names(std::string&& value) {
  _impl_.names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.v1.LabelValuesResponse.names)
}
inline void LabelValuesResponse::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.v1.LabelValuesResponse.names)
}
inline void LabelValuesResponse::add_names(const char* value, size_t size) {
  _impl_.names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.v1.LabelValuesResponse.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LabelValuesResponse::names() const {
  // @@protoc_insertion_point(field_list:types.v1.LabelValuesResponse.names)
  return _impl_.names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LabelValuesResponse::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.LabelValuesResponse.names)
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// LabelNamesRequest

// repeated string matchers = 1;
inline int LabelNamesRequest::_internal_matchers_size() const {
  return _impl_.matchers_.size();
}
inline int LabelNamesRequest::matchers_size() const {
  return _internal_matchers_size();
}
inline void LabelNamesRequest::clear_matchers() {
  _impl_.matchers_.Clear();
}
inline std::string* LabelNamesRequest::add_matchers() {
  std::string* _s = _internal_add_matchers();
  // @@protoc_insertion_point(field_add_mutable:types.v1.LabelNamesRequest.matchers)
  return _s;
}
inline const std::string& LabelNamesRequest::_internal_matchers(int index) const {
  return _impl_.matchers_.Get(index);
}
inline const std::string& LabelNamesRequest::matchers(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.LabelNamesRequest.matchers)
  return _internal_matchers(index);
}
inline std::string* LabelNamesRequest::mutable_matchers(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.LabelNamesRequest.matchers)
  return _impl_.matchers_.Mutable(index);
}
inline void LabelNamesRequest::set_matchers(int index, const std::string& value) {
  _impl_.matchers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelNamesRequest.matchers)
}
inline void LabelNamesRequest::set_matchers(int index, std::string&& value) {
  _impl_.matchers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.v1.LabelNamesRequest.matchers)
}
inline void LabelNamesRequest::set_matchers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.matchers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.v1.LabelNamesRequest.matchers)
}
inline void LabelNamesRequest::set_matchers(int index, const char* value, size_t size) {
  _impl_.matchers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.v1.LabelNamesRequest.matchers)
}
inline std::string* LabelNamesRequest::_internal_add_matchers() {
  return _impl_.matchers_.Add();
}
inline void LabelNamesRequest::add_matchers(const std::string& value) {
  _impl_.matchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.v1.LabelNamesRequest.matchers)
}
inline void LabelNamesRequest::add_matchers(std::string&& value) {
  _impl_.matchers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.v1.LabelNamesRequest.matchers)
}
inline void LabelNamesRequest::add_matchers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.matchers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.v1.LabelNamesRequest.matchers)
}
inline void LabelNamesRequest::add_matchers(const char* value, size_t size) {
  _impl_.matchers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.v1.LabelNamesRequest.matchers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LabelNamesRequest::matchers() const {
  // @@protoc_insertion_point(field_list:types.v1.LabelNamesRequest.matchers)
  return _impl_.matchers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LabelNamesRequest::mutable_matchers() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.LabelNamesRequest.matchers)
  return &_impl_.matchers_;
}

// int64 start = 2 [(.gnostic.openapi.v3.property) = {
inline void LabelNamesRequest::clear_start() {
  _impl_.start_ = int64_t{0};
}
inline int64_t LabelNamesRequest::_internal_start() const {
  return _impl_.start_;
}
inline int64_t LabelNamesRequest::start() const {
  // @@protoc_insertion_point(field_get:types.v1.LabelNamesRequest.start)
  return _internal_start();
}
inline void LabelNamesRequest::_internal_set_start(int64_t value) {
  
  _impl_.start_ = value;
}
inline void LabelNamesRequest::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelNamesRequest.start)
}

// int64 end = 3 [(.gnostic.openapi.v3.property) = {
inline void LabelNamesRequest::clear_end() {
  _impl_.end_ = int64_t{0};
}
inline int64_t LabelNamesRequest::_internal_end() const {
  return _impl_.end_;
}
inline int64_t LabelNamesRequest::end() const {
  // @@protoc_insertion_point(field_get:types.v1.LabelNamesRequest.end)
  return _internal_end();
}
inline void LabelNamesRequest::_internal_set_end(int64_t value) {
  
  _impl_.end_ = value;
}
inline void LabelNamesRequest::set_end(int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelNamesRequest.end)
}

// -------------------------------------------------------------------

// LabelNamesResponse

// repeated string names = 1;
inline int LabelNamesResponse::_internal_names_size() const {
  return _impl_.names_.size();
}
inline int LabelNamesResponse::names_size() const {
  return _internal_names_size();
}
inline void LabelNamesResponse::clear_names() {
  _impl_.names_.Clear();
}
inline std::string* LabelNamesResponse::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:types.v1.LabelNamesResponse.names)
  return _s;
}
inline const std::string& LabelNamesResponse::_internal_names(int index) const {
  return _impl_.names_.Get(index);
}
inline const std::string& LabelNamesResponse::names(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.LabelNamesResponse.names)
  return _internal_names(index);
}
inline std::string* LabelNamesResponse::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.LabelNamesResponse.names)
  return _impl_.names_.Mutable(index);
}
inline void LabelNamesResponse::set_names(int index, const std::string& value) {
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.v1.LabelNamesResponse.names)
}
inline void LabelNamesResponse::set_names(int index, std::string&& value) {
  _impl_.names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.v1.LabelNamesResponse.names)
}
inline void LabelNamesResponse::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.v1.LabelNamesResponse.names)
}
inline void LabelNamesResponse::set_names(int index, const char* value, size_t size) {
  _impl_.names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.v1.LabelNamesResponse.names)
}
inline std::string* LabelNamesResponse::_internal_add_names() {
  return _impl_.names_.Add();
}
inline void LabelNamesResponse::add_names(const std::string& value) {
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.v1.LabelNamesResponse.names)
}
inline void LabelNamesResponse::add_names(std::string&& value) {
  _impl_.names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.v1.LabelNamesResponse.names)
}
inline void LabelNamesResponse::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.v1.LabelNamesResponse.names)
}
inline void LabelNamesResponse::add_names(const char* value, size_t size) {
  _impl_.names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.v1.LabelNamesResponse.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LabelNamesResponse::names() const {
  // @@protoc_insertion_point(field_list:types.v1.LabelNamesResponse.names)
  return _impl_.names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LabelNamesResponse::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.LabelNamesResponse.names)
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// BlockInfo

// string ulid = 1;
inline void BlockInfo::clear_ulid() {
  _impl_.ulid_.ClearToEmpty();
}
inline const std::string& BlockInfo::ulid() const {
  // @@protoc_insertion_point(field_get:types.v1.BlockInfo.ulid)
  return _internal_ulid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockInfo::set_ulid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ulid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.BlockInfo.ulid)
}
inline std::string* BlockInfo::mutable_ulid() {
  std::string* _s = _internal_mutable_ulid();
  // @@protoc_insertion_point(field_mutable:types.v1.BlockInfo.ulid)
  return _s;
}
inline const std::string& BlockInfo::_internal_ulid() const {
  return _impl_.ulid_.Get();
}
inline void BlockInfo::_internal_set_ulid(const std::string& value) {
  
  _impl_.ulid_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockInfo::_internal_mutable_ulid() {
  
  return _impl_.ulid_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockInfo::release_ulid() {
  // @@protoc_insertion_point(field_release:types.v1.BlockInfo.ulid)
  return _impl_.ulid_.Release();
}
inline void BlockInfo::set_allocated_ulid(std::string* ulid) {
  if (ulid != nullptr) {
    
  } else {
    
  }
  _impl_.ulid_.SetAllocated(ulid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ulid_.IsDefault()) {
    _impl_.ulid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.BlockInfo.ulid)
}

// int64 min_time = 2;
inline void BlockInfo::clear_min_time() {
  _impl_.min_time_ = int64_t{0};
}
inline int64_t BlockInfo::_internal_min_time() const {
  return _impl_.min_time_;
}
inline int64_t BlockInfo::min_time() const {
  // @@protoc_insertion_point(field_get:types.v1.BlockInfo.min_time)
  return _internal_min_time();
}
inline void BlockInfo::_internal_set_min_time(int64_t value) {
  
  _impl_.min_time_ = value;
}
inline void BlockInfo::set_min_time(int64_t value) {
  _internal_set_min_time(value);
  // @@protoc_insertion_point(field_set:types.v1.BlockInfo.min_time)
}

// int64 max_time = 3;
inline void BlockInfo::clear_max_time() {
  _impl_.max_time_ = int64_t{0};
}
inline int64_t BlockInfo::_internal_max_time() const {
  return _impl_.max_time_;
}
inline int64_t BlockInfo::max_time() const {
  // @@protoc_insertion_point(field_get:types.v1.BlockInfo.max_time)
  return _internal_max_time();
}
inline void BlockInfo::_internal_set_max_time(int64_t value) {
  
  _impl_.max_time_ = value;
}
inline void BlockInfo::set_max_time(int64_t value) {
  _internal_set_max_time(value);
  // @@protoc_insertion_point(field_set:types.v1.BlockInfo.max_time)
}

// .types.v1.BlockCompaction compaction = 4;
inline bool BlockInfo::_internal_has_compaction() const {
  return this != internal_default_instance() && _impl_.compaction_ != nullptr;
}
inline bool BlockInfo::has_compaction() const {
  return _internal_has_compaction();
}
inline void BlockInfo::clear_compaction() {
  if (GetArenaForAllocation() == nullptr && _impl_.compaction_ != nullptr) {
    delete _impl_.compaction_;
  }
  _impl_.compaction_ = nullptr;
}
inline const ::types::v1::BlockCompaction& BlockInfo::_internal_compaction() const {
  const ::types::v1::BlockCompaction* p = _impl_.compaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::v1::BlockCompaction&>(
      ::types::v1::_BlockCompaction_default_instance_);
}
inline const ::types::v1::BlockCompaction& BlockInfo::compaction() const {
  // @@protoc_insertion_point(field_get:types.v1.BlockInfo.compaction)
  return _internal_compaction();
}
inline void BlockInfo::unsafe_arena_set_allocated_compaction(
    ::types::v1::BlockCompaction* compaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compaction_);
  }
  _impl_.compaction_ = compaction;
  if (compaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.v1.BlockInfo.compaction)
}
inline ::types::v1::BlockCompaction* BlockInfo::release_compaction() {
  
  ::types::v1::BlockCompaction* temp = _impl_.compaction_;
  _impl_.compaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::v1::BlockCompaction* BlockInfo::unsafe_arena_release_compaction() {
  // @@protoc_insertion_point(field_release:types.v1.BlockInfo.compaction)
  
  ::types::v1::BlockCompaction* temp = _impl_.compaction_;
  _impl_.compaction_ = nullptr;
  return temp;
}
inline ::types::v1::BlockCompaction* BlockInfo::_internal_mutable_compaction() {
  
  if (_impl_.compaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::v1::BlockCompaction>(GetArenaForAllocation());
    _impl_.compaction_ = p;
  }
  return _impl_.compaction_;
}
inline ::types::v1::BlockCompaction* BlockInfo::mutable_compaction() {
  ::types::v1::BlockCompaction* _msg = _internal_mutable_compaction();
  // @@protoc_insertion_point(field_mutable:types.v1.BlockInfo.compaction)
  return _msg;
}
inline void BlockInfo::set_allocated_compaction(::types::v1::BlockCompaction* compaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compaction_;
  }
  if (compaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compaction);
    if (message_arena != submessage_arena) {
      compaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.compaction_ = compaction;
  // @@protoc_insertion_point(field_set_allocated:types.v1.BlockInfo.compaction)
}

// repeated .types.v1.LabelPair labels = 5;
inline int BlockInfo::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int BlockInfo::labels_size() const {
  return _internal_labels_size();
}
inline void BlockInfo::clear_labels() {
  _impl_.labels_.Clear();
}
inline ::types::v1::LabelPair* BlockInfo::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.BlockInfo.labels)
  return _impl_.labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
BlockInfo::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.BlockInfo.labels)
  return &_impl_.labels_;
}
inline const ::types::v1::LabelPair& BlockInfo::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const ::types::v1::LabelPair& BlockInfo::labels(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.BlockInfo.labels)
  return _internal_labels(index);
}
inline ::types::v1::LabelPair* BlockInfo::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline ::types::v1::LabelPair* BlockInfo::add_labels() {
  ::types::v1::LabelPair* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:types.v1.BlockInfo.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
BlockInfo::labels() const {
  // @@protoc_insertion_point(field_list:types.v1.BlockInfo.labels)
  return _impl_.labels_;
}

// -------------------------------------------------------------------

// BlockCompaction

// int32 level = 1;
inline void BlockCompaction::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t BlockCompaction::_internal_level() const {
  return _impl_.level_;
}
inline int32_t BlockCompaction::level() const {
  // @@protoc_insertion_point(field_get:types.v1.BlockCompaction.level)
  return _internal_level();
}
inline void BlockCompaction::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void BlockCompaction::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:types.v1.BlockCompaction.level)
}

// repeated string sources = 2;
inline int BlockCompaction::_internal_sources_size() const {
  return _impl_.sources_.size();
}
inline int BlockCompaction::sources_size() const {
  return _internal_sources_size();
}
inline void BlockCompaction::clear_sources() {
  _impl_.sources_.Clear();
}
inline std::string* BlockCompaction::add_sources() {
  std::string* _s = _internal_add_sources();
  // @@protoc_insertion_point(field_add_mutable:types.v1.BlockCompaction.sources)
  return _s;
}
inline const std::string& BlockCompaction::_internal_sources(int index) const {
  return _impl_.sources_.Get(index);
}
inline const std::string& BlockCompaction::sources(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.BlockCompaction.sources)
  return _internal_sources(index);
}
inline std::string* BlockCompaction::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.BlockCompaction.sources)
  return _impl_.sources_.Mutable(index);
}
inline void BlockCompaction::set_sources(int index, const std::string& value) {
  _impl_.sources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.v1.BlockCompaction.sources)
}
inline void BlockCompaction::set_sources(int index, std::string&& value) {
  _impl_.sources_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.v1.BlockCompaction.sources)
}
inline void BlockCompaction::set_sources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.v1.BlockCompaction.sources)
}
inline void BlockCompaction::set_sources(int index, const char* value, size_t size) {
  _impl_.sources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.v1.BlockCompaction.sources)
}
inline std::string* BlockCompaction::_internal_add_sources() {
  return _impl_.sources_.Add();
}
inline void BlockCompaction::add_sources(const std::string& value) {
  _impl_.sources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.v1.BlockCompaction.sources)
}
inline void BlockCompaction::add_sources(std::string&& value) {
  _impl_.sources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.v1.BlockCompaction.sources)
}
inline void BlockCompaction::add_sources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.v1.BlockCompaction.sources)
}
inline void BlockCompaction::add_sources(const char* value, size_t size) {
  _impl_.sources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.v1.BlockCompaction.sources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockCompaction::sources() const {
  // @@protoc_insertion_point(field_list:types.v1.BlockCompaction.sources)
  return _impl_.sources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockCompaction::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.BlockCompaction.sources)
  return &_impl_.sources_;
}

// repeated string parents = 3;
inline int BlockCompaction::_internal_parents_size() const {
  return _impl_.parents_.size();
}
inline int BlockCompaction::parents_size() const {
  return _internal_parents_size();
}
inline void BlockCompaction::clear_parents() {
  _impl_.parents_.Clear();
}
inline std::string* BlockCompaction::add_parents() {
  std::string* _s = _internal_add_parents();
  // @@protoc_insertion_point(field_add_mutable:types.v1.BlockCompaction.parents)
  return _s;
}
inline const std::string& BlockCompaction::_internal_parents(int index) const {
  return _impl_.parents_.Get(index);
}
inline const std::string& BlockCompaction::parents(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.BlockCompaction.parents)
  return _internal_parents(index);
}
inline std::string* BlockCompaction::mutable_parents(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.BlockCompaction.parents)
  return _impl_.parents_.Mutable(index);
}
inline void BlockCompaction::set_parents(int index, const std::string& value) {
  _impl_.parents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.v1.BlockCompaction.parents)
}
inline void BlockCompaction::set_parents(int index, std::string&& value) {
  _impl_.parents_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.v1.BlockCompaction.parents)
}
inline void BlockCompaction::set_parents(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.parents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.v1.BlockCompaction.parents)
}
inline void BlockCompaction::set_parents(int index, const char* value, size_t size) {
  _impl_.parents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.v1.BlockCompaction.parents)
}
inline std::string* BlockCompaction::_internal_add_parents() {
  return _impl_.parents_.Add();
}
inline void BlockCompaction::add_parents(const std::string& value) {
  _impl_.parents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.v1.BlockCompaction.parents)
}
inline void BlockCompaction::add_parents(std::string&& value) {
  _impl_.parents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.v1.BlockCompaction.parents)
}
inline void BlockCompaction::add_parents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.parents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.v1.BlockCompaction.parents)
}
inline void BlockCompaction::add_parents(const char* value, size_t size) {
  _impl_.parents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.v1.BlockCompaction.parents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockCompaction::parents() const {
  // @@protoc_insertion_point(field_list:types.v1.BlockCompaction.parents)
  return _impl_.parents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockCompaction::mutable_parents() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.BlockCompaction.parents)
  return &_impl_.parents_;
}

// -------------------------------------------------------------------

// StackTraceSelector

// repeated .types.v1.Location call_site = 1;
inline int StackTraceSelector::_internal_call_site_size() const {
  return _impl_.call_site_.size();
}
inline int StackTraceSelector::call_site_size() const {
  return _internal_call_site_size();
}
inline void StackTraceSelector::clear_call_site() {
  _impl_.call_site_.Clear();
}
inline ::types::v1::Location* StackTraceSelector::mutable_call_site(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.StackTraceSelector.call_site)
  return _impl_.call_site_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Location >*
StackTraceSelector::mutable_call_site() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.StackTraceSelector.call_site)
  return &_impl_.call_site_;
}
inline const ::types::v1::Location& StackTraceSelector::_internal_call_site(int index) const {
  return _impl_.call_site_.Get(index);
}
inline const ::types::v1::Location& StackTraceSelector::call_site(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.StackTraceSelector.call_site)
  return _internal_call_site(index);
}
inline ::types::v1::Location* StackTraceSelector::_internal_add_call_site() {
  return _impl_.call_site_.Add();
}
inline ::types::v1::Location* StackTraceSelector::add_call_site() {
  ::types::v1::Location* _add = _internal_add_call_site();
  // @@protoc_insertion_point(field_add:types.v1.StackTraceSelector.call_site)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Location >&
StackTraceSelector::call_site() const {
  // @@protoc_insertion_point(field_list:types.v1.StackTraceSelector.call_site)
  return _impl_.call_site_;
}

// .types.v1.GoPGO go_pgo = 2;
inline bool StackTraceSelector::_internal_has_go_pgo() const {
  return this != internal_default_instance() && _impl_.go_pgo_ != nullptr;
}
inline bool StackTraceSelector::has_go_pgo() const {
  return _internal_has_go_pgo();
}
inline void StackTraceSelector::clear_go_pgo() {
  if (GetArenaForAllocation() == nullptr && _impl_.go_pgo_ != nullptr) {
    delete _impl_.go_pgo_;
  }
  _impl_.go_pgo_ = nullptr;
}
inline const ::types::v1::GoPGO& StackTraceSelector::_internal_go_pgo() const {
  const ::types::v1::GoPGO* p = _impl_.go_pgo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::v1::GoPGO&>(
      ::types::v1::_GoPGO_default_instance_);
}
inline const ::types::v1::GoPGO& StackTraceSelector::go_pgo() const {
  // @@protoc_insertion_point(field_get:types.v1.StackTraceSelector.go_pgo)
  return _internal_go_pgo();
}
inline void StackTraceSelector::unsafe_arena_set_allocated_go_pgo(
    ::types::v1::GoPGO* go_pgo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.go_pgo_);
  }
  _impl_.go_pgo_ = go_pgo;
  if (go_pgo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.v1.StackTraceSelector.go_pgo)
}
inline ::types::v1::GoPGO* StackTraceSelector::release_go_pgo() {
  
  ::types::v1::GoPGO* temp = _impl_.go_pgo_;
  _impl_.go_pgo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::v1::GoPGO* StackTraceSelector::unsafe_arena_release_go_pgo() {
  // @@protoc_insertion_point(field_release:types.v1.StackTraceSelector.go_pgo)
  
  ::types::v1::GoPGO* temp = _impl_.go_pgo_;
  _impl_.go_pgo_ = nullptr;
  return temp;
}
inline ::types::v1::GoPGO* StackTraceSelector::_internal_mutable_go_pgo() {
  
  if (_impl_.go_pgo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::v1::GoPGO>(GetArenaForAllocation());
    _impl_.go_pgo_ = p;
  }
  return _impl_.go_pgo_;
}
inline ::types::v1::GoPGO* StackTraceSelector::mutable_go_pgo() {
  ::types::v1::GoPGO* _msg = _internal_mutable_go_pgo();
  // @@protoc_insertion_point(field_mutable:types.v1.StackTraceSelector.go_pgo)
  return _msg;
}
inline void StackTraceSelector::set_allocated_go_pgo(::types::v1::GoPGO* go_pgo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.go_pgo_;
  }
  if (go_pgo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(go_pgo);
    if (message_arena != submessage_arena) {
      go_pgo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, go_pgo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.go_pgo_ = go_pgo;
  // @@protoc_insertion_point(field_set_allocated:types.v1.StackTraceSelector.go_pgo)
}

// -------------------------------------------------------------------

// Location

// string name = 1;
inline void Location::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Location::name() const {
  // @@protoc_insertion_point(field_get:types.v1.Location.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.Location.name)
}
inline std::string* Location::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.v1.Location.name)
  return _s;
}
inline const std::string& Location::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Location::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_name() {
  // @@protoc_insertion_point(field_release:types.v1.Location.name)
  return _impl_.name_.Release();
}
inline void Location::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.Location.name)
}

// -------------------------------------------------------------------

// GoPGO

// uint32 keep_locations = 1;
inline void GoPGO::clear_keep_locations() {
  _impl_.keep_locations_ = 0u;
}
inline uint32_t GoPGO::_internal_keep_locations() const {
  return _impl_.keep_locations_;
}
inline uint32_t GoPGO::keep_locations() const {
  // @@protoc_insertion_point(field_get:types.v1.GoPGO.keep_locations)
  return _internal_keep_locations();
}
inline void GoPGO::_internal_set_keep_locations(uint32_t value) {
  
  _impl_.keep_locations_ = value;
}
inline void GoPGO::set_keep_locations(uint32_t value) {
  _internal_set_keep_locations(value);
  // @@protoc_insertion_point(field_set:types.v1.GoPGO.keep_locations)
}

// bool aggregate_callees = 2;
inline void GoPGO::clear_aggregate_callees() {
  _impl_.aggregate_callees_ = false;
}
inline bool GoPGO::_internal_aggregate_callees() const {
  return _impl_.aggregate_callees_;
}
inline bool GoPGO::aggregate_callees() const {
  // @@protoc_insertion_point(field_get:types.v1.GoPGO.aggregate_callees)
  return _internal_aggregate_callees();
}
inline void GoPGO::_internal_set_aggregate_callees(bool value) {
  
  _impl_.aggregate_callees_ = value;
}
inline void GoPGO::set_aggregate_callees(bool value) {
  _internal_set_aggregate_callees(value);
  // @@protoc_insertion_point(field_set:types.v1.GoPGO.aggregate_callees)
}

// -------------------------------------------------------------------

// GetProfileStatsRequest

// -------------------------------------------------------------------

// GetProfileStatsResponse

// bool data_ingested = 1;
inline void GetProfileStatsResponse::clear_data_ingested() {
  _impl_.data_ingested_ = false;
}
inline bool GetProfileStatsResponse::_internal_data_ingested() const {
  return _impl_.data_ingested_;
}
inline bool GetProfileStatsResponse::data_ingested() const {
  // @@protoc_insertion_point(field_get:types.v1.GetProfileStatsResponse.data_ingested)
  return _internal_data_ingested();
}
inline void GetProfileStatsResponse::_internal_set_data_ingested(bool value) {
  
  _impl_.data_ingested_ = value;
}
inline void GetProfileStatsResponse::set_data_ingested(bool value) {
  _internal_set_data_ingested(value);
  // @@protoc_insertion_point(field_set:types.v1.GetProfileStatsResponse.data_ingested)
}

// int64 oldest_profile_time = 2;
inline void GetProfileStatsResponse::clear_oldest_profile_time() {
  _impl_.oldest_profile_time_ = int64_t{0};
}
inline int64_t GetProfileStatsResponse::_internal_oldest_profile_time() const {
  return _impl_.oldest_profile_time_;
}
inline int64_t GetProfileStatsResponse::oldest_profile_time() const {
  // @@protoc_insertion_point(field_get:types.v1.GetProfileStatsResponse.oldest_profile_time)
  return _internal_oldest_profile_time();
}
inline void GetProfileStatsResponse::_internal_set_oldest_profile_time(int64_t value) {
  
  _impl_.oldest_profile_time_ = value;
}
inline void GetProfileStatsResponse::set_oldest_profile_time(int64_t value) {
  _internal_set_oldest_profile_time(value);
  // @@protoc_insertion_point(field_set:types.v1.GetProfileStatsResponse.oldest_profile_time)
}

// int64 newest_profile_time = 3;
inline void GetProfileStatsResponse::clear_newest_profile_time() {
  _impl_.newest_profile_time_ = int64_t{0};
}
inline int64_t GetProfileStatsResponse::_internal_newest_profile_time() const {
  return _impl_.newest_profile_time_;
}
inline int64_t GetProfileStatsResponse::newest_profile_time() const {
  // @@protoc_insertion_point(field_get:types.v1.GetProfileStatsResponse.newest_profile_time)
  return _internal_newest_profile_time();
}
inline void GetProfileStatsResponse::_internal_set_newest_profile_time(int64_t value) {
  
  _impl_.newest_profile_time_ = value;
}
inline void GetProfileStatsResponse::set_newest_profile_time(int64_t value) {
  _internal_set_newest_profile_time(value);
  // @@protoc_insertion_point(field_set:types.v1.GetProfileStatsResponse.newest_profile_time)
}

// -------------------------------------------------------------------

// Exemplar

// int64 timestamp = 1 [(.gnostic.openapi.v3.property) = {
inline void Exemplar::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Exemplar::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Exemplar::timestamp() const {
  // @@protoc_insertion_point(field_get:types.v1.Exemplar.timestamp)
  return _internal_timestamp();
}
inline void Exemplar::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Exemplar::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:types.v1.Exemplar.timestamp)
}

// string profile_id = 2 [(.gnostic.openapi.v3.property) = {
inline void Exemplar::clear_profile_id() {
  _impl_.profile_id_.ClearToEmpty();
}
inline const std::string& Exemplar::profile_id() const {
  // @@protoc_insertion_point(field_get:types.v1.Exemplar.profile_id)
  return _internal_profile_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Exemplar::set_profile_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.profile_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.Exemplar.profile_id)
}
inline std::string* Exemplar::mutable_profile_id() {
  std::string* _s = _internal_mutable_profile_id();
  // @@protoc_insertion_point(field_mutable:types.v1.Exemplar.profile_id)
  return _s;
}
inline const std::string& Exemplar::_internal_profile_id() const {
  return _impl_.profile_id_.Get();
}
inline void Exemplar::_internal_set_profile_id(const std::string& value) {
  
  _impl_.profile_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Exemplar::_internal_mutable_profile_id() {
  
  return _impl_.profile_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Exemplar::release_profile_id() {
  // @@protoc_insertion_point(field_release:types.v1.Exemplar.profile_id)
  return _impl_.profile_id_.Release();
}
inline void Exemplar::set_allocated_profile_id(std::string* profile_id) {
  if (profile_id != nullptr) {
    
  } else {
    
  }
  _impl_.profile_id_.SetAllocated(profile_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profile_id_.IsDefault()) {
    _impl_.profile_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.Exemplar.profile_id)
}

// string span_id = 3 [(.gnostic.openapi.v3.property) = {
inline void Exemplar::clear_span_id() {
  _impl_.span_id_.ClearToEmpty();
}
inline const std::string& Exemplar::span_id() const {
  // @@protoc_insertion_point(field_get:types.v1.Exemplar.span_id)
  return _internal_span_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Exemplar::set_span_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.span_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.v1.Exemplar.span_id)
}
inline std::string* Exemplar::mutable_span_id() {
  std::string* _s = _internal_mutable_span_id();
  // @@protoc_insertion_point(field_mutable:types.v1.Exemplar.span_id)
  return _s;
}
inline const std::string& Exemplar::_internal_span_id() const {
  return _impl_.span_id_.Get();
}
inline void Exemplar::_internal_set_span_id(const std::string& value) {
  
  _impl_.span_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Exemplar::_internal_mutable_span_id() {
  
  return _impl_.span_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Exemplar::release_span_id() {
  // @@protoc_insertion_point(field_release:types.v1.Exemplar.span_id)
  return _impl_.span_id_.Release();
}
inline void Exemplar::set_allocated_span_id(std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  _impl_.span_id_.SetAllocated(span_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.span_id_.IsDefault()) {
    _impl_.span_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.v1.Exemplar.span_id)
}

// int64 value = 4 [(.gnostic.openapi.v3.property) = {
inline void Exemplar::clear_value() {
  _impl_.value_ = int64_t{0};
}
inline int64_t Exemplar::_internal_value() const {
  return _impl_.value_;
}
inline int64_t Exemplar::value() const {
  // @@protoc_insertion_point(field_get:types.v1.Exemplar.value)
  return _internal_value();
}
inline void Exemplar::_internal_set_value(int64_t value) {
  
  _impl_.value_ = value;
}
inline void Exemplar::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:types.v1.Exemplar.value)
}

// repeated .types.v1.LabelPair labels = 5;
inline int Exemplar::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int Exemplar::labels_size() const {
  return _internal_labels_size();
}
inline void Exemplar::clear_labels() {
  _impl_.labels_.Clear();
}
inline ::types::v1::LabelPair* Exemplar::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.Exemplar.labels)
  return _impl_.labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
Exemplar::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.Exemplar.labels)
  return &_impl_.labels_;
}
inline const ::types::v1::LabelPair& Exemplar::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const ::types::v1::LabelPair& Exemplar::labels(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.Exemplar.labels)
  return _internal_labels(index);
}
inline ::types::v1::LabelPair* Exemplar::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline ::types::v1::LabelPair* Exemplar::add_labels() {
  ::types::v1::LabelPair* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:types.v1.Exemplar.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
Exemplar::labels() const {
  // @@protoc_insertion_point(field_list:types.v1.Exemplar.labels)
  return _impl_.labels_;
}

// -------------------------------------------------------------------

// HeatmapSeries

// repeated .types.v1.LabelPair labels = 1;
inline int HeatmapSeries::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int HeatmapSeries::labels_size() const {
  return _internal_labels_size();
}
inline void HeatmapSeries::clear_labels() {
  _impl_.labels_.Clear();
}
inline ::types::v1::LabelPair* HeatmapSeries::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.HeatmapSeries.labels)
  return _impl_.labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >*
HeatmapSeries::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.HeatmapSeries.labels)
  return &_impl_.labels_;
}
inline const ::types::v1::LabelPair& HeatmapSeries::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const ::types::v1::LabelPair& HeatmapSeries::labels(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.HeatmapSeries.labels)
  return _internal_labels(index);
}
inline ::types::v1::LabelPair* HeatmapSeries::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline ::types::v1::LabelPair* HeatmapSeries::add_labels() {
  ::types::v1::LabelPair* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:types.v1.HeatmapSeries.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::LabelPair >&
HeatmapSeries::labels() const {
  // @@protoc_insertion_point(field_list:types.v1.HeatmapSeries.labels)
  return _impl_.labels_;
}

// repeated .types.v1.HeatmapSlot slots = 2;
inline int HeatmapSeries::_internal_slots_size() const {
  return _impl_.slots_.size();
}
inline int HeatmapSeries::slots_size() const {
  return _internal_slots_size();
}
inline void HeatmapSeries::clear_slots() {
  _impl_.slots_.Clear();
}
inline ::types::v1::HeatmapSlot* HeatmapSeries::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.HeatmapSeries.slots)
  return _impl_.slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::HeatmapSlot >*
HeatmapSeries::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.HeatmapSeries.slots)
  return &_impl_.slots_;
}
inline const ::types::v1::HeatmapSlot& HeatmapSeries::_internal_slots(int index) const {
  return _impl_.slots_.Get(index);
}
inline const ::types::v1::HeatmapSlot& HeatmapSeries::slots(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.HeatmapSeries.slots)
  return _internal_slots(index);
}
inline ::types::v1::HeatmapSlot* HeatmapSeries::_internal_add_slots() {
  return _impl_.slots_.Add();
}
inline ::types::v1::HeatmapSlot* HeatmapSeries::add_slots() {
  ::types::v1::HeatmapSlot* _add = _internal_add_slots();
  // @@protoc_insertion_point(field_add:types.v1.HeatmapSeries.slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::HeatmapSlot >&
HeatmapSeries::slots() const {
  // @@protoc_insertion_point(field_list:types.v1.HeatmapSeries.slots)
  return _impl_.slots_;
}

// -------------------------------------------------------------------

// HeatmapSlot

// int64 timestamp = 1;
inline void HeatmapSlot::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t HeatmapSlot::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t HeatmapSlot::timestamp() const {
  // @@protoc_insertion_point(field_get:types.v1.HeatmapSlot.timestamp)
  return _internal_timestamp();
}
inline void HeatmapSlot::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void HeatmapSlot::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:types.v1.HeatmapSlot.timestamp)
}

// repeated double y_min = 2;
inline int HeatmapSlot::_internal_y_min_size() const {
  return _impl_.y_min_.size();
}
inline int HeatmapSlot::y_min_size() const {
  return _internal_y_min_size();
}
inline void HeatmapSlot::clear_y_min() {
  _impl_.y_min_.Clear();
}
inline double HeatmapSlot::_internal_y_min(int index) const {
  return _impl_.y_min_.Get(index);
}
inline double HeatmapSlot::y_min(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.HeatmapSlot.y_min)
  return _internal_y_min(index);
}
inline void HeatmapSlot::set_y_min(int index, double value) {
  _impl_.y_min_.Set(index, value);
  // @@protoc_insertion_point(field_set:types.v1.HeatmapSlot.y_min)
}
inline void HeatmapSlot::_internal_add_y_min(double value) {
  _impl_.y_min_.Add(value);
}
inline void HeatmapSlot::add_y_min(double value) {
  _internal_add_y_min(value);
  // @@protoc_insertion_point(field_add:types.v1.HeatmapSlot.y_min)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
HeatmapSlot::_internal_y_min() const {
  return _impl_.y_min_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
HeatmapSlot::y_min() const {
  // @@protoc_insertion_point(field_list:types.v1.HeatmapSlot.y_min)
  return _internal_y_min();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
HeatmapSlot::_internal_mutable_y_min() {
  return &_impl_.y_min_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
HeatmapSlot::mutable_y_min() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.HeatmapSlot.y_min)
  return _internal_mutable_y_min();
}

// repeated int32 counts = 3;
inline int HeatmapSlot::_internal_counts_size() const {
  return _impl_.counts_.size();
}
inline int HeatmapSlot::counts_size() const {
  return _internal_counts_size();
}
inline void HeatmapSlot::clear_counts() {
  _impl_.counts_.Clear();
}
inline int32_t HeatmapSlot::_internal_counts(int index) const {
  return _impl_.counts_.Get(index);
}
inline int32_t HeatmapSlot::counts(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.HeatmapSlot.counts)
  return _internal_counts(index);
}
inline void HeatmapSlot::set_counts(int index, int32_t value) {
  _impl_.counts_.Set(index, value);
  // @@protoc_insertion_point(field_set:types.v1.HeatmapSlot.counts)
}
inline void HeatmapSlot::_internal_add_counts(int32_t value) {
  _impl_.counts_.Add(value);
}
inline void HeatmapSlot::add_counts(int32_t value) {
  _internal_add_counts(value);
  // @@protoc_insertion_point(field_add:types.v1.HeatmapSlot.counts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
HeatmapSlot::_internal_counts() const {
  return _impl_.counts_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
HeatmapSlot::counts() const {
  // @@protoc_insertion_point(field_list:types.v1.HeatmapSlot.counts)
  return _internal_counts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
HeatmapSlot::_internal_mutable_counts() {
  return &_impl_.counts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
HeatmapSlot::mutable_counts() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.HeatmapSlot.counts)
  return _internal_mutable_counts();
}

// repeated .types.v1.Exemplar exemplars = 4;
inline int HeatmapSlot::_internal_exemplars_size() const {
  return _impl_.exemplars_.size();
}
inline int HeatmapSlot::exemplars_size() const {
  return _internal_exemplars_size();
}
inline void HeatmapSlot::clear_exemplars() {
  _impl_.exemplars_.Clear();
}
inline ::types::v1::Exemplar* HeatmapSlot::mutable_exemplars(int index) {
  // @@protoc_insertion_point(field_mutable:types.v1.HeatmapSlot.exemplars)
  return _impl_.exemplars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >*
HeatmapSlot::mutable_exemplars() {
  // @@protoc_insertion_point(field_mutable_list:types.v1.HeatmapSlot.exemplars)
  return &_impl_.exemplars_;
}
inline const ::types::v1::Exemplar& HeatmapSlot::_internal_exemplars(int index) const {
  return _impl_.exemplars_.Get(index);
}
inline const ::types::v1::Exemplar& HeatmapSlot::exemplars(int index) const {
  // @@protoc_insertion_point(field_get:types.v1.HeatmapSlot.exemplars)
  return _internal_exemplars(index);
}
inline ::types::v1::Exemplar* HeatmapSlot::_internal_add_exemplars() {
  return _impl_.exemplars_.Add();
}
inline ::types::v1::Exemplar* HeatmapSlot::add_exemplars() {
  ::types::v1::Exemplar* _add = _internal_add_exemplars();
  // @@protoc_insertion_point(field_add:types.v1.HeatmapSlot.exemplars)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::v1::Exemplar >&
HeatmapSlot::exemplars() const {
  // @@protoc_insertion_point(field_list:types.v1.HeatmapSlot.exemplars)
  return _impl_.exemplars_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace types

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::types::v1::TimeSeriesAggregationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::types::v1::TimeSeriesAggregationType>() {
  return ::types::v1::TimeSeriesAggregationType_descriptor();
}
template <> struct is_proto_enum< ::types::v1::ExemplarType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::types::v1::ExemplarType>() {
  return ::types::v1::ExemplarType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_types_2fv1_2ftypes_2eproto

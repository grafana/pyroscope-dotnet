// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gnostic/openapi/v3/openapiv3.proto

#include "gnostic/openapi/v3/openapiv3.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace gnostic {
namespace openapi {
namespace v3 {
PROTOBUF_CONSTEXPR AdditionalPropertiesItem::AdditionalPropertiesItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AdditionalPropertiesItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AdditionalPropertiesItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AdditionalPropertiesItemDefaultTypeInternal() {}
  union {
    AdditionalPropertiesItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AdditionalPropertiesItemDefaultTypeInternal _AdditionalPropertiesItem_default_instance_;
PROTOBUF_CONSTEXPR Any::Any(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.yaml_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AnyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnyDefaultTypeInternal() {}
  union {
    Any _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnyDefaultTypeInternal _Any_default_instance_;
PROTOBUF_CONSTEXPR AnyOrExpression::AnyOrExpression(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AnyOrExpressionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnyOrExpressionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnyOrExpressionDefaultTypeInternal() {}
  union {
    AnyOrExpression _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnyOrExpressionDefaultTypeInternal _AnyOrExpression_default_instance_;
PROTOBUF_CONSTEXPR Callback::Callback(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CallbackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallbackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallbackDefaultTypeInternal() {}
  union {
    Callback _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallbackDefaultTypeInternal _Callback_default_instance_;
PROTOBUF_CONSTEXPR CallbackOrReference::CallbackOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CallbackOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallbackOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallbackOrReferenceDefaultTypeInternal() {}
  union {
    CallbackOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallbackOrReferenceDefaultTypeInternal _CallbackOrReference_default_instance_;
PROTOBUF_CONSTEXPR CallbacksOrReferences::CallbacksOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CallbacksOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallbacksOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallbacksOrReferencesDefaultTypeInternal() {}
  union {
    CallbacksOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallbacksOrReferencesDefaultTypeInternal _CallbacksOrReferences_default_instance_;
PROTOBUF_CONSTEXPR Components::Components(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.schemas_)*/nullptr
  , /*decltype(_impl_.responses_)*/nullptr
  , /*decltype(_impl_.parameters_)*/nullptr
  , /*decltype(_impl_.examples_)*/nullptr
  , /*decltype(_impl_.request_bodies_)*/nullptr
  , /*decltype(_impl_.headers_)*/nullptr
  , /*decltype(_impl_.security_schemes_)*/nullptr
  , /*decltype(_impl_.links_)*/nullptr
  , /*decltype(_impl_.callbacks_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ComponentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComponentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComponentsDefaultTypeInternal() {}
  union {
    Components _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComponentsDefaultTypeInternal _Components_default_instance_;
PROTOBUF_CONSTEXPR Contact::Contact(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContactDefaultTypeInternal() {}
  union {
    Contact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContactDefaultTypeInternal _Contact_default_instance_;
PROTOBUF_CONSTEXPR DefaultType::DefaultType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DefaultTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DefaultTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DefaultTypeDefaultTypeInternal() {}
  union {
    DefaultType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefaultTypeDefaultTypeInternal _DefaultType_default_instance_;
PROTOBUF_CONSTEXPR Discriminator::Discriminator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.property_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mapping_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DiscriminatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DiscriminatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DiscriminatorDefaultTypeInternal() {}
  union {
    Discriminator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DiscriminatorDefaultTypeInternal _Discriminator_default_instance_;
PROTOBUF_CONSTEXPR Document::Document(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.servers_)*/{}
  , /*decltype(_impl_.security_)*/{}
  , /*decltype(_impl_.tags_)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.openapi_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.paths_)*/nullptr
  , /*decltype(_impl_.components_)*/nullptr
  , /*decltype(_impl_.external_docs_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DocumentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocumentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocumentDefaultTypeInternal() {}
  union {
    Document _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocumentDefaultTypeInternal _Document_default_instance_;
PROTOBUF_CONSTEXPR Encoding::Encoding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.content_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.style_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.headers_)*/nullptr
  , /*decltype(_impl_.explode_)*/false
  , /*decltype(_impl_.allow_reserved_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EncodingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncodingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncodingDefaultTypeInternal() {}
  union {
    Encoding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncodingDefaultTypeInternal _Encoding_default_instance_;
PROTOBUF_CONSTEXPR Encodings::Encodings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EncodingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncodingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncodingsDefaultTypeInternal() {}
  union {
    Encodings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncodingsDefaultTypeInternal _Encodings_default_instance_;
PROTOBUF_CONSTEXPR Example::Example(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.summary_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.external_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExampleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExampleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExampleDefaultTypeInternal() {}
  union {
    Example _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExampleDefaultTypeInternal _Example_default_instance_;
PROTOBUF_CONSTEXPR ExampleOrReference::ExampleOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ExampleOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExampleOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExampleOrReferenceDefaultTypeInternal() {}
  union {
    ExampleOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExampleOrReferenceDefaultTypeInternal _ExampleOrReference_default_instance_;
PROTOBUF_CONSTEXPR ExamplesOrReferences::ExamplesOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExamplesOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExamplesOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExamplesOrReferencesDefaultTypeInternal() {}
  union {
    ExamplesOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExamplesOrReferencesDefaultTypeInternal _ExamplesOrReferences_default_instance_;
PROTOBUF_CONSTEXPR Expression::Expression(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpressionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpressionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpressionDefaultTypeInternal() {}
  union {
    Expression _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpressionDefaultTypeInternal _Expression_default_instance_;
PROTOBUF_CONSTEXPR ExternalDocs::ExternalDocs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExternalDocsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExternalDocsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExternalDocsDefaultTypeInternal() {}
  union {
    ExternalDocs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExternalDocsDefaultTypeInternal _ExternalDocs_default_instance_;
PROTOBUF_CONSTEXPR Header::Header(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.style_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.schema_)*/nullptr
  , /*decltype(_impl_.example_)*/nullptr
  , /*decltype(_impl_.examples_)*/nullptr
  , /*decltype(_impl_.content_)*/nullptr
  , /*decltype(_impl_.required_)*/false
  , /*decltype(_impl_.deprecated_)*/false
  , /*decltype(_impl_.allow_empty_value_)*/false
  , /*decltype(_impl_.explode_)*/false
  , /*decltype(_impl_.allow_reserved_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderDefaultTypeInternal() {}
  union {
    Header _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderDefaultTypeInternal _Header_default_instance_;
PROTOBUF_CONSTEXPR HeaderOrReference::HeaderOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct HeaderOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderOrReferenceDefaultTypeInternal() {}
  union {
    HeaderOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderOrReferenceDefaultTypeInternal _HeaderOrReference_default_instance_;
PROTOBUF_CONSTEXPR HeadersOrReferences::HeadersOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeadersOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeadersOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeadersOrReferencesDefaultTypeInternal() {}
  union {
    HeadersOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeadersOrReferencesDefaultTypeInternal _HeadersOrReferences_default_instance_;
PROTOBUF_CONSTEXPR Info::Info(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.terms_of_service_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.summary_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contact_)*/nullptr
  , /*decltype(_impl_.license_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoDefaultTypeInternal() {}
  union {
    Info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoDefaultTypeInternal _Info_default_instance_;
PROTOBUF_CONSTEXPR ItemsItem::ItemsItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.schema_or_reference_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ItemsItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemsItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemsItemDefaultTypeInternal() {}
  union {
    ItemsItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemsItemDefaultTypeInternal _ItemsItem_default_instance_;
PROTOBUF_CONSTEXPR License::License(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LicenseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LicenseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LicenseDefaultTypeInternal() {}
  union {
    License _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LicenseDefaultTypeInternal _License_default_instance_;
PROTOBUF_CONSTEXPR Link::Link(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.operation_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.operation_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.parameters_)*/nullptr
  , /*decltype(_impl_.request_body_)*/nullptr
  , /*decltype(_impl_.server_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LinkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinkDefaultTypeInternal() {}
  union {
    Link _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinkDefaultTypeInternal _Link_default_instance_;
PROTOBUF_CONSTEXPR LinkOrReference::LinkOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LinkOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinkOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinkOrReferenceDefaultTypeInternal() {}
  union {
    LinkOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinkOrReferenceDefaultTypeInternal _LinkOrReference_default_instance_;
PROTOBUF_CONSTEXPR LinksOrReferences::LinksOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LinksOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinksOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinksOrReferencesDefaultTypeInternal() {}
  union {
    LinksOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinksOrReferencesDefaultTypeInternal _LinksOrReferences_default_instance_;
PROTOBUF_CONSTEXPR MediaType::MediaType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.schema_)*/nullptr
  , /*decltype(_impl_.example_)*/nullptr
  , /*decltype(_impl_.examples_)*/nullptr
  , /*decltype(_impl_.encoding_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MediaTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaTypeDefaultTypeInternal() {}
  union {
    MediaType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaTypeDefaultTypeInternal _MediaType_default_instance_;
PROTOBUF_CONSTEXPR MediaTypes::MediaTypes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MediaTypesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaTypesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaTypesDefaultTypeInternal() {}
  union {
    MediaTypes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaTypesDefaultTypeInternal _MediaTypes_default_instance_;
PROTOBUF_CONSTEXPR NamedAny::NamedAny(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedAnyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedAnyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedAnyDefaultTypeInternal() {}
  union {
    NamedAny _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedAnyDefaultTypeInternal _NamedAny_default_instance_;
PROTOBUF_CONSTEXPR NamedCallbackOrReference::NamedCallbackOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedCallbackOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedCallbackOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedCallbackOrReferenceDefaultTypeInternal() {}
  union {
    NamedCallbackOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedCallbackOrReferenceDefaultTypeInternal _NamedCallbackOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedEncoding::NamedEncoding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedEncodingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedEncodingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedEncodingDefaultTypeInternal() {}
  union {
    NamedEncoding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedEncodingDefaultTypeInternal _NamedEncoding_default_instance_;
PROTOBUF_CONSTEXPR NamedExampleOrReference::NamedExampleOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedExampleOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedExampleOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedExampleOrReferenceDefaultTypeInternal() {}
  union {
    NamedExampleOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedExampleOrReferenceDefaultTypeInternal _NamedExampleOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedHeaderOrReference::NamedHeaderOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedHeaderOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedHeaderOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedHeaderOrReferenceDefaultTypeInternal() {}
  union {
    NamedHeaderOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedHeaderOrReferenceDefaultTypeInternal _NamedHeaderOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedLinkOrReference::NamedLinkOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedLinkOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedLinkOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedLinkOrReferenceDefaultTypeInternal() {}
  union {
    NamedLinkOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedLinkOrReferenceDefaultTypeInternal _NamedLinkOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedMediaType::NamedMediaType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedMediaTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedMediaTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedMediaTypeDefaultTypeInternal() {}
  union {
    NamedMediaType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedMediaTypeDefaultTypeInternal _NamedMediaType_default_instance_;
PROTOBUF_CONSTEXPR NamedParameterOrReference::NamedParameterOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedParameterOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedParameterOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedParameterOrReferenceDefaultTypeInternal() {}
  union {
    NamedParameterOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedParameterOrReferenceDefaultTypeInternal _NamedParameterOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedPathItem::NamedPathItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedPathItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedPathItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedPathItemDefaultTypeInternal() {}
  union {
    NamedPathItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedPathItemDefaultTypeInternal _NamedPathItem_default_instance_;
PROTOBUF_CONSTEXPR NamedRequestBodyOrReference::NamedRequestBodyOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedRequestBodyOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedRequestBodyOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedRequestBodyOrReferenceDefaultTypeInternal() {}
  union {
    NamedRequestBodyOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedRequestBodyOrReferenceDefaultTypeInternal _NamedRequestBodyOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedResponseOrReference::NamedResponseOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedResponseOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedResponseOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedResponseOrReferenceDefaultTypeInternal() {}
  union {
    NamedResponseOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedResponseOrReferenceDefaultTypeInternal _NamedResponseOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedSchemaOrReference::NamedSchemaOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedSchemaOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedSchemaOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedSchemaOrReferenceDefaultTypeInternal() {}
  union {
    NamedSchemaOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedSchemaOrReferenceDefaultTypeInternal _NamedSchemaOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedSecuritySchemeOrReference::NamedSecuritySchemeOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedSecuritySchemeOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedSecuritySchemeOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedSecuritySchemeOrReferenceDefaultTypeInternal() {}
  union {
    NamedSecuritySchemeOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedSecuritySchemeOrReferenceDefaultTypeInternal _NamedSecuritySchemeOrReference_default_instance_;
PROTOBUF_CONSTEXPR NamedServerVariable::NamedServerVariable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedServerVariableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedServerVariableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedServerVariableDefaultTypeInternal() {}
  union {
    NamedServerVariable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedServerVariableDefaultTypeInternal _NamedServerVariable_default_instance_;
PROTOBUF_CONSTEXPR NamedString::NamedString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedStringDefaultTypeInternal() {}
  union {
    NamedString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedStringDefaultTypeInternal _NamedString_default_instance_;
PROTOBUF_CONSTEXPR NamedStringArray::NamedStringArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedStringArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedStringArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedStringArrayDefaultTypeInternal() {}
  union {
    NamedStringArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedStringArrayDefaultTypeInternal _NamedStringArray_default_instance_;
PROTOBUF_CONSTEXPR OauthFlow::OauthFlow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.authorization_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.token_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.refresh_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scopes_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OauthFlowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OauthFlowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OauthFlowDefaultTypeInternal() {}
  union {
    OauthFlow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OauthFlowDefaultTypeInternal _OauthFlow_default_instance_;
PROTOBUF_CONSTEXPR OauthFlows::OauthFlows(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.implicit_)*/nullptr
  , /*decltype(_impl_.password_)*/nullptr
  , /*decltype(_impl_.client_credentials_)*/nullptr
  , /*decltype(_impl_.authorization_code_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OauthFlowsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OauthFlowsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OauthFlowsDefaultTypeInternal() {}
  union {
    OauthFlows _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OauthFlowsDefaultTypeInternal _OauthFlows_default_instance_;
PROTOBUF_CONSTEXPR Object::Object(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectDefaultTypeInternal() {}
  union {
    Object _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectDefaultTypeInternal _Object_default_instance_;
PROTOBUF_CONSTEXPR Operation::Operation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tags_)*/{}
  , /*decltype(_impl_.parameters_)*/{}
  , /*decltype(_impl_.security_)*/{}
  , /*decltype(_impl_.servers_)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.summary_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.operation_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.external_docs_)*/nullptr
  , /*decltype(_impl_.request_body_)*/nullptr
  , /*decltype(_impl_.responses_)*/nullptr
  , /*decltype(_impl_.callbacks_)*/nullptr
  , /*decltype(_impl_.deprecated_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDefaultTypeInternal() {}
  union {
    Operation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDefaultTypeInternal _Operation_default_instance_;
PROTOBUF_CONSTEXPR Parameter::Parameter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.in_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.style_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.schema_)*/nullptr
  , /*decltype(_impl_.example_)*/nullptr
  , /*decltype(_impl_.examples_)*/nullptr
  , /*decltype(_impl_.content_)*/nullptr
  , /*decltype(_impl_.required_)*/false
  , /*decltype(_impl_.deprecated_)*/false
  , /*decltype(_impl_.allow_empty_value_)*/false
  , /*decltype(_impl_.explode_)*/false
  , /*decltype(_impl_.allow_reserved_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ParameterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParameterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParameterDefaultTypeInternal() {}
  union {
    Parameter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParameterDefaultTypeInternal _Parameter_default_instance_;
PROTOBUF_CONSTEXPR ParameterOrReference::ParameterOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ParameterOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParameterOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParameterOrReferenceDefaultTypeInternal() {}
  union {
    ParameterOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParameterOrReferenceDefaultTypeInternal _ParameterOrReference_default_instance_;
PROTOBUF_CONSTEXPR ParametersOrReferences::ParametersOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ParametersOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParametersOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParametersOrReferencesDefaultTypeInternal() {}
  union {
    ParametersOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParametersOrReferencesDefaultTypeInternal _ParametersOrReferences_default_instance_;
PROTOBUF_CONSTEXPR PathItem::PathItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.servers_)*/{}
  , /*decltype(_impl_.parameters_)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_._ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.summary_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.get_)*/nullptr
  , /*decltype(_impl_.put_)*/nullptr
  , /*decltype(_impl_.post_)*/nullptr
  , /*decltype(_impl_.delete__)*/nullptr
  , /*decltype(_impl_.options_)*/nullptr
  , /*decltype(_impl_.head_)*/nullptr
  , /*decltype(_impl_.patch_)*/nullptr
  , /*decltype(_impl_.trace_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PathItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathItemDefaultTypeInternal() {}
  union {
    PathItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathItemDefaultTypeInternal _PathItem_default_instance_;
PROTOBUF_CONSTEXPR Paths::Paths(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PathsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathsDefaultTypeInternal() {}
  union {
    Paths _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathsDefaultTypeInternal _Paths_default_instance_;
PROTOBUF_CONSTEXPR Properties::Properties(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PropertiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PropertiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PropertiesDefaultTypeInternal() {}
  union {
    Properties _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PropertiesDefaultTypeInternal _Properties_default_instance_;
PROTOBUF_CONSTEXPR Reference::Reference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.summary_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferenceDefaultTypeInternal() {}
  union {
    Reference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferenceDefaultTypeInternal _Reference_default_instance_;
PROTOBUF_CONSTEXPR RequestBodiesOrReferences::RequestBodiesOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestBodiesOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestBodiesOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestBodiesOrReferencesDefaultTypeInternal() {}
  union {
    RequestBodiesOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestBodiesOrReferencesDefaultTypeInternal _RequestBodiesOrReferences_default_instance_;
PROTOBUF_CONSTEXPR RequestBody::RequestBody(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.content_)*/nullptr
  , /*decltype(_impl_.required_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestBodyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestBodyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestBodyDefaultTypeInternal() {}
  union {
    RequestBody _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestBodyDefaultTypeInternal _RequestBody_default_instance_;
PROTOBUF_CONSTEXPR RequestBodyOrReference::RequestBodyOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestBodyOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestBodyOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestBodyOrReferenceDefaultTypeInternal() {}
  union {
    RequestBodyOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestBodyOrReferenceDefaultTypeInternal _RequestBodyOrReference_default_instance_;
PROTOBUF_CONSTEXPR Response::Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.headers_)*/nullptr
  , /*decltype(_impl_.content_)*/nullptr
  , /*decltype(_impl_.links_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDefaultTypeInternal() {}
  union {
    Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDefaultTypeInternal _Response_default_instance_;
PROTOBUF_CONSTEXPR ResponseOrReference::ResponseOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ResponseOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseOrReferenceDefaultTypeInternal() {}
  union {
    ResponseOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseOrReferenceDefaultTypeInternal _ResponseOrReference_default_instance_;
PROTOBUF_CONSTEXPR Responses::Responses(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_or_reference_)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.default__)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponsesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponsesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponsesDefaultTypeInternal() {}
  union {
    Responses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponsesDefaultTypeInternal _Responses_default_instance_;
PROTOBUF_CONSTEXPR ResponsesOrReferences::ResponsesOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponsesOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponsesOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponsesOrReferencesDefaultTypeInternal() {}
  union {
    ResponsesOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponsesOrReferencesDefaultTypeInternal _ResponsesOrReferences_default_instance_;
PROTOBUF_CONSTEXPR Schema::Schema(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.required_)*/{}
  , /*decltype(_impl_.enum__)*/{}
  , /*decltype(_impl_.all_of_)*/{}
  , /*decltype(_impl_.one_of_)*/{}
  , /*decltype(_impl_.any_of_)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pattern_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.format_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.discriminator_)*/nullptr
  , /*decltype(_impl_.xml_)*/nullptr
  , /*decltype(_impl_.external_docs_)*/nullptr
  , /*decltype(_impl_.example_)*/nullptr
  , /*decltype(_impl_.not__)*/nullptr
  , /*decltype(_impl_.items_)*/nullptr
  , /*decltype(_impl_.properties_)*/nullptr
  , /*decltype(_impl_.additional_properties_)*/nullptr
  , /*decltype(_impl_.default__)*/nullptr
  , /*decltype(_impl_.nullable_)*/false
  , /*decltype(_impl_.read_only_)*/false
  , /*decltype(_impl_.write_only_)*/false
  , /*decltype(_impl_.deprecated_)*/false
  , /*decltype(_impl_.exclusive_maximum_)*/false
  , /*decltype(_impl_.exclusive_minimum_)*/false
  , /*decltype(_impl_.unique_items_)*/false
  , /*decltype(_impl_.multiple_of_)*/0
  , /*decltype(_impl_.maximum_)*/0
  , /*decltype(_impl_.minimum_)*/0
  , /*decltype(_impl_.max_length_)*/int64_t{0}
  , /*decltype(_impl_.min_length_)*/int64_t{0}
  , /*decltype(_impl_.max_items_)*/int64_t{0}
  , /*decltype(_impl_.min_items_)*/int64_t{0}
  , /*decltype(_impl_.max_properties_)*/int64_t{0}
  , /*decltype(_impl_.min_properties_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SchemaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchemaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchemaDefaultTypeInternal() {}
  union {
    Schema _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchemaDefaultTypeInternal _Schema_default_instance_;
PROTOBUF_CONSTEXPR SchemaOrReference::SchemaOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SchemaOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchemaOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchemaOrReferenceDefaultTypeInternal() {}
  union {
    SchemaOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchemaOrReferenceDefaultTypeInternal _SchemaOrReference_default_instance_;
PROTOBUF_CONSTEXPR SchemasOrReferences::SchemasOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SchemasOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchemasOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchemasOrReferencesDefaultTypeInternal() {}
  union {
    SchemasOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchemasOrReferencesDefaultTypeInternal _SchemasOrReferences_default_instance_;
PROTOBUF_CONSTEXPR SecurityRequirement::SecurityRequirement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SecurityRequirementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecurityRequirementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecurityRequirementDefaultTypeInternal() {}
  union {
    SecurityRequirement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityRequirementDefaultTypeInternal _SecurityRequirement_default_instance_;
PROTOBUF_CONSTEXPR SecurityScheme::SecurityScheme(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.in_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scheme_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bearer_format_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.open_id_connect_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flows_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SecuritySchemeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecuritySchemeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecuritySchemeDefaultTypeInternal() {}
  union {
    SecurityScheme _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecuritySchemeDefaultTypeInternal _SecurityScheme_default_instance_;
PROTOBUF_CONSTEXPR SecuritySchemeOrReference::SecuritySchemeOrReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SecuritySchemeOrReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecuritySchemeOrReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecuritySchemeOrReferenceDefaultTypeInternal() {}
  union {
    SecuritySchemeOrReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecuritySchemeOrReferenceDefaultTypeInternal _SecuritySchemeOrReference_default_instance_;
PROTOBUF_CONSTEXPR SecuritySchemesOrReferences::SecuritySchemesOrReferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SecuritySchemesOrReferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecuritySchemesOrReferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecuritySchemesOrReferencesDefaultTypeInternal() {}
  union {
    SecuritySchemesOrReferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecuritySchemesOrReferencesDefaultTypeInternal _SecuritySchemesOrReferences_default_instance_;
PROTOBUF_CONSTEXPR Server::Server(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.variables_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerDefaultTypeInternal() {}
  union {
    Server _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerDefaultTypeInternal _Server_default_instance_;
PROTOBUF_CONSTEXPR ServerVariable::ServerVariable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.enum__)*/{}
  , /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.default__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServerVariableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerVariableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerVariableDefaultTypeInternal() {}
  union {
    ServerVariable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerVariableDefaultTypeInternal _ServerVariable_default_instance_;
PROTOBUF_CONSTEXPR ServerVariables::ServerVariables(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServerVariablesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerVariablesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerVariablesDefaultTypeInternal() {}
  union {
    ServerVariables _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerVariablesDefaultTypeInternal _ServerVariables_default_instance_;
PROTOBUF_CONSTEXPR SpecificationExtension::SpecificationExtension(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SpecificationExtensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecificationExtensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecificationExtensionDefaultTypeInternal() {}
  union {
    SpecificationExtension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecificationExtensionDefaultTypeInternal _SpecificationExtension_default_instance_;
PROTOBUF_CONSTEXPR StringArray::StringArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StringArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringArrayDefaultTypeInternal() {}
  union {
    StringArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringArrayDefaultTypeInternal _StringArray_default_instance_;
PROTOBUF_CONSTEXPR Strings::Strings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_properties_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StringsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringsDefaultTypeInternal() {}
  union {
    Strings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringsDefaultTypeInternal _Strings_default_instance_;
PROTOBUF_CONSTEXPR Tag::Tag(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.external_docs_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TagDefaultTypeInternal() {}
  union {
    Tag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TagDefaultTypeInternal _Tag_default_instance_;
PROTOBUF_CONSTEXPR Xml::Xml(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.specification_extension_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.namespace__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attribute_)*/false
  , /*decltype(_impl_.wrapped_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct XmlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XmlDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~XmlDefaultTypeInternal() {}
  union {
    Xml _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XmlDefaultTypeInternal _Xml_default_instance_;
}  // namespace v3
}  // namespace openapi
}  // namespace gnostic
static ::_pb::Metadata file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[78];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto = nullptr;

const uint32_t TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::AdditionalPropertiesItem, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::AdditionalPropertiesItem, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::AdditionalPropertiesItem, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Any, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Any, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Any, _impl_.yaml_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::AnyOrExpression, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::AnyOrExpression, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::AnyOrExpression, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Callback, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Callback, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Callback, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::CallbackOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::CallbackOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::CallbackOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::CallbacksOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::CallbacksOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.schemas_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.responses_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.examples_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.request_bodies_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.headers_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.security_schemes_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.links_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.callbacks_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Components, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Contact, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Contact, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Contact, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Contact, _impl_.email_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Contact, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::DefaultType, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::DefaultType, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::DefaultType, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Discriminator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Discriminator, _impl_.property_name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Discriminator, _impl_.mapping_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Discriminator, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.openapi_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.servers_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.paths_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.components_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.security_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.tags_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.external_docs_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Document, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encoding, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encoding, _impl_.content_type_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encoding, _impl_.headers_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encoding, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encoding, _impl_.explode_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encoding, _impl_.allow_reserved_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encoding, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encodings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Encodings, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Example, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Example, _impl_.summary_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Example, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Example, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Example, _impl_.external_value_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Example, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExampleOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExampleOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExampleOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExamplesOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExamplesOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Expression, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Expression, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExternalDocs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExternalDocs, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExternalDocs, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ExternalDocs, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.deprecated_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.allow_empty_value_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.explode_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.allow_reserved_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.schema_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.example_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.examples_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.content_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Header, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::HeaderOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::HeaderOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::HeaderOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::HeadersOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::HeadersOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.terms_of_service_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.contact_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.license_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.specification_extension_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Info, _impl_.summary_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ItemsItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ItemsItem, _impl_.schema_or_reference_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::License, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::License, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::License, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::License, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _impl_.operation_ref_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _impl_.operation_id_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _impl_.request_body_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _impl_.server_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Link, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::LinkOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::LinkOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::LinkOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::LinksOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::LinksOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaType, _impl_.schema_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaType, _impl_.example_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaType, _impl_.examples_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaType, _impl_.encoding_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaType, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaTypes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::MediaTypes, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedAny, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedAny, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedAny, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedCallbackOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedCallbackOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedCallbackOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedEncoding, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedEncoding, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedEncoding, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedExampleOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedExampleOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedExampleOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedHeaderOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedHeaderOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedHeaderOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedLinkOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedLinkOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedLinkOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedMediaType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedMediaType, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedMediaType, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedParameterOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedParameterOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedParameterOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedPathItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedPathItem, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedPathItem, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedRequestBodyOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedRequestBodyOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedRequestBodyOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedResponseOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedResponseOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedResponseOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedSchemaOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedSchemaOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedSchemaOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedSecuritySchemeOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedSecuritySchemeOrReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedSecuritySchemeOrReference, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedServerVariable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedServerVariable, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedServerVariable, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedString, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedString, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedString, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedStringArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedStringArray, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::NamedStringArray, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlow, _impl_.authorization_url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlow, _impl_.token_url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlow, _impl_.refresh_url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlow, _impl_.scopes_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlow, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlows, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlows, _impl_.implicit_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlows, _impl_.password_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlows, _impl_.client_credentials_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlows, _impl_.authorization_code_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::OauthFlows, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Object, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Object, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.tags_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.summary_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.external_docs_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.operation_id_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.request_body_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.responses_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.callbacks_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.deprecated_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.security_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.servers_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Operation, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.deprecated_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.allow_empty_value_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.explode_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.allow_reserved_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.schema_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.example_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.examples_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.content_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Parameter, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ParameterOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ParameterOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ParameterOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ParametersOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ParametersOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_._ref_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.summary_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.get_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.put_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.post_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.delete__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.options_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.head_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.patch_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.trace_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.servers_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::PathItem, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Paths, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Paths, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Paths, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Properties, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Properties, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Reference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Reference, _impl_._ref_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Reference, _impl_.summary_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Reference, _impl_.description_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBodiesOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBodiesOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBody, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBody, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBody, _impl_.content_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBody, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBody, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBodyOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBodyOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::RequestBodyOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Response, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Response, _impl_.headers_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Response, _impl_.content_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Response, _impl_.links_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Response, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ResponseOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ResponseOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ResponseOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Responses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Responses, _impl_.default__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Responses, _impl_.response_or_reference_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Responses, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ResponsesOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ResponsesOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.nullable_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.discriminator_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.read_only_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.write_only_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.xml_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.external_docs_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.example_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.deprecated_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.multiple_of_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.maximum_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.exclusive_maximum_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.exclusive_minimum_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.max_length_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.min_length_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.pattern_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.max_items_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.min_items_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.unique_items_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.max_properties_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.min_properties_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.required_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.enum__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.all_of_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.one_of_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.any_of_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.not__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.properties_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.additional_properties_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.default__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Schema, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SchemaOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SchemaOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SchemaOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SchemasOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SchemasOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityRequirement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityRequirement, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.in_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.scheme_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.bearer_format_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.flows_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.open_id_connect_url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecurityScheme, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecuritySchemeOrReference, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecuritySchemeOrReference, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecuritySchemeOrReference, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecuritySchemesOrReferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SecuritySchemesOrReferences, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Server, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Server, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Server, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Server, _impl_.variables_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Server, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ServerVariable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ServerVariable, _impl_.enum__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ServerVariable, _impl_.default__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ServerVariable, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ServerVariable, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ServerVariables, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::ServerVariables, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SpecificationExtension, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SpecificationExtension, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::SpecificationExtension, _impl_.oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::StringArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::StringArray, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Strings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Strings, _impl_.additional_properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Tag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Tag, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Tag, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Tag, _impl_.external_docs_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Tag, _impl_.specification_extension_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Xml, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Xml, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Xml, _impl_.namespace__),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Xml, _impl_.prefix_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Xml, _impl_.attribute_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Xml, _impl_.wrapped_),
  PROTOBUF_FIELD_OFFSET(::gnostic::openapi::v3::Xml, _impl_.specification_extension_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::gnostic::openapi::v3::AdditionalPropertiesItem)},
  { 9, -1, -1, sizeof(::gnostic::openapi::v3::Any)},
  { 17, -1, -1, sizeof(::gnostic::openapi::v3::AnyOrExpression)},
  { 26, -1, -1, sizeof(::gnostic::openapi::v3::Callback)},
  { 34, -1, -1, sizeof(::gnostic::openapi::v3::CallbackOrReference)},
  { 43, -1, -1, sizeof(::gnostic::openapi::v3::CallbacksOrReferences)},
  { 50, -1, -1, sizeof(::gnostic::openapi::v3::Components)},
  { 66, -1, -1, sizeof(::gnostic::openapi::v3::Contact)},
  { 76, -1, -1, sizeof(::gnostic::openapi::v3::DefaultType)},
  { 86, -1, -1, sizeof(::gnostic::openapi::v3::Discriminator)},
  { 95, -1, -1, sizeof(::gnostic::openapi::v3::Document)},
  { 110, -1, -1, sizeof(::gnostic::openapi::v3::Encoding)},
  { 122, -1, -1, sizeof(::gnostic::openapi::v3::Encodings)},
  { 129, -1, -1, sizeof(::gnostic::openapi::v3::Example)},
  { 140, -1, -1, sizeof(::gnostic::openapi::v3::ExampleOrReference)},
  { 149, -1, -1, sizeof(::gnostic::openapi::v3::ExamplesOrReferences)},
  { 156, -1, -1, sizeof(::gnostic::openapi::v3::Expression)},
  { 163, -1, -1, sizeof(::gnostic::openapi::v3::ExternalDocs)},
  { 172, -1, -1, sizeof(::gnostic::openapi::v3::Header)},
  { 190, -1, -1, sizeof(::gnostic::openapi::v3::HeaderOrReference)},
  { 199, -1, -1, sizeof(::gnostic::openapi::v3::HeadersOrReferences)},
  { 206, -1, -1, sizeof(::gnostic::openapi::v3::Info)},
  { 220, -1, -1, sizeof(::gnostic::openapi::v3::ItemsItem)},
  { 227, -1, -1, sizeof(::gnostic::openapi::v3::License)},
  { 236, -1, -1, sizeof(::gnostic::openapi::v3::Link)},
  { 249, -1, -1, sizeof(::gnostic::openapi::v3::LinkOrReference)},
  { 258, -1, -1, sizeof(::gnostic::openapi::v3::LinksOrReferences)},
  { 265, -1, -1, sizeof(::gnostic::openapi::v3::MediaType)},
  { 276, -1, -1, sizeof(::gnostic::openapi::v3::MediaTypes)},
  { 283, -1, -1, sizeof(::gnostic::openapi::v3::NamedAny)},
  { 291, -1, -1, sizeof(::gnostic::openapi::v3::NamedCallbackOrReference)},
  { 299, -1, -1, sizeof(::gnostic::openapi::v3::NamedEncoding)},
  { 307, -1, -1, sizeof(::gnostic::openapi::v3::NamedExampleOrReference)},
  { 315, -1, -1, sizeof(::gnostic::openapi::v3::NamedHeaderOrReference)},
  { 323, -1, -1, sizeof(::gnostic::openapi::v3::NamedLinkOrReference)},
  { 331, -1, -1, sizeof(::gnostic::openapi::v3::NamedMediaType)},
  { 339, -1, -1, sizeof(::gnostic::openapi::v3::NamedParameterOrReference)},
  { 347, -1, -1, sizeof(::gnostic::openapi::v3::NamedPathItem)},
  { 355, -1, -1, sizeof(::gnostic::openapi::v3::NamedRequestBodyOrReference)},
  { 363, -1, -1, sizeof(::gnostic::openapi::v3::NamedResponseOrReference)},
  { 371, -1, -1, sizeof(::gnostic::openapi::v3::NamedSchemaOrReference)},
  { 379, -1, -1, sizeof(::gnostic::openapi::v3::NamedSecuritySchemeOrReference)},
  { 387, -1, -1, sizeof(::gnostic::openapi::v3::NamedServerVariable)},
  { 395, -1, -1, sizeof(::gnostic::openapi::v3::NamedString)},
  { 403, -1, -1, sizeof(::gnostic::openapi::v3::NamedStringArray)},
  { 411, -1, -1, sizeof(::gnostic::openapi::v3::OauthFlow)},
  { 422, -1, -1, sizeof(::gnostic::openapi::v3::OauthFlows)},
  { 433, -1, -1, sizeof(::gnostic::openapi::v3::Object)},
  { 440, -1, -1, sizeof(::gnostic::openapi::v3::Operation)},
  { 459, -1, -1, sizeof(::gnostic::openapi::v3::Parameter)},
  { 479, -1, -1, sizeof(::gnostic::openapi::v3::ParameterOrReference)},
  { 488, -1, -1, sizeof(::gnostic::openapi::v3::ParametersOrReferences)},
  { 495, -1, -1, sizeof(::gnostic::openapi::v3::PathItem)},
  { 515, -1, -1, sizeof(::gnostic::openapi::v3::Paths)},
  { 523, -1, -1, sizeof(::gnostic::openapi::v3::Properties)},
  { 530, -1, -1, sizeof(::gnostic::openapi::v3::Reference)},
  { 539, -1, -1, sizeof(::gnostic::openapi::v3::RequestBodiesOrReferences)},
  { 546, -1, -1, sizeof(::gnostic::openapi::v3::RequestBody)},
  { 556, -1, -1, sizeof(::gnostic::openapi::v3::RequestBodyOrReference)},
  { 565, -1, -1, sizeof(::gnostic::openapi::v3::Response)},
  { 576, -1, -1, sizeof(::gnostic::openapi::v3::ResponseOrReference)},
  { 585, -1, -1, sizeof(::gnostic::openapi::v3::Responses)},
  { 594, -1, -1, sizeof(::gnostic::openapi::v3::ResponsesOrReferences)},
  { 601, -1, -1, sizeof(::gnostic::openapi::v3::Schema)},
  { 643, -1, -1, sizeof(::gnostic::openapi::v3::SchemaOrReference)},
  { 652, -1, -1, sizeof(::gnostic::openapi::v3::SchemasOrReferences)},
  { 659, -1, -1, sizeof(::gnostic::openapi::v3::SecurityRequirement)},
  { 666, -1, -1, sizeof(::gnostic::openapi::v3::SecurityScheme)},
  { 681, -1, -1, sizeof(::gnostic::openapi::v3::SecuritySchemeOrReference)},
  { 690, -1, -1, sizeof(::gnostic::openapi::v3::SecuritySchemesOrReferences)},
  { 697, -1, -1, sizeof(::gnostic::openapi::v3::Server)},
  { 707, -1, -1, sizeof(::gnostic::openapi::v3::ServerVariable)},
  { 717, -1, -1, sizeof(::gnostic::openapi::v3::ServerVariables)},
  { 724, -1, -1, sizeof(::gnostic::openapi::v3::SpecificationExtension)},
  { 734, -1, -1, sizeof(::gnostic::openapi::v3::StringArray)},
  { 741, -1, -1, sizeof(::gnostic::openapi::v3::Strings)},
  { 748, -1, -1, sizeof(::gnostic::openapi::v3::Tag)},
  { 758, -1, -1, sizeof(::gnostic::openapi::v3::Xml)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::gnostic::openapi::v3::_AdditionalPropertiesItem_default_instance_._instance,
  &::gnostic::openapi::v3::_Any_default_instance_._instance,
  &::gnostic::openapi::v3::_AnyOrExpression_default_instance_._instance,
  &::gnostic::openapi::v3::_Callback_default_instance_._instance,
  &::gnostic::openapi::v3::_CallbackOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_CallbacksOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_Components_default_instance_._instance,
  &::gnostic::openapi::v3::_Contact_default_instance_._instance,
  &::gnostic::openapi::v3::_DefaultType_default_instance_._instance,
  &::gnostic::openapi::v3::_Discriminator_default_instance_._instance,
  &::gnostic::openapi::v3::_Document_default_instance_._instance,
  &::gnostic::openapi::v3::_Encoding_default_instance_._instance,
  &::gnostic::openapi::v3::_Encodings_default_instance_._instance,
  &::gnostic::openapi::v3::_Example_default_instance_._instance,
  &::gnostic::openapi::v3::_ExampleOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_ExamplesOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_Expression_default_instance_._instance,
  &::gnostic::openapi::v3::_ExternalDocs_default_instance_._instance,
  &::gnostic::openapi::v3::_Header_default_instance_._instance,
  &::gnostic::openapi::v3::_HeaderOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_HeadersOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_Info_default_instance_._instance,
  &::gnostic::openapi::v3::_ItemsItem_default_instance_._instance,
  &::gnostic::openapi::v3::_License_default_instance_._instance,
  &::gnostic::openapi::v3::_Link_default_instance_._instance,
  &::gnostic::openapi::v3::_LinkOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_LinksOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_MediaType_default_instance_._instance,
  &::gnostic::openapi::v3::_MediaTypes_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedAny_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedCallbackOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedEncoding_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedExampleOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedHeaderOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedLinkOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedMediaType_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedParameterOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedPathItem_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedRequestBodyOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedResponseOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedSchemaOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedSecuritySchemeOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedServerVariable_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedString_default_instance_._instance,
  &::gnostic::openapi::v3::_NamedStringArray_default_instance_._instance,
  &::gnostic::openapi::v3::_OauthFlow_default_instance_._instance,
  &::gnostic::openapi::v3::_OauthFlows_default_instance_._instance,
  &::gnostic::openapi::v3::_Object_default_instance_._instance,
  &::gnostic::openapi::v3::_Operation_default_instance_._instance,
  &::gnostic::openapi::v3::_Parameter_default_instance_._instance,
  &::gnostic::openapi::v3::_ParameterOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_ParametersOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_PathItem_default_instance_._instance,
  &::gnostic::openapi::v3::_Paths_default_instance_._instance,
  &::gnostic::openapi::v3::_Properties_default_instance_._instance,
  &::gnostic::openapi::v3::_Reference_default_instance_._instance,
  &::gnostic::openapi::v3::_RequestBodiesOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_RequestBody_default_instance_._instance,
  &::gnostic::openapi::v3::_RequestBodyOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_Response_default_instance_._instance,
  &::gnostic::openapi::v3::_ResponseOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_Responses_default_instance_._instance,
  &::gnostic::openapi::v3::_ResponsesOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_Schema_default_instance_._instance,
  &::gnostic::openapi::v3::_SchemaOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_SchemasOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_SecurityRequirement_default_instance_._instance,
  &::gnostic::openapi::v3::_SecurityScheme_default_instance_._instance,
  &::gnostic::openapi::v3::_SecuritySchemeOrReference_default_instance_._instance,
  &::gnostic::openapi::v3::_SecuritySchemesOrReferences_default_instance_._instance,
  &::gnostic::openapi::v3::_Server_default_instance_._instance,
  &::gnostic::openapi::v3::_ServerVariable_default_instance_._instance,
  &::gnostic::openapi::v3::_ServerVariables_default_instance_._instance,
  &::gnostic::openapi::v3::_SpecificationExtension_default_instance_._instance,
  &::gnostic::openapi::v3::_StringArray_default_instance_._instance,
  &::gnostic::openapi::v3::_Strings_default_instance_._instance,
  &::gnostic::openapi::v3::_Tag_default_instance_._instance,
  &::gnostic::openapi::v3::_Xml_default_instance_._instance,
};

const char descriptor_table_protodef_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\"gnostic/openapi/v3/openapiv3.proto\022\022gn"
  "ostic.openapi.v3\032\031google/protobuf/any.pr"
  "oto\"|\n\030AdditionalPropertiesItem\022D\n\023schem"
  "a_or_reference\030\001 \001(\0132%.gnostic.openapi.v"
  "3.SchemaOrReferenceH\000\022\021\n\007boolean\030\002 \001(\010H\000"
  "B\007\n\005oneof\"8\n\003Any\022#\n\005value\030\001 \001(\0132\024.google"
  ".protobuf.Any\022\014\n\004yaml\030\002 \001(\t\"x\n\017AnyOrExpr"
  "ession\022&\n\003any\030\001 \001(\0132\027.gnostic.openapi.v3"
  ".AnyH\000\0224\n\nexpression\030\002 \001(\0132\036.gnostic.ope"
  "napi.v3.ExpressionH\000B\007\n\005oneof\"z\n\010Callbac"
  "k\022/\n\004path\030\001 \003(\0132!.gnostic.openapi.v3.Nam"
  "edPathItem\022=\n\027specification_extension\030\002 "
  "\003(\0132\034.gnostic.openapi.v3.NamedAny\"\204\001\n\023Ca"
  "llbackOrReference\0220\n\010callback\030\001 \001(\0132\034.gn"
  "ostic.openapi.v3.CallbackH\000\0222\n\treference"
  "\030\002 \001(\0132\035.gnostic.openapi.v3.ReferenceH\000B"
  "\007\n\005oneof\"d\n\025CallbacksOrReferences\022K\n\025add"
  "itional_properties\030\001 \003(\0132,.gnostic.opena"
  "pi.v3.NamedCallbackOrReference\"\377\004\n\nCompo"
  "nents\0228\n\007schemas\030\001 \001(\0132\'.gnostic.openapi"
  ".v3.SchemasOrReferences\022<\n\tresponses\030\002 \001"
  "(\0132).gnostic.openapi.v3.ResponsesOrRefer"
  "ences\022>\n\nparameters\030\003 \001(\0132*.gnostic.open"
  "api.v3.ParametersOrReferences\022:\n\010example"
  "s\030\004 \001(\0132(.gnostic.openapi.v3.ExamplesOrR"
  "eferences\022E\n\016request_bodies\030\005 \001(\0132-.gnos"
  "tic.openapi.v3.RequestBodiesOrReferences"
  "\0228\n\007headers\030\006 \001(\0132\'.gnostic.openapi.v3.H"
  "eadersOrReferences\022I\n\020security_schemes\030\007"
  " \001(\0132/.gnostic.openapi.v3.SecurityScheme"
  "sOrReferences\0224\n\005links\030\010 \001(\0132%.gnostic.o"
  "penapi.v3.LinksOrReferences\022<\n\tcallbacks"
  "\030\t \001(\0132).gnostic.openapi.v3.CallbacksOrR"
  "eferences\022=\n\027specification_extension\030\n \003"
  "(\0132\034.gnostic.openapi.v3.NamedAny\"r\n\007Cont"
  "act\022\014\n\004name\030\001 \001(\t\022\013\n\003url\030\002 \001(\t\022\r\n\005email\030"
  "\003 \001(\t\022=\n\027specification_extension\030\004 \003(\0132\034"
  ".gnostic.openapi.v3.NamedAny\"M\n\013DefaultT"
  "ype\022\020\n\006number\030\001 \001(\001H\000\022\021\n\007boolean\030\002 \001(\010H\000"
  "\022\020\n\006string\030\003 \001(\tH\000B\007\n\005oneof\"\223\001\n\rDiscrimi"
  "nator\022\025\n\rproperty_name\030\001 \001(\t\022,\n\007mapping\030"
  "\002 \001(\0132\033.gnostic.openapi.v3.Strings\022=\n\027sp"
  "ecification_extension\030\003 \003(\0132\034.gnostic.op"
  "enapi.v3.NamedAny\"\250\003\n\010Document\022\017\n\007openap"
  "i\030\001 \001(\t\022&\n\004info\030\002 \001(\0132\030.gnostic.openapi."
  "v3.Info\022+\n\007servers\030\003 \003(\0132\032.gnostic.opena"
  "pi.v3.Server\022(\n\005paths\030\004 \001(\0132\031.gnostic.op"
  "enapi.v3.Paths\0222\n\ncomponents\030\005 \001(\0132\036.gno"
  "stic.openapi.v3.Components\0229\n\010security\030\006"
  " \003(\0132\'.gnostic.openapi.v3.SecurityRequir"
  "ement\022%\n\004tags\030\007 \003(\0132\027.gnostic.openapi.v3"
  ".Tag\0227\n\rexternal_docs\030\010 \001(\0132 .gnostic.op"
  "enapi.v3.ExternalDocs\022=\n\027specification_e"
  "xtension\030\t \003(\0132\034.gnostic.openapi.v3.Name"
  "dAny\"\321\001\n\010Encoding\022\024\n\014content_type\030\001 \001(\t\022"
  "8\n\007headers\030\002 \001(\0132\'.gnostic.openapi.v3.He"
  "adersOrReferences\022\r\n\005style\030\003 \001(\t\022\017\n\007expl"
  "ode\030\004 \001(\010\022\026\n\016allow_reserved\030\005 \001(\010\022=\n\027spe"
  "cification_extension\030\006 \003(\0132\034.gnostic.ope"
  "napi.v3.NamedAny\"M\n\tEncodings\022@\n\025additio"
  "nal_properties\030\001 \003(\0132!.gnostic.openapi.v"
  "3.NamedEncoding\"\256\001\n\007Example\022\017\n\007summary\030\001"
  " \001(\t\022\023\n\013description\030\002 \001(\t\022&\n\005value\030\003 \001(\013"
  "2\027.gnostic.openapi.v3.Any\022\026\n\016external_va"
  "lue\030\004 \001(\t\022=\n\027specification_extension\030\005 \003"
  "(\0132\034.gnostic.openapi.v3.NamedAny\"\201\001\n\022Exa"
  "mpleOrReference\022.\n\007example\030\001 \001(\0132\033.gnost"
  "ic.openapi.v3.ExampleH\000\0222\n\treference\030\002 \001"
  "(\0132\035.gnostic.openapi.v3.ReferenceH\000B\007\n\005o"
  "neof\"b\n\024ExamplesOrReferences\022J\n\025addition"
  "al_properties\030\001 \003(\0132+.gnostic.openapi.v3"
  ".NamedExampleOrReference\"I\n\nExpression\022;"
  "\n\025additional_properties\030\001 \003(\0132\034.gnostic."
  "openapi.v3.NamedAny\"o\n\014ExternalDocs\022\023\n\013d"
  "escription\030\001 \001(\t\022\013\n\003url\030\002 \001(\t\022=\n\027specifi"
  "cation_extension\030\003 \003(\0132\034.gnostic.openapi"
  ".v3.NamedAny\"\243\003\n\006Header\022\023\n\013description\030\001"
  " \001(\t\022\020\n\010required\030\002 \001(\010\022\022\n\ndeprecated\030\003 \001"
  "(\010\022\031\n\021allow_empty_value\030\004 \001(\010\022\r\n\005style\030\005"
  " \001(\t\022\017\n\007explode\030\006 \001(\010\022\026\n\016allow_reserved\030"
  "\007 \001(\010\0225\n\006schema\030\010 \001(\0132%.gnostic.openapi."
  "v3.SchemaOrReference\022(\n\007example\030\t \001(\0132\027."
  "gnostic.openapi.v3.Any\022:\n\010examples\030\n \001(\013"
  "2(.gnostic.openapi.v3.ExamplesOrReferenc"
  "es\022/\n\007content\030\013 \001(\0132\036.gnostic.openapi.v3"
  ".MediaTypes\022=\n\027specification_extension\030\014"
  " \003(\0132\034.gnostic.openapi.v3.NamedAny\"~\n\021He"
  "aderOrReference\022,\n\006header\030\001 \001(\0132\032.gnosti"
  "c.openapi.v3.HeaderH\000\0222\n\treference\030\002 \001(\013"
  "2\035.gnostic.openapi.v3.ReferenceH\000B\007\n\005one"
  "of\"`\n\023HeadersOrReferences\022I\n\025additional_"
  "properties\030\001 \003(\0132*.gnostic.openapi.v3.Na"
  "medHeaderOrReference\"\201\002\n\004Info\022\r\n\005title\030\001"
  " \001(\t\022\023\n\013description\030\002 \001(\t\022\030\n\020terms_of_se"
  "rvice\030\003 \001(\t\022,\n\007contact\030\004 \001(\0132\033.gnostic.o"
  "penapi.v3.Contact\022,\n\007license\030\005 \001(\0132\033.gno"
  "stic.openapi.v3.License\022\017\n\007version\030\006 \001(\t"
  "\022=\n\027specification_extension\030\007 \003(\0132\034.gnos"
  "tic.openapi.v3.NamedAny\022\017\n\007summary\030\010 \001(\t"
  "\"O\n\tItemsItem\022B\n\023schema_or_reference\030\001 \003"
  "(\0132%.gnostic.openapi.v3.SchemaOrReferenc"
  "e\"c\n\007License\022\014\n\004name\030\001 \001(\t\022\013\n\003url\030\002 \001(\t\022"
  "=\n\027specification_extension\030\003 \003(\0132\034.gnost"
  "ic.openapi.v3.NamedAny\"\247\002\n\004Link\022\025\n\ropera"
  "tion_ref\030\001 \001(\t\022\024\n\014operation_id\030\002 \001(\t\0227\n\n"
  "parameters\030\003 \001(\0132#.gnostic.openapi.v3.An"
  "yOrExpression\0229\n\014request_body\030\004 \001(\0132#.gn"
  "ostic.openapi.v3.AnyOrExpression\022\023\n\013desc"
  "ription\030\005 \001(\t\022*\n\006server\030\006 \001(\0132\032.gnostic."
  "openapi.v3.Server\022=\n\027specification_exten"
  "sion\030\007 \003(\0132\034.gnostic.openapi.v3.NamedAny"
  "\"x\n\017LinkOrReference\022(\n\004link\030\001 \001(\0132\030.gnos"
  "tic.openapi.v3.LinkH\000\0222\n\treference\030\002 \001(\013"
  "2\035.gnostic.openapi.v3.ReferenceH\000B\007\n\005one"
  "of\"\\\n\021LinksOrReferences\022G\n\025additional_pr"
  "operties\030\001 \003(\0132(.gnostic.openapi.v3.Name"
  "dLinkOrReference\"\230\002\n\tMediaType\0225\n\006schema"
  "\030\001 \001(\0132%.gnostic.openapi.v3.SchemaOrRefe"
  "rence\022(\n\007example\030\002 \001(\0132\027.gnostic.openapi"
  ".v3.Any\022:\n\010examples\030\003 \001(\0132(.gnostic.open"
  "api.v3.ExamplesOrReferences\022/\n\010encoding\030"
  "\004 \001(\0132\035.gnostic.openapi.v3.Encodings\022=\n\027"
  "specification_extension\030\005 \003(\0132\034.gnostic."
  "openapi.v3.NamedAny\"O\n\nMediaTypes\022A\n\025add"
  "itional_properties\030\001 \003(\0132\".gnostic.opena"
  "pi.v3.NamedMediaType\"@\n\010NamedAny\022\014\n\004name"
  "\030\001 \001(\t\022&\n\005value\030\002 \001(\0132\027.gnostic.openapi."
  "v3.Any\"`\n\030NamedCallbackOrReference\022\014\n\004na"
  "me\030\001 \001(\t\0226\n\005value\030\002 \001(\0132\'.gnostic.openap"
  "i.v3.CallbackOrReference\"J\n\rNamedEncodin"
  "g\022\014\n\004name\030\001 \001(\t\022+\n\005value\030\002 \001(\0132\034.gnostic"
  ".openapi.v3.Encoding\"^\n\027NamedExampleOrRe"
  "ference\022\014\n\004name\030\001 \001(\t\0225\n\005value\030\002 \001(\0132&.g"
  "nostic.openapi.v3.ExampleOrReference\"\\\n\026"
  "NamedHeaderOrReference\022\014\n\004name\030\001 \001(\t\0224\n\005"
  "value\030\002 \001(\0132%.gnostic.openapi.v3.HeaderO"
  "rReference\"X\n\024NamedLinkOrReference\022\014\n\004na"
  "me\030\001 \001(\t\0222\n\005value\030\002 \001(\0132#.gnostic.openap"
  "i.v3.LinkOrReference\"L\n\016NamedMediaType\022\014"
  "\n\004name\030\001 \001(\t\022,\n\005value\030\002 \001(\0132\035.gnostic.op"
  "enapi.v3.MediaType\"b\n\031NamedParameterOrRe"
  "ference\022\014\n\004name\030\001 \001(\t\0227\n\005value\030\002 \001(\0132(.g"
  "nostic.openapi.v3.ParameterOrReference\"J"
  "\n\rNamedPathItem\022\014\n\004name\030\001 \001(\t\022+\n\005value\030\002"
  " \001(\0132\034.gnostic.openapi.v3.PathItem\"f\n\033Na"
  "medRequestBodyOrReference\022\014\n\004name\030\001 \001(\t\022"
  "9\n\005value\030\002 \001(\0132*.gnostic.openapi.v3.Requ"
  "estBodyOrReference\"`\n\030NamedResponseOrRef"
  "erence\022\014\n\004name\030\001 \001(\t\0226\n\005value\030\002 \001(\0132\'.gn"
  "ostic.openapi.v3.ResponseOrReference\"\\\n\026"
  "NamedSchemaOrReference\022\014\n\004name\030\001 \001(\t\0224\n\005"
  "value\030\002 \001(\0132%.gnostic.openapi.v3.SchemaO"
  "rReference\"l\n\036NamedSecuritySchemeOrRefer"
  "ence\022\014\n\004name\030\001 \001(\t\022<\n\005value\030\002 \001(\0132-.gnos"
  "tic.openapi.v3.SecuritySchemeOrReference"
  "\"V\n\023NamedServerVariable\022\014\n\004name\030\001 \001(\t\0221\n"
  "\005value\030\002 \001(\0132\".gnostic.openapi.v3.Server"
  "Variable\"*\n\013NamedString\022\014\n\004name\030\001 \001(\t\022\r\n"
  "\005value\030\002 \001(\t\"P\n\020NamedStringArray\022\014\n\004name"
  "\030\001 \001(\t\022.\n\005value\030\002 \001(\0132\037.gnostic.openapi."
  "v3.StringArray\"\272\001\n\tOauthFlow\022\031\n\021authoriz"
  "ation_url\030\001 \001(\t\022\021\n\ttoken_url\030\002 \001(\t\022\023\n\013re"
  "fresh_url\030\003 \001(\t\022+\n\006scopes\030\004 \001(\0132\033.gnosti"
  "c.openapi.v3.Strings\022=\n\027specification_ex"
  "tension\030\005 \003(\0132\034.gnostic.openapi.v3.Named"
  "Any\"\243\002\n\nOauthFlows\022/\n\010implicit\030\001 \001(\0132\035.g"
  "nostic.openapi.v3.OauthFlow\022/\n\010password\030"
  "\002 \001(\0132\035.gnostic.openapi.v3.OauthFlow\0229\n\022"
  "client_credentials\030\003 \001(\0132\035.gnostic.opena"
  "pi.v3.OauthFlow\0229\n\022authorization_code\030\004 "
  "\001(\0132\035.gnostic.openapi.v3.OauthFlow\022=\n\027sp"
  "ecification_extension\030\005 \003(\0132\034.gnostic.op"
  "enapi.v3.NamedAny\"E\n\006Object\022;\n\025additiona"
  "l_properties\030\001 \003(\0132\034.gnostic.openapi.v3."
  "NamedAny\"\271\004\n\tOperation\022\014\n\004tags\030\001 \003(\t\022\017\n\007"
  "summary\030\002 \001(\t\022\023\n\013description\030\003 \001(\t\0227\n\rex"
  "ternal_docs\030\004 \001(\0132 .gnostic.openapi.v3.E"
  "xternalDocs\022\024\n\014operation_id\030\005 \001(\t\022<\n\npar"
  "ameters\030\006 \003(\0132(.gnostic.openapi.v3.Param"
  "eterOrReference\022@\n\014request_body\030\007 \001(\0132*."
  "gnostic.openapi.v3.RequestBodyOrReferenc"
  "e\0220\n\tresponses\030\010 \001(\0132\035.gnostic.openapi.v"
  "3.Responses\022<\n\tcallbacks\030\t \001(\0132).gnostic"
  ".openapi.v3.CallbacksOrReferences\022\022\n\ndep"
  "recated\030\n \001(\010\0229\n\010security\030\013 \003(\0132\'.gnosti"
  "c.openapi.v3.SecurityRequirement\022+\n\007serv"
  "ers\030\014 \003(\0132\032.gnostic.openapi.v3.Server\022=\n"
  "\027specification_extension\030\r \003(\0132\034.gnostic"
  ".openapi.v3.NamedAny\"\300\003\n\tParameter\022\014\n\004na"
  "me\030\001 \001(\t\022\n\n\002in\030\002 \001(\t\022\023\n\013description\030\003 \001("
  "\t\022\020\n\010required\030\004 \001(\010\022\022\n\ndeprecated\030\005 \001(\010\022"
  "\031\n\021allow_empty_value\030\006 \001(\010\022\r\n\005style\030\007 \001("
  "\t\022\017\n\007explode\030\010 \001(\010\022\026\n\016allow_reserved\030\t \001"
  "(\010\0225\n\006schema\030\n \001(\0132%.gnostic.openapi.v3."
  "SchemaOrReference\022(\n\007example\030\013 \001(\0132\027.gno"
  "stic.openapi.v3.Any\022:\n\010examples\030\014 \001(\0132(."
  "gnostic.openapi.v3.ExamplesOrReferences\022"
  "/\n\007content\030\r \001(\0132\036.gnostic.openapi.v3.Me"
  "diaTypes\022=\n\027specification_extension\030\016 \003("
  "\0132\034.gnostic.openapi.v3.NamedAny\"\207\001\n\024Para"
  "meterOrReference\0222\n\tparameter\030\001 \001(\0132\035.gn"
  "ostic.openapi.v3.ParameterH\000\0222\n\treferenc"
  "e\030\002 \001(\0132\035.gnostic.openapi.v3.ReferenceH\000"
  "B\007\n\005oneof\"f\n\026ParametersOrReferences\022L\n\025a"
  "dditional_properties\030\001 \003(\0132-.gnostic.ope"
  "napi.v3.NamedParameterOrReference\"\325\004\n\010Pa"
  "thItem\022\014\n\004_ref\030\001 \001(\t\022\017\n\007summary\030\002 \001(\t\022\023\n"
  "\013description\030\003 \001(\t\022*\n\003get\030\004 \001(\0132\035.gnosti"
  "c.openapi.v3.Operation\022*\n\003put\030\005 \001(\0132\035.gn"
  "ostic.openapi.v3.Operation\022+\n\004post\030\006 \001(\013"
  "2\035.gnostic.openapi.v3.Operation\022-\n\006delet"
  "e\030\007 \001(\0132\035.gnostic.openapi.v3.Operation\022."
  "\n\007options\030\010 \001(\0132\035.gnostic.openapi.v3.Ope"
  "ration\022+\n\004head\030\t \001(\0132\035.gnostic.openapi.v"
  "3.Operation\022,\n\005patch\030\n \001(\0132\035.gnostic.ope"
  "napi.v3.Operation\022,\n\005trace\030\013 \001(\0132\035.gnost"
  "ic.openapi.v3.Operation\022+\n\007servers\030\014 \003(\013"
  "2\032.gnostic.openapi.v3.Server\022<\n\nparamete"
  "rs\030\r \003(\0132(.gnostic.openapi.v3.ParameterO"
  "rReference\022=\n\027specification_extension\030\016 "
  "\003(\0132\034.gnostic.openapi.v3.NamedAny\"w\n\005Pat"
  "hs\022/\n\004path\030\001 \003(\0132!.gnostic.openapi.v3.Na"
  "medPathItem\022=\n\027specification_extension\030\002"
  " \003(\0132\034.gnostic.openapi.v3.NamedAny\"W\n\nPr"
  "operties\022I\n\025additional_properties\030\001 \003(\0132"
  "*.gnostic.openapi.v3.NamedSchemaOrRefere"
  "nce\"\?\n\tReference\022\014\n\004_ref\030\001 \001(\t\022\017\n\007summar"
  "y\030\002 \001(\t\022\023\n\013description\030\003 \001(\t\"k\n\031RequestB"
  "odiesOrReferences\022N\n\025additional_properti"
  "es\030\001 \003(\0132/.gnostic.openapi.v3.NamedReque"
  "stBodyOrReference\"\244\001\n\013RequestBody\022\023\n\013des"
  "cription\030\001 \001(\t\022/\n\007content\030\002 \001(\0132\036.gnosti"
  "c.openapi.v3.MediaTypes\022\020\n\010required\030\003 \001("
  "\010\022=\n\027specification_extension\030\004 \003(\0132\034.gno"
  "stic.openapi.v3.NamedAny\"\216\001\n\026RequestBody"
  "OrReference\0227\n\014request_body\030\001 \001(\0132\037.gnos"
  "tic.openapi.v3.RequestBodyH\000\0222\n\treferenc"
  "e\030\002 \001(\0132\035.gnostic.openapi.v3.ReferenceH\000"
  "B\007\n\005oneof\"\377\001\n\010Response\022\023\n\013description\030\001 "
  "\001(\t\0228\n\007headers\030\002 \001(\0132\'.gnostic.openapi.v"
  "3.HeadersOrReferences\022/\n\007content\030\003 \001(\0132\036"
  ".gnostic.openapi.v3.MediaTypes\0224\n\005links\030"
  "\004 \001(\0132%.gnostic.openapi.v3.LinksOrRefere"
  "nces\022=\n\027specification_extension\030\005 \003(\0132\034."
  "gnostic.openapi.v3.NamedAny\"\204\001\n\023Response"
  "OrReference\0220\n\010response\030\001 \001(\0132\034.gnostic."
  "openapi.v3.ResponseH\000\0222\n\treference\030\002 \001(\013"
  "2\035.gnostic.openapi.v3.ReferenceH\000B\007\n\005one"
  "of\"\321\001\n\tResponses\0228\n\007default\030\001 \001(\0132\'.gnos"
  "tic.openapi.v3.ResponseOrReference\022K\n\025re"
  "sponse_or_reference\030\002 \003(\0132,.gnostic.open"
  "api.v3.NamedResponseOrReference\022=\n\027speci"
  "fication_extension\030\003 \003(\0132\034.gnostic.opena"
  "pi.v3.NamedAny\"d\n\025ResponsesOrReferences\022"
  "K\n\025additional_properties\030\001 \003(\0132,.gnostic"
  ".openapi.v3.NamedResponseOrReference\"\223\t\n"
  "\006Schema\022\020\n\010nullable\030\001 \001(\010\0228\n\rdiscriminat"
  "or\030\002 \001(\0132!.gnostic.openapi.v3.Discrimina"
  "tor\022\021\n\tread_only\030\003 \001(\010\022\022\n\nwrite_only\030\004 \001"
  "(\010\022$\n\003xml\030\005 \001(\0132\027.gnostic.openapi.v3.Xml"
  "\0227\n\rexternal_docs\030\006 \001(\0132 .gnostic.openap"
  "i.v3.ExternalDocs\022(\n\007example\030\007 \001(\0132\027.gno"
  "stic.openapi.v3.Any\022\022\n\ndeprecated\030\010 \001(\010\022"
  "\r\n\005title\030\t \001(\t\022\023\n\013multiple_of\030\n \001(\001\022\017\n\007m"
  "aximum\030\013 \001(\001\022\031\n\021exclusive_maximum\030\014 \001(\010\022"
  "\017\n\007minimum\030\r \001(\001\022\031\n\021exclusive_minimum\030\016 "
  "\001(\010\022\022\n\nmax_length\030\017 \001(\003\022\022\n\nmin_length\030\020 "
  "\001(\003\022\017\n\007pattern\030\021 \001(\t\022\021\n\tmax_items\030\022 \001(\003\022"
  "\021\n\tmin_items\030\023 \001(\003\022\024\n\014unique_items\030\024 \001(\010"
  "\022\026\n\016max_properties\030\025 \001(\003\022\026\n\016min_properti"
  "es\030\026 \001(\003\022\020\n\010required\030\027 \003(\t\022%\n\004enum\030\030 \003(\013"
  "2\027.gnostic.openapi.v3.Any\022\014\n\004type\030\031 \001(\t\022"
  "5\n\006all_of\030\032 \003(\0132%.gnostic.openapi.v3.Sch"
  "emaOrReference\0225\n\006one_of\030\033 \003(\0132%.gnostic"
  ".openapi.v3.SchemaOrReference\0225\n\006any_of\030"
  "\034 \003(\0132%.gnostic.openapi.v3.SchemaOrRefer"
  "ence\022\'\n\003not\030\035 \001(\0132\032.gnostic.openapi.v3.S"
  "chema\022,\n\005items\030\036 \001(\0132\035.gnostic.openapi.v"
  "3.ItemsItem\0222\n\nproperties\030\037 \001(\0132\036.gnosti"
  "c.openapi.v3.Properties\022K\n\025additional_pr"
  "operties\030  \001(\0132,.gnostic.openapi.v3.Addi"
  "tionalPropertiesItem\0220\n\007default\030! \001(\0132\037."
  "gnostic.openapi.v3.DefaultType\022\023\n\013descri"
  "ption\030\" \001(\t\022\016\n\006format\030# \001(\t\022=\n\027specifica"
  "tion_extension\030$ \003(\0132\034.gnostic.openapi.v"
  "3.NamedAny\"~\n\021SchemaOrReference\022,\n\006schem"
  "a\030\001 \001(\0132\032.gnostic.openapi.v3.SchemaH\000\0222\n"
  "\treference\030\002 \001(\0132\035.gnostic.openapi.v3.Re"
  "ferenceH\000B\007\n\005oneof\"`\n\023SchemasOrReference"
  "s\022I\n\025additional_properties\030\001 \003(\0132*.gnost"
  "ic.openapi.v3.NamedSchemaOrReference\"Z\n\023"
  "SecurityRequirement\022C\n\025additional_proper"
  "ties\030\001 \003(\0132$.gnostic.openapi.v3.NamedStr"
  "ingArray\"\377\001\n\016SecurityScheme\022\014\n\004type\030\001 \001("
  "\t\022\023\n\013description\030\002 \001(\t\022\014\n\004name\030\003 \001(\t\022\n\n\002"
  "in\030\004 \001(\t\022\016\n\006scheme\030\005 \001(\t\022\025\n\rbearer_forma"
  "t\030\006 \001(\t\022-\n\005flows\030\007 \001(\0132\036.gnostic.openapi"
  ".v3.OauthFlows\022\033\n\023open_id_connect_url\030\010 "
  "\001(\t\022=\n\027specification_extension\030\t \003(\0132\034.g"
  "nostic.openapi.v3.NamedAny\"\227\001\n\031SecurityS"
  "chemeOrReference\022=\n\017security_scheme\030\001 \001("
  "\0132\".gnostic.openapi.v3.SecuritySchemeH\000\022"
  "2\n\treference\030\002 \001(\0132\035.gnostic.openapi.v3."
  "ReferenceH\000B\007\n\005oneof\"p\n\033SecuritySchemesO"
  "rReferences\022Q\n\025additional_properties\030\001 \003"
  "(\01322.gnostic.openapi.v3.NamedSecuritySch"
  "emeOrReference\"\241\001\n\006Server\022\013\n\003url\030\001 \001(\t\022\023"
  "\n\013description\030\002 \001(\t\0226\n\tvariables\030\003 \001(\0132#"
  ".gnostic.openapi.v3.ServerVariables\022=\n\027s"
  "pecification_extension\030\004 \003(\0132\034.gnostic.o"
  "penapi.v3.NamedAny\"\203\001\n\016ServerVariable\022\014\n"
  "\004enum\030\001 \003(\t\022\017\n\007default\030\002 \001(\t\022\023\n\013descript"
  "ion\030\003 \001(\t\022=\n\027specification_extension\030\004 \003"
  "(\0132\034.gnostic.openapi.v3.NamedAny\"Y\n\017Serv"
  "erVariables\022F\n\025additional_properties\030\001 \003"
  "(\0132\'.gnostic.openapi.v3.NamedServerVaria"
  "ble\"X\n\026SpecificationExtension\022\020\n\006number\030"
  "\001 \001(\001H\000\022\021\n\007boolean\030\002 \001(\010H\000\022\020\n\006string\030\003 \001"
  "(\tH\000B\007\n\005oneof\"\034\n\013StringArray\022\r\n\005value\030\001 "
  "\003(\t\"I\n\007Strings\022>\n\025additional_properties\030"
  "\001 \003(\0132\037.gnostic.openapi.v3.NamedString\"\240"
  "\001\n\003Tag\022\014\n\004name\030\001 \001(\t\022\023\n\013description\030\002 \001("
  "\t\0227\n\rexternal_docs\030\003 \001(\0132 .gnostic.opena"
  "pi.v3.ExternalDocs\022=\n\027specification_exte"
  "nsion\030\004 \003(\0132\034.gnostic.openapi.v3.NamedAn"
  "y\"\231\001\n\003Xml\022\014\n\004name\030\001 \001(\t\022\021\n\tnamespace\030\002 \001"
  "(\t\022\016\n\006prefix\030\003 \001(\t\022\021\n\tattribute\030\004 \001(\010\022\017\n"
  "\007wrapped\030\005 \001(\010\022=\n\027specification_extensio"
  "n\030\006 \003(\0132\034.gnostic.openapi.v3.NamedAnyBV\n"
  "\016org.openapi_v3B\014OpenAPIProtoP\001Z.github."
  "com/google/gnostic/openapiv3;openapi_v3\242"
  "\002\003OASb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fany_2eproto,
};
static ::_pbi::once_flag descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto = {
    false, false, 13253, descriptor_table_protodef_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto,
    "gnostic/openapi/v3/openapiv3.proto",
    &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once, descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_deps, 1, 78,
    schemas, file_default_instances, TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto::offsets,
    file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto, file_level_enum_descriptors_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto,
    file_level_service_descriptors_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter() {
  return &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto(&descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto);
namespace gnostic {
namespace openapi {
namespace v3 {

// ===================================================================

class AdditionalPropertiesItem::_Internal {
 public:
  static const ::gnostic::openapi::v3::SchemaOrReference& schema_or_reference(const AdditionalPropertiesItem* msg);
};

const ::gnostic::openapi::v3::SchemaOrReference&
AdditionalPropertiesItem::_Internal::schema_or_reference(const AdditionalPropertiesItem* msg) {
  return *msg->_impl_.oneof_.schema_or_reference_;
}
void AdditionalPropertiesItem::set_allocated_schema_or_reference(::gnostic::openapi::v3::SchemaOrReference* schema_or_reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (schema_or_reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema_or_reference);
    if (message_arena != submessage_arena) {
      schema_or_reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_or_reference, submessage_arena);
    }
    set_has_schema_or_reference();
    _impl_.oneof_.schema_or_reference_ = schema_or_reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.AdditionalPropertiesItem.schema_or_reference)
}
AdditionalPropertiesItem::AdditionalPropertiesItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.AdditionalPropertiesItem)
}
AdditionalPropertiesItem::AdditionalPropertiesItem(const AdditionalPropertiesItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AdditionalPropertiesItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kSchemaOrReference: {
      _this->_internal_mutable_schema_or_reference()->::gnostic::openapi::v3::SchemaOrReference::MergeFrom(
          from._internal_schema_or_reference());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.AdditionalPropertiesItem)
}

inline void AdditionalPropertiesItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

AdditionalPropertiesItem::~AdditionalPropertiesItem() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.AdditionalPropertiesItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AdditionalPropertiesItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void AdditionalPropertiesItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AdditionalPropertiesItem::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.AdditionalPropertiesItem)
  switch (oneof_case()) {
    case kSchemaOrReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.schema_or_reference_;
      }
      break;
    }
    case kBoolean: {
      // No need to clear
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void AdditionalPropertiesItem::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.AdditionalPropertiesItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AdditionalPropertiesItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema_or_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool boolean = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_boolean(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdditionalPropertiesItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.AdditionalPropertiesItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
  if (_internal_has_schema_or_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::schema_or_reference(this),
        _Internal::schema_or_reference(this).GetCachedSize(), target, stream);
  }

  // bool boolean = 2;
  if (_internal_has_boolean()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_boolean(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.AdditionalPropertiesItem)
  return target;
}

size_t AdditionalPropertiesItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.AdditionalPropertiesItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
    case kSchemaOrReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.schema_or_reference_);
      break;
    }
    // bool boolean = 2;
    case kBoolean: {
      total_size += 1 + 1;
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AdditionalPropertiesItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AdditionalPropertiesItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AdditionalPropertiesItem::GetClassData() const { return &_class_data_; }


void AdditionalPropertiesItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AdditionalPropertiesItem*>(&to_msg);
  auto& from = static_cast<const AdditionalPropertiesItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.AdditionalPropertiesItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kSchemaOrReference: {
      _this->_internal_mutable_schema_or_reference()->::gnostic::openapi::v3::SchemaOrReference::MergeFrom(
          from._internal_schema_or_reference());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AdditionalPropertiesItem::CopyFrom(const AdditionalPropertiesItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.AdditionalPropertiesItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdditionalPropertiesItem::IsInitialized() const {
  return true;
}

void AdditionalPropertiesItem::InternalSwap(AdditionalPropertiesItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AdditionalPropertiesItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[0]);
}

// ===================================================================

class Any::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Any& value(const Any* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Any&
Any::_Internal::value(const Any* msg) {
  return *msg->_impl_.value_;
}
void Any::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
Any::Any(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Any)
}
Any::Any(const Any& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Any* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.yaml_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.yaml_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.yaml_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_yaml().empty()) {
    _this->_impl_.yaml_.Set(from._internal_yaml(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Any)
}

inline void Any::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.yaml_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.yaml_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.yaml_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Any::~Any() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Any)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Any::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.yaml_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void Any::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Any::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Any)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.yaml_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Any::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Any value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string yaml = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_yaml();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Any.yaml"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Any::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Any)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Any value = 1;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  // string yaml = 2;
  if (!this->_internal_yaml().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_yaml().data(), static_cast<int>(this->_internal_yaml().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Any.yaml");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_yaml(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Any)
  return target;
}

size_t Any::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Any)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string yaml = 2;
  if (!this->_internal_yaml().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_yaml());
  }

  // .google.protobuf.Any value = 1;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Any::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Any::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Any::GetClassData() const { return &_class_data_; }


void Any::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Any*>(&to_msg);
  auto& from = static_cast<const Any&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Any)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_yaml().empty()) {
    _this->_internal_set_yaml(from._internal_yaml());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Any::CopyFrom(const Any& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Any)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Any::IsInitialized() const {
  return true;
}

void Any::InternalSwap(Any* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.yaml_, lhs_arena,
      &other->_impl_.yaml_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Any::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[1]);
}

// ===================================================================

class AnyOrExpression::_Internal {
 public:
  static const ::gnostic::openapi::v3::Any& any(const AnyOrExpression* msg);
  static const ::gnostic::openapi::v3::Expression& expression(const AnyOrExpression* msg);
};

const ::gnostic::openapi::v3::Any&
AnyOrExpression::_Internal::any(const AnyOrExpression* msg) {
  return *msg->_impl_.oneof_.any_;
}
const ::gnostic::openapi::v3::Expression&
AnyOrExpression::_Internal::expression(const AnyOrExpression* msg) {
  return *msg->_impl_.oneof_.expression_;
}
void AnyOrExpression::set_allocated_any(::gnostic::openapi::v3::Any* any) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (any) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(any);
    if (message_arena != submessage_arena) {
      any = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, any, submessage_arena);
    }
    set_has_any();
    _impl_.oneof_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.AnyOrExpression.any)
}
void AnyOrExpression::set_allocated_expression(::gnostic::openapi::v3::Expression* expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expression);
    if (message_arena != submessage_arena) {
      expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expression, submessage_arena);
    }
    set_has_expression();
    _impl_.oneof_.expression_ = expression;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.AnyOrExpression.expression)
}
AnyOrExpression::AnyOrExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.AnyOrExpression)
}
AnyOrExpression::AnyOrExpression(const AnyOrExpression& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnyOrExpression* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kAny: {
      _this->_internal_mutable_any()->::gnostic::openapi::v3::Any::MergeFrom(
          from._internal_any());
      break;
    }
    case kExpression: {
      _this->_internal_mutable_expression()->::gnostic::openapi::v3::Expression::MergeFrom(
          from._internal_expression());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.AnyOrExpression)
}

inline void AnyOrExpression::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

AnyOrExpression::~AnyOrExpression() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.AnyOrExpression)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnyOrExpression::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void AnyOrExpression::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnyOrExpression::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.AnyOrExpression)
  switch (oneof_case()) {
    case kAny: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.any_;
      }
      break;
    }
    case kExpression: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.expression_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void AnyOrExpression::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.AnyOrExpression)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnyOrExpression::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Any any = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_any(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Expression expression = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_expression(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnyOrExpression::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.AnyOrExpression)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Any any = 1;
  if (_internal_has_any()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::any(this),
        _Internal::any(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Expression expression = 2;
  if (_internal_has_expression()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::expression(this),
        _Internal::expression(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.AnyOrExpression)
  return target;
}

size_t AnyOrExpression::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.AnyOrExpression)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Any any = 1;
    case kAny: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.any_);
      break;
    }
    // .gnostic.openapi.v3.Expression expression = 2;
    case kExpression: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.expression_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnyOrExpression::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnyOrExpression::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnyOrExpression::GetClassData() const { return &_class_data_; }


void AnyOrExpression::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnyOrExpression*>(&to_msg);
  auto& from = static_cast<const AnyOrExpression&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.AnyOrExpression)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kAny: {
      _this->_internal_mutable_any()->::gnostic::openapi::v3::Any::MergeFrom(
          from._internal_any());
      break;
    }
    case kExpression: {
      _this->_internal_mutable_expression()->::gnostic::openapi::v3::Expression::MergeFrom(
          from._internal_expression());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnyOrExpression::CopyFrom(const AnyOrExpression& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.AnyOrExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnyOrExpression::IsInitialized() const {
  return true;
}

void AnyOrExpression::InternalSwap(AnyOrExpression* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnyOrExpression::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[2]);
}

// ===================================================================

class Callback::_Internal {
 public:
};

Callback::Callback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Callback)
}
Callback::Callback(const Callback& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Callback* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){from._impl_.path_}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Callback)
}

inline void Callback::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){arena}
    , decltype(_impl_.specification_extension_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Callback::~Callback() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Callback)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Callback::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
}

void Callback::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Callback::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Callback)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.Clear();
  _impl_.specification_extension_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Callback::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_path(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Callback::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Callback)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_path_size()); i < n; i++) {
    const auto& repfield = this->_internal_path(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Callback)
  return target;
}

size_t Callback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Callback)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
  total_size += 1UL * this->_internal_path_size();
  for (const auto& msg : this->_impl_.path_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Callback::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Callback::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Callback::GetClassData() const { return &_class_data_; }


void Callback::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Callback*>(&to_msg);
  auto& from = static_cast<const Callback&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Callback)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.path_.MergeFrom(from._impl_.path_);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Callback::CopyFrom(const Callback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Callback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Callback::IsInitialized() const {
  return true;
}

void Callback::InternalSwap(Callback* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Callback::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[3]);
}

// ===================================================================

class CallbackOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::Callback& callback(const CallbackOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const CallbackOrReference* msg);
};

const ::gnostic::openapi::v3::Callback&
CallbackOrReference::_Internal::callback(const CallbackOrReference* msg) {
  return *msg->_impl_.oneof_.callback_;
}
const ::gnostic::openapi::v3::Reference&
CallbackOrReference::_Internal::reference(const CallbackOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void CallbackOrReference::set_allocated_callback(::gnostic::openapi::v3::Callback* callback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (callback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(callback);
    if (message_arena != submessage_arena) {
      callback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callback, submessage_arena);
    }
    set_has_callback();
    _impl_.oneof_.callback_ = callback;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.CallbackOrReference.callback)
}
void CallbackOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.CallbackOrReference.reference)
}
CallbackOrReference::CallbackOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.CallbackOrReference)
}
CallbackOrReference::CallbackOrReference(const CallbackOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CallbackOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kCallback: {
      _this->_internal_mutable_callback()->::gnostic::openapi::v3::Callback::MergeFrom(
          from._internal_callback());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.CallbackOrReference)
}

inline void CallbackOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

CallbackOrReference::~CallbackOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.CallbackOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CallbackOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void CallbackOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CallbackOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.CallbackOrReference)
  switch (oneof_case()) {
    case kCallback: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.callback_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void CallbackOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.CallbackOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CallbackOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Callback callback = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_callback(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallbackOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.CallbackOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Callback callback = 1;
  if (_internal_has_callback()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::callback(this),
        _Internal::callback(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.CallbackOrReference)
  return target;
}

size_t CallbackOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.CallbackOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Callback callback = 1;
    case kCallback: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.callback_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CallbackOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CallbackOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CallbackOrReference::GetClassData() const { return &_class_data_; }


void CallbackOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CallbackOrReference*>(&to_msg);
  auto& from = static_cast<const CallbackOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.CallbackOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kCallback: {
      _this->_internal_mutable_callback()->::gnostic::openapi::v3::Callback::MergeFrom(
          from._internal_callback());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CallbackOrReference::CopyFrom(const CallbackOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.CallbackOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallbackOrReference::IsInitialized() const {
  return true;
}

void CallbackOrReference::InternalSwap(CallbackOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CallbackOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[4]);
}

// ===================================================================

class CallbacksOrReferences::_Internal {
 public:
};

CallbacksOrReferences::CallbacksOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.CallbacksOrReferences)
}
CallbacksOrReferences::CallbacksOrReferences(const CallbacksOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CallbacksOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.CallbacksOrReferences)
}

inline void CallbacksOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CallbacksOrReferences::~CallbacksOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.CallbacksOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CallbacksOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void CallbacksOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CallbacksOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.CallbacksOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CallbacksOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallbacksOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.CallbacksOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.CallbacksOrReferences)
  return target;
}

size_t CallbacksOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.CallbacksOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CallbacksOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CallbacksOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CallbacksOrReferences::GetClassData() const { return &_class_data_; }


void CallbacksOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CallbacksOrReferences*>(&to_msg);
  auto& from = static_cast<const CallbacksOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.CallbacksOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CallbacksOrReferences::CopyFrom(const CallbacksOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.CallbacksOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallbacksOrReferences::IsInitialized() const {
  return true;
}

void CallbacksOrReferences::InternalSwap(CallbacksOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CallbacksOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[5]);
}

// ===================================================================

class Components::_Internal {
 public:
  static const ::gnostic::openapi::v3::SchemasOrReferences& schemas(const Components* msg);
  static const ::gnostic::openapi::v3::ResponsesOrReferences& responses(const Components* msg);
  static const ::gnostic::openapi::v3::ParametersOrReferences& parameters(const Components* msg);
  static const ::gnostic::openapi::v3::ExamplesOrReferences& examples(const Components* msg);
  static const ::gnostic::openapi::v3::RequestBodiesOrReferences& request_bodies(const Components* msg);
  static const ::gnostic::openapi::v3::HeadersOrReferences& headers(const Components* msg);
  static const ::gnostic::openapi::v3::SecuritySchemesOrReferences& security_schemes(const Components* msg);
  static const ::gnostic::openapi::v3::LinksOrReferences& links(const Components* msg);
  static const ::gnostic::openapi::v3::CallbacksOrReferences& callbacks(const Components* msg);
};

const ::gnostic::openapi::v3::SchemasOrReferences&
Components::_Internal::schemas(const Components* msg) {
  return *msg->_impl_.schemas_;
}
const ::gnostic::openapi::v3::ResponsesOrReferences&
Components::_Internal::responses(const Components* msg) {
  return *msg->_impl_.responses_;
}
const ::gnostic::openapi::v3::ParametersOrReferences&
Components::_Internal::parameters(const Components* msg) {
  return *msg->_impl_.parameters_;
}
const ::gnostic::openapi::v3::ExamplesOrReferences&
Components::_Internal::examples(const Components* msg) {
  return *msg->_impl_.examples_;
}
const ::gnostic::openapi::v3::RequestBodiesOrReferences&
Components::_Internal::request_bodies(const Components* msg) {
  return *msg->_impl_.request_bodies_;
}
const ::gnostic::openapi::v3::HeadersOrReferences&
Components::_Internal::headers(const Components* msg) {
  return *msg->_impl_.headers_;
}
const ::gnostic::openapi::v3::SecuritySchemesOrReferences&
Components::_Internal::security_schemes(const Components* msg) {
  return *msg->_impl_.security_schemes_;
}
const ::gnostic::openapi::v3::LinksOrReferences&
Components::_Internal::links(const Components* msg) {
  return *msg->_impl_.links_;
}
const ::gnostic::openapi::v3::CallbacksOrReferences&
Components::_Internal::callbacks(const Components* msg) {
  return *msg->_impl_.callbacks_;
}
Components::Components(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Components)
}
Components::Components(const Components& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Components* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.schemas_){nullptr}
    , decltype(_impl_.responses_){nullptr}
    , decltype(_impl_.parameters_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.request_bodies_){nullptr}
    , decltype(_impl_.headers_){nullptr}
    , decltype(_impl_.security_schemes_){nullptr}
    , decltype(_impl_.links_){nullptr}
    , decltype(_impl_.callbacks_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_schemas()) {
    _this->_impl_.schemas_ = new ::gnostic::openapi::v3::SchemasOrReferences(*from._impl_.schemas_);
  }
  if (from._internal_has_responses()) {
    _this->_impl_.responses_ = new ::gnostic::openapi::v3::ResponsesOrReferences(*from._impl_.responses_);
  }
  if (from._internal_has_parameters()) {
    _this->_impl_.parameters_ = new ::gnostic::openapi::v3::ParametersOrReferences(*from._impl_.parameters_);
  }
  if (from._internal_has_examples()) {
    _this->_impl_.examples_ = new ::gnostic::openapi::v3::ExamplesOrReferences(*from._impl_.examples_);
  }
  if (from._internal_has_request_bodies()) {
    _this->_impl_.request_bodies_ = new ::gnostic::openapi::v3::RequestBodiesOrReferences(*from._impl_.request_bodies_);
  }
  if (from._internal_has_headers()) {
    _this->_impl_.headers_ = new ::gnostic::openapi::v3::HeadersOrReferences(*from._impl_.headers_);
  }
  if (from._internal_has_security_schemes()) {
    _this->_impl_.security_schemes_ = new ::gnostic::openapi::v3::SecuritySchemesOrReferences(*from._impl_.security_schemes_);
  }
  if (from._internal_has_links()) {
    _this->_impl_.links_ = new ::gnostic::openapi::v3::LinksOrReferences(*from._impl_.links_);
  }
  if (from._internal_has_callbacks()) {
    _this->_impl_.callbacks_ = new ::gnostic::openapi::v3::CallbacksOrReferences(*from._impl_.callbacks_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Components)
}

inline void Components::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.schemas_){nullptr}
    , decltype(_impl_.responses_){nullptr}
    , decltype(_impl_.parameters_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.request_bodies_){nullptr}
    , decltype(_impl_.headers_){nullptr}
    , decltype(_impl_.security_schemes_){nullptr}
    , decltype(_impl_.links_){nullptr}
    , decltype(_impl_.callbacks_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Components::~Components() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Components)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Components::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.schemas_;
  if (this != internal_default_instance()) delete _impl_.responses_;
  if (this != internal_default_instance()) delete _impl_.parameters_;
  if (this != internal_default_instance()) delete _impl_.examples_;
  if (this != internal_default_instance()) delete _impl_.request_bodies_;
  if (this != internal_default_instance()) delete _impl_.headers_;
  if (this != internal_default_instance()) delete _impl_.security_schemes_;
  if (this != internal_default_instance()) delete _impl_.links_;
  if (this != internal_default_instance()) delete _impl_.callbacks_;
}

void Components::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Components::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Components)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.schemas_ != nullptr) {
    delete _impl_.schemas_;
  }
  _impl_.schemas_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.responses_ != nullptr) {
    delete _impl_.responses_;
  }
  _impl_.responses_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.parameters_ != nullptr) {
    delete _impl_.parameters_;
  }
  _impl_.parameters_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.request_bodies_ != nullptr) {
    delete _impl_.request_bodies_;
  }
  _impl_.request_bodies_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.headers_ != nullptr) {
    delete _impl_.headers_;
  }
  _impl_.headers_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.security_schemes_ != nullptr) {
    delete _impl_.security_schemes_;
  }
  _impl_.security_schemes_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.links_ != nullptr) {
    delete _impl_.links_;
  }
  _impl_.links_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.callbacks_ != nullptr) {
    delete _impl_.callbacks_;
  }
  _impl_.callbacks_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Components::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.SchemasOrReferences schemas = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_schemas(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ResponsesOrReferences responses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_responses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ParametersOrReferences parameters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExamplesOrReferences examples = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_examples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_bodies(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.HeadersOrReferences headers = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_security_schemes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.LinksOrReferences links = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_links(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_callbacks(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Components::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Components)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.SchemasOrReferences schemas = 1;
  if (this->_internal_has_schemas()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::schemas(this),
        _Internal::schemas(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ResponsesOrReferences responses = 2;
  if (this->_internal_has_responses()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::responses(this),
        _Internal::responses(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ParametersOrReferences parameters = 3;
  if (this->_internal_has_parameters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parameters(this),
        _Internal::parameters(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 4;
  if (this->_internal_has_examples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::examples(this),
        _Internal::examples(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5;
  if (this->_internal_has_request_bodies()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::request_bodies(this),
        _Internal::request_bodies(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.HeadersOrReferences headers = 6;
  if (this->_internal_has_headers()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::headers(this),
        _Internal::headers(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7;
  if (this->_internal_has_security_schemes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::security_schemes(this),
        _Internal::security_schemes(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.LinksOrReferences links = 8;
  if (this->_internal_has_links()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::links(this),
        _Internal::links(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
  if (this->_internal_has_callbacks()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::callbacks(this),
        _Internal::callbacks(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Components)
  return target;
}

size_t Components::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Components)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 10;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .gnostic.openapi.v3.SchemasOrReferences schemas = 1;
  if (this->_internal_has_schemas()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.schemas_);
  }

  // .gnostic.openapi.v3.ResponsesOrReferences responses = 2;
  if (this->_internal_has_responses()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.responses_);
  }

  // .gnostic.openapi.v3.ParametersOrReferences parameters = 3;
  if (this->_internal_has_parameters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parameters_);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 4;
  if (this->_internal_has_examples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.examples_);
  }

  // .gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5;
  if (this->_internal_has_request_bodies()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.request_bodies_);
  }

  // .gnostic.openapi.v3.HeadersOrReferences headers = 6;
  if (this->_internal_has_headers()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.headers_);
  }

  // .gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7;
  if (this->_internal_has_security_schemes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.security_schemes_);
  }

  // .gnostic.openapi.v3.LinksOrReferences links = 8;
  if (this->_internal_has_links()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.links_);
  }

  // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
  if (this->_internal_has_callbacks()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.callbacks_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Components::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Components::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Components::GetClassData() const { return &_class_data_; }


void Components::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Components*>(&to_msg);
  auto& from = static_cast<const Components&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Components)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (from._internal_has_schemas()) {
    _this->_internal_mutable_schemas()->::gnostic::openapi::v3::SchemasOrReferences::MergeFrom(
        from._internal_schemas());
  }
  if (from._internal_has_responses()) {
    _this->_internal_mutable_responses()->::gnostic::openapi::v3::ResponsesOrReferences::MergeFrom(
        from._internal_responses());
  }
  if (from._internal_has_parameters()) {
    _this->_internal_mutable_parameters()->::gnostic::openapi::v3::ParametersOrReferences::MergeFrom(
        from._internal_parameters());
  }
  if (from._internal_has_examples()) {
    _this->_internal_mutable_examples()->::gnostic::openapi::v3::ExamplesOrReferences::MergeFrom(
        from._internal_examples());
  }
  if (from._internal_has_request_bodies()) {
    _this->_internal_mutable_request_bodies()->::gnostic::openapi::v3::RequestBodiesOrReferences::MergeFrom(
        from._internal_request_bodies());
  }
  if (from._internal_has_headers()) {
    _this->_internal_mutable_headers()->::gnostic::openapi::v3::HeadersOrReferences::MergeFrom(
        from._internal_headers());
  }
  if (from._internal_has_security_schemes()) {
    _this->_internal_mutable_security_schemes()->::gnostic::openapi::v3::SecuritySchemesOrReferences::MergeFrom(
        from._internal_security_schemes());
  }
  if (from._internal_has_links()) {
    _this->_internal_mutable_links()->::gnostic::openapi::v3::LinksOrReferences::MergeFrom(
        from._internal_links());
  }
  if (from._internal_has_callbacks()) {
    _this->_internal_mutable_callbacks()->::gnostic::openapi::v3::CallbacksOrReferences::MergeFrom(
        from._internal_callbacks());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Components::CopyFrom(const Components& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Components)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Components::IsInitialized() const {
  return true;
}

void Components::InternalSwap(Components* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Components, _impl_.callbacks_)
      + sizeof(Components::_impl_.callbacks_)
      - PROTOBUF_FIELD_OFFSET(Components, _impl_.schemas_)>(
          reinterpret_cast<char*>(&_impl_.schemas_),
          reinterpret_cast<char*>(&other->_impl_.schemas_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Components::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[6]);
}

// ===================================================================

class Contact::_Internal {
 public:
};

Contact::Contact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Contact)
}
Contact::Contact(const Contact& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Contact* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.email_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Contact)
}

inline void Contact::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.email_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Contact::~Contact() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Contact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Contact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.url_.Destroy();
  _impl_.email_.Destroy();
}

void Contact::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Contact::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Contact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.url_.ClearToEmpty();
  _impl_.email_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Contact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Contact.name"));
        } else
          goto handle_unusual;
        continue;
      // string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Contact.url"));
        } else
          goto handle_unusual;
        continue;
      // string email = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Contact.email"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Contact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Contact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Contact.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Contact.url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // string email = 3;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Contact.email");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_email(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Contact)
  return target;
}

size_t Contact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Contact)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // string email = 3;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Contact::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Contact::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Contact::GetClassData() const { return &_class_data_; }


void Contact::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Contact*>(&to_msg);
  auto& from = static_cast<const Contact&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Contact)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  if (!from._internal_email().empty()) {
    _this->_internal_set_email(from._internal_email());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Contact::CopyFrom(const Contact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Contact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contact::IsInitialized() const {
  return true;
}

void Contact::InternalSwap(Contact* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Contact::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[7]);
}

// ===================================================================

class DefaultType::_Internal {
 public:
};

DefaultType::DefaultType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.DefaultType)
}
DefaultType::DefaultType(const DefaultType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DefaultType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kNumber: {
      _this->_internal_set_number(from._internal_number());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case kString: {
      _this->_internal_set_string(from._internal_string());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.DefaultType)
}

inline void DefaultType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

DefaultType::~DefaultType() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.DefaultType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DefaultType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void DefaultType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DefaultType::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.DefaultType)
  switch (oneof_case()) {
    case kNumber: {
      // No need to clear
      break;
    }
    case kBoolean: {
      // No need to clear
      break;
    }
    case kString: {
      _impl_.oneof_.string_.Destroy();
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void DefaultType::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.DefaultType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DefaultType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _internal_set_number(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool boolean = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_boolean(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.DefaultType.string"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DefaultType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.DefaultType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double number = 1;
  if (_internal_has_number()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_number(), target);
  }

  // bool boolean = 2;
  if (_internal_has_boolean()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_boolean(), target);
  }

  // string string = 3;
  if (_internal_has_string()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_string().data(), static_cast<int>(this->_internal_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.DefaultType.string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.DefaultType)
  return target;
}

size_t DefaultType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.DefaultType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // double number = 1;
    case kNumber: {
      total_size += 1 + 8;
      break;
    }
    // bool boolean = 2;
    case kBoolean: {
      total_size += 1 + 1;
      break;
    }
    // string string = 3;
    case kString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DefaultType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DefaultType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DefaultType::GetClassData() const { return &_class_data_; }


void DefaultType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DefaultType*>(&to_msg);
  auto& from = static_cast<const DefaultType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.DefaultType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kNumber: {
      _this->_internal_set_number(from._internal_number());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case kString: {
      _this->_internal_set_string(from._internal_string());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DefaultType::CopyFrom(const DefaultType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.DefaultType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DefaultType::IsInitialized() const {
  return true;
}

void DefaultType::InternalSwap(DefaultType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata DefaultType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[8]);
}

// ===================================================================

class Discriminator::_Internal {
 public:
  static const ::gnostic::openapi::v3::Strings& mapping(const Discriminator* msg);
};

const ::gnostic::openapi::v3::Strings&
Discriminator::_Internal::mapping(const Discriminator* msg) {
  return *msg->_impl_.mapping_;
}
Discriminator::Discriminator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Discriminator)
}
Discriminator::Discriminator(const Discriminator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Discriminator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.property_name_){}
    , decltype(_impl_.mapping_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.property_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.property_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_property_name().empty()) {
    _this->_impl_.property_name_.Set(from._internal_property_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_mapping()) {
    _this->_impl_.mapping_ = new ::gnostic::openapi::v3::Strings(*from._impl_.mapping_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Discriminator)
}

inline void Discriminator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.property_name_){}
    , decltype(_impl_.mapping_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.property_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.property_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Discriminator::~Discriminator() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Discriminator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Discriminator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.property_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.mapping_;
}

void Discriminator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Discriminator::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Discriminator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.property_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.mapping_ != nullptr) {
    delete _impl_.mapping_;
  }
  _impl_.mapping_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Discriminator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string property_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_property_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Discriminator.property_name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Strings mapping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Discriminator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Discriminator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string property_name = 1;
  if (!this->_internal_property_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_property_name().data(), static_cast<int>(this->_internal_property_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Discriminator.property_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_property_name(), target);
  }

  // .gnostic.openapi.v3.Strings mapping = 2;
  if (this->_internal_has_mapping()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::mapping(this),
        _Internal::mapping(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Discriminator)
  return target;
}

size_t Discriminator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Discriminator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string property_name = 1;
  if (!this->_internal_property_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_property_name());
  }

  // .gnostic.openapi.v3.Strings mapping = 2;
  if (this->_internal_has_mapping()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mapping_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Discriminator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Discriminator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Discriminator::GetClassData() const { return &_class_data_; }


void Discriminator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Discriminator*>(&to_msg);
  auto& from = static_cast<const Discriminator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Discriminator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_property_name().empty()) {
    _this->_internal_set_property_name(from._internal_property_name());
  }
  if (from._internal_has_mapping()) {
    _this->_internal_mutable_mapping()->::gnostic::openapi::v3::Strings::MergeFrom(
        from._internal_mapping());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Discriminator::CopyFrom(const Discriminator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Discriminator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Discriminator::IsInitialized() const {
  return true;
}

void Discriminator::InternalSwap(Discriminator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.property_name_, lhs_arena,
      &other->_impl_.property_name_, rhs_arena
  );
  swap(_impl_.mapping_, other->_impl_.mapping_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Discriminator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[9]);
}

// ===================================================================

class Document::_Internal {
 public:
  static const ::gnostic::openapi::v3::Info& info(const Document* msg);
  static const ::gnostic::openapi::v3::Paths& paths(const Document* msg);
  static const ::gnostic::openapi::v3::Components& components(const Document* msg);
  static const ::gnostic::openapi::v3::ExternalDocs& external_docs(const Document* msg);
};

const ::gnostic::openapi::v3::Info&
Document::_Internal::info(const Document* msg) {
  return *msg->_impl_.info_;
}
const ::gnostic::openapi::v3::Paths&
Document::_Internal::paths(const Document* msg) {
  return *msg->_impl_.paths_;
}
const ::gnostic::openapi::v3::Components&
Document::_Internal::components(const Document* msg) {
  return *msg->_impl_.components_;
}
const ::gnostic::openapi::v3::ExternalDocs&
Document::_Internal::external_docs(const Document* msg) {
  return *msg->_impl_.external_docs_;
}
Document::Document(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Document)
}
Document::Document(const Document& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Document* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.servers_){from._impl_.servers_}
    , decltype(_impl_.security_){from._impl_.security_}
    , decltype(_impl_.tags_){from._impl_.tags_}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.openapi_){}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.paths_){nullptr}
    , decltype(_impl_.components_){nullptr}
    , decltype(_impl_.external_docs_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.openapi_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.openapi_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_openapi().empty()) {
    _this->_impl_.openapi_.Set(from._internal_openapi(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::gnostic::openapi::v3::Info(*from._impl_.info_);
  }
  if (from._internal_has_paths()) {
    _this->_impl_.paths_ = new ::gnostic::openapi::v3::Paths(*from._impl_.paths_);
  }
  if (from._internal_has_components()) {
    _this->_impl_.components_ = new ::gnostic::openapi::v3::Components(*from._impl_.components_);
  }
  if (from._internal_has_external_docs()) {
    _this->_impl_.external_docs_ = new ::gnostic::openapi::v3::ExternalDocs(*from._impl_.external_docs_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Document)
}

inline void Document::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.servers_){arena}
    , decltype(_impl_.security_){arena}
    , decltype(_impl_.tags_){arena}
    , decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.openapi_){}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.paths_){nullptr}
    , decltype(_impl_.components_){nullptr}
    , decltype(_impl_.external_docs_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.openapi_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.openapi_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Document::~Document() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Document)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Document::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.servers_.~RepeatedPtrField();
  _impl_.security_.~RepeatedPtrField();
  _impl_.tags_.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.openapi_.Destroy();
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.paths_;
  if (this != internal_default_instance()) delete _impl_.components_;
  if (this != internal_default_instance()) delete _impl_.external_docs_;
}

void Document::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Document::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Document)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.servers_.Clear();
  _impl_.security_.Clear();
  _impl_.tags_.Clear();
  _impl_.specification_extension_.Clear();
  _impl_.openapi_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.paths_ != nullptr) {
    delete _impl_.paths_;
  }
  _impl_.paths_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.components_ != nullptr) {
    delete _impl_.components_;
  }
  _impl_.components_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Document::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string openapi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_openapi();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Document.openapi"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Info info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.Server servers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_servers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Paths paths = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_paths(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Components components = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_components(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.SecurityRequirement security = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_security(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.Tag tags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tags(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExternalDocs external_docs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_docs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Document::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Document)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string openapi = 1;
  if (!this->_internal_openapi().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_openapi().data(), static_cast<int>(this->_internal_openapi().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Document.openapi");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_openapi(), target);
  }

  // .gnostic.openapi.v3.Info info = 2;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.Server servers = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_servers_size()); i < n; i++) {
    const auto& repfield = this->_internal_servers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Paths paths = 4;
  if (this->_internal_has_paths()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::paths(this),
        _Internal::paths(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Components components = 5;
  if (this->_internal_has_components()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::components(this),
        _Internal::components(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.SecurityRequirement security = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_security_size()); i < n; i++) {
    const auto& repfield = this->_internal_security(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.Tag tags = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tags_size()); i < n; i++) {
    const auto& repfield = this->_internal_tags(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 8;
  if (this->_internal_has_external_docs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::external_docs(this),
        _Internal::external_docs(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Document)
  return target;
}

size_t Document::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Document)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.Server servers = 3;
  total_size += 1UL * this->_internal_servers_size();
  for (const auto& msg : this->_impl_.servers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.SecurityRequirement security = 6;
  total_size += 1UL * this->_internal_security_size();
  for (const auto& msg : this->_impl_.security_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.Tag tags = 7;
  total_size += 1UL * this->_internal_tags_size();
  for (const auto& msg : this->_impl_.tags_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string openapi = 1;
  if (!this->_internal_openapi().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_openapi());
  }

  // .gnostic.openapi.v3.Info info = 2;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  // .gnostic.openapi.v3.Paths paths = 4;
  if (this->_internal_has_paths()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.paths_);
  }

  // .gnostic.openapi.v3.Components components = 5;
  if (this->_internal_has_components()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.components_);
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 8;
  if (this->_internal_has_external_docs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.external_docs_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Document::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Document::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Document::GetClassData() const { return &_class_data_; }


void Document::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Document*>(&to_msg);
  auto& from = static_cast<const Document&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Document)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.servers_.MergeFrom(from._impl_.servers_);
  _this->_impl_.security_.MergeFrom(from._impl_.security_);
  _this->_impl_.tags_.MergeFrom(from._impl_.tags_);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_openapi().empty()) {
    _this->_internal_set_openapi(from._internal_openapi());
  }
  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::gnostic::openapi::v3::Info::MergeFrom(
        from._internal_info());
  }
  if (from._internal_has_paths()) {
    _this->_internal_mutable_paths()->::gnostic::openapi::v3::Paths::MergeFrom(
        from._internal_paths());
  }
  if (from._internal_has_components()) {
    _this->_internal_mutable_components()->::gnostic::openapi::v3::Components::MergeFrom(
        from._internal_components());
  }
  if (from._internal_has_external_docs()) {
    _this->_internal_mutable_external_docs()->::gnostic::openapi::v3::ExternalDocs::MergeFrom(
        from._internal_external_docs());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Document::CopyFrom(const Document& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Document)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Document::IsInitialized() const {
  return true;
}

void Document::InternalSwap(Document* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.servers_.InternalSwap(&other->_impl_.servers_);
  _impl_.security_.InternalSwap(&other->_impl_.security_);
  _impl_.tags_.InternalSwap(&other->_impl_.tags_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.openapi_, lhs_arena,
      &other->_impl_.openapi_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Document, _impl_.external_docs_)
      + sizeof(Document::_impl_.external_docs_)
      - PROTOBUF_FIELD_OFFSET(Document, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Document::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[10]);
}

// ===================================================================

class Encoding::_Internal {
 public:
  static const ::gnostic::openapi::v3::HeadersOrReferences& headers(const Encoding* msg);
};

const ::gnostic::openapi::v3::HeadersOrReferences&
Encoding::_Internal::headers(const Encoding* msg) {
  return *msg->_impl_.headers_;
}
Encoding::Encoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Encoding)
}
Encoding::Encoding(const Encoding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Encoding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.content_type_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.headers_){nullptr}
    , decltype(_impl_.explode_){}
    , decltype(_impl_.allow_reserved_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.content_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_content_type().empty()) {
    _this->_impl_.content_type_.Set(from._internal_content_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_style().empty()) {
    _this->_impl_.style_.Set(from._internal_style(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_headers()) {
    _this->_impl_.headers_ = new ::gnostic::openapi::v3::HeadersOrReferences(*from._impl_.headers_);
  }
  ::memcpy(&_impl_.explode_, &from._impl_.explode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allow_reserved_) -
    reinterpret_cast<char*>(&_impl_.explode_)) + sizeof(_impl_.allow_reserved_));
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Encoding)
}

inline void Encoding::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.content_type_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.headers_){nullptr}
    , decltype(_impl_.explode_){false}
    , decltype(_impl_.allow_reserved_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.content_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Encoding::~Encoding() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Encoding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Encoding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.content_type_.Destroy();
  _impl_.style_.Destroy();
  if (this != internal_default_instance()) delete _impl_.headers_;
}

void Encoding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Encoding::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Encoding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.content_type_.ClearToEmpty();
  _impl_.style_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.headers_ != nullptr) {
    delete _impl_.headers_;
  }
  _impl_.headers_ = nullptr;
  ::memset(&_impl_.explode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.allow_reserved_) -
      reinterpret_cast<char*>(&_impl_.explode_)) + sizeof(_impl_.allow_reserved_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Encoding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string content_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_content_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Encoding.content_type"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_style();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Encoding.style"));
        } else
          goto handle_unusual;
        continue;
      // bool explode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.explode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_reserved = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.allow_reserved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Encoding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Encoding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string content_type = 1;
  if (!this->_internal_content_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content_type().data(), static_cast<int>(this->_internal_content_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Encoding.content_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_content_type(), target);
  }

  // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
  if (this->_internal_has_headers()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::headers(this),
        _Internal::headers(this).GetCachedSize(), target, stream);
  }

  // string style = 3;
  if (!this->_internal_style().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_style().data(), static_cast<int>(this->_internal_style().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Encoding.style");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_style(), target);
  }

  // bool explode = 4;
  if (this->_internal_explode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_explode(), target);
  }

  // bool allow_reserved = 5;
  if (this->_internal_allow_reserved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_allow_reserved(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Encoding)
  return target;
}

size_t Encoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Encoding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string content_type = 1;
  if (!this->_internal_content_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_content_type());
  }

  // string style = 3;
  if (!this->_internal_style().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_style());
  }

  // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
  if (this->_internal_has_headers()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.headers_);
  }

  // bool explode = 4;
  if (this->_internal_explode() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_reserved = 5;
  if (this->_internal_allow_reserved() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Encoding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Encoding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Encoding::GetClassData() const { return &_class_data_; }


void Encoding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Encoding*>(&to_msg);
  auto& from = static_cast<const Encoding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Encoding)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_content_type().empty()) {
    _this->_internal_set_content_type(from._internal_content_type());
  }
  if (!from._internal_style().empty()) {
    _this->_internal_set_style(from._internal_style());
  }
  if (from._internal_has_headers()) {
    _this->_internal_mutable_headers()->::gnostic::openapi::v3::HeadersOrReferences::MergeFrom(
        from._internal_headers());
  }
  if (from._internal_explode() != 0) {
    _this->_internal_set_explode(from._internal_explode());
  }
  if (from._internal_allow_reserved() != 0) {
    _this->_internal_set_allow_reserved(from._internal_allow_reserved());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Encoding::CopyFrom(const Encoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Encoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Encoding::IsInitialized() const {
  return true;
}

void Encoding::InternalSwap(Encoding* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_type_, lhs_arena,
      &other->_impl_.content_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.style_, lhs_arena,
      &other->_impl_.style_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Encoding, _impl_.allow_reserved_)
      + sizeof(Encoding::_impl_.allow_reserved_)
      - PROTOBUF_FIELD_OFFSET(Encoding, _impl_.headers_)>(
          reinterpret_cast<char*>(&_impl_.headers_),
          reinterpret_cast<char*>(&other->_impl_.headers_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Encoding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[11]);
}

// ===================================================================

class Encodings::_Internal {
 public:
};

Encodings::Encodings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Encodings)
}
Encodings::Encodings(const Encodings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Encodings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Encodings)
}

inline void Encodings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Encodings::~Encodings() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Encodings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Encodings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void Encodings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Encodings::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Encodings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Encodings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedEncoding additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Encodings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Encodings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedEncoding additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Encodings)
  return target;
}

size_t Encodings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Encodings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedEncoding additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Encodings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Encodings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Encodings::GetClassData() const { return &_class_data_; }


void Encodings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Encodings*>(&to_msg);
  auto& from = static_cast<const Encodings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Encodings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Encodings::CopyFrom(const Encodings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Encodings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Encodings::IsInitialized() const {
  return true;
}

void Encodings::InternalSwap(Encodings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Encodings::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[12]);
}

// ===================================================================

class Example::_Internal {
 public:
  static const ::gnostic::openapi::v3::Any& value(const Example* msg);
};

const ::gnostic::openapi::v3::Any&
Example::_Internal::value(const Example* msg) {
  return *msg->_impl_.value_;
}
Example::Example(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Example)
}
Example::Example(const Example& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Example* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.external_value_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_summary().empty()) {
    _this->_impl_.summary_.Set(from._internal_summary(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.external_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_external_value().empty()) {
    _this->_impl_.external_value_.Set(from._internal_external_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::Any(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Example)
}

inline void Example::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.external_value_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.external_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Example::~Example() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Example)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Example::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.summary_.Destroy();
  _impl_.description_.Destroy();
  _impl_.external_value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void Example::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Example::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Example)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.summary_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.external_value_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Example::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string summary = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_summary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Example.summary"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Example.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Any value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string external_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_external_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Example.external_value"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Example::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Example)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string summary = 1;
  if (!this->_internal_summary().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_summary().data(), static_cast<int>(this->_internal_summary().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Example.summary");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_summary(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Example.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.Any value = 3;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  // string external_value = 4;
  if (!this->_internal_external_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_external_value().data(), static_cast<int>(this->_internal_external_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Example.external_value");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_external_value(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Example)
  return target;
}

size_t Example::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Example)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string summary = 1;
  if (!this->_internal_summary().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_summary());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string external_value = 4;
  if (!this->_internal_external_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_external_value());
  }

  // .gnostic.openapi.v3.Any value = 3;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Example::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Example::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Example::GetClassData() const { return &_class_data_; }


void Example::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Example*>(&to_msg);
  auto& from = static_cast<const Example&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Example)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_summary().empty()) {
    _this->_internal_set_summary(from._internal_summary());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_external_value().empty()) {
    _this->_internal_set_external_value(from._internal_external_value());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::Any::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Example::CopyFrom(const Example& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Example)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Example::IsInitialized() const {
  return true;
}

void Example::InternalSwap(Example* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.summary_, lhs_arena,
      &other->_impl_.summary_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.external_value_, lhs_arena,
      &other->_impl_.external_value_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Example::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[13]);
}

// ===================================================================

class ExampleOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::Example& example(const ExampleOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const ExampleOrReference* msg);
};

const ::gnostic::openapi::v3::Example&
ExampleOrReference::_Internal::example(const ExampleOrReference* msg) {
  return *msg->_impl_.oneof_.example_;
}
const ::gnostic::openapi::v3::Reference&
ExampleOrReference::_Internal::reference(const ExampleOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void ExampleOrReference::set_allocated_example(::gnostic::openapi::v3::Example* example) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (example) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(example);
    if (message_arena != submessage_arena) {
      example = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example, submessage_arena);
    }
    set_has_example();
    _impl_.oneof_.example_ = example;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ExampleOrReference.example)
}
void ExampleOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ExampleOrReference.reference)
}
ExampleOrReference::ExampleOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ExampleOrReference)
}
ExampleOrReference::ExampleOrReference(const ExampleOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExampleOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kExample: {
      _this->_internal_mutable_example()->::gnostic::openapi::v3::Example::MergeFrom(
          from._internal_example());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ExampleOrReference)
}

inline void ExampleOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

ExampleOrReference::~ExampleOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ExampleOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExampleOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void ExampleOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExampleOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.ExampleOrReference)
  switch (oneof_case()) {
    case kExample: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.example_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void ExampleOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ExampleOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExampleOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Example example = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_example(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExampleOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ExampleOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Example example = 1;
  if (_internal_has_example()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::example(this),
        _Internal::example(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ExampleOrReference)
  return target;
}

size_t ExampleOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ExampleOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Example example = 1;
    case kExample: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.example_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExampleOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExampleOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExampleOrReference::GetClassData() const { return &_class_data_; }


void ExampleOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExampleOrReference*>(&to_msg);
  auto& from = static_cast<const ExampleOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ExampleOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kExample: {
      _this->_internal_mutable_example()->::gnostic::openapi::v3::Example::MergeFrom(
          from._internal_example());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExampleOrReference::CopyFrom(const ExampleOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ExampleOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExampleOrReference::IsInitialized() const {
  return true;
}

void ExampleOrReference::InternalSwap(ExampleOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExampleOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[14]);
}

// ===================================================================

class ExamplesOrReferences::_Internal {
 public:
};

ExamplesOrReferences::ExamplesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ExamplesOrReferences)
}
ExamplesOrReferences::ExamplesOrReferences(const ExamplesOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExamplesOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ExamplesOrReferences)
}

inline void ExamplesOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExamplesOrReferences::~ExamplesOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ExamplesOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExamplesOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void ExamplesOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExamplesOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ExamplesOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExamplesOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExamplesOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ExamplesOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ExamplesOrReferences)
  return target;
}

size_t ExamplesOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ExamplesOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExamplesOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExamplesOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExamplesOrReferences::GetClassData() const { return &_class_data_; }


void ExamplesOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExamplesOrReferences*>(&to_msg);
  auto& from = static_cast<const ExamplesOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ExamplesOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExamplesOrReferences::CopyFrom(const ExamplesOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ExamplesOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExamplesOrReferences::IsInitialized() const {
  return true;
}

void ExamplesOrReferences::InternalSwap(ExamplesOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExamplesOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[15]);
}

// ===================================================================

class Expression::_Internal {
 public:
};

Expression::Expression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Expression)
}
Expression::Expression(const Expression& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Expression* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Expression)
}

inline void Expression::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Expression::~Expression() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Expression)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Expression::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void Expression::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Expression::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Expression)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Expression::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Expression::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Expression)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Expression)
  return target;
}

size_t Expression::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Expression)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Expression::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Expression::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Expression::GetClassData() const { return &_class_data_; }


void Expression::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Expression*>(&to_msg);
  auto& from = static_cast<const Expression&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Expression)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Expression::CopyFrom(const Expression& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Expression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Expression::IsInitialized() const {
  return true;
}

void Expression::InternalSwap(Expression* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Expression::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[16]);
}

// ===================================================================

class ExternalDocs::_Internal {
 public:
};

ExternalDocs::ExternalDocs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ExternalDocs)
}
ExternalDocs::ExternalDocs(const ExternalDocs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExternalDocs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.description_){}
    , decltype(_impl_.url_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ExternalDocs)
}

inline void ExternalDocs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.description_){}
    , decltype(_impl_.url_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExternalDocs::~ExternalDocs() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ExternalDocs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExternalDocs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.description_.Destroy();
  _impl_.url_.Destroy();
}

void ExternalDocs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExternalDocs::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ExternalDocs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.description_.ClearToEmpty();
  _impl_.url_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExternalDocs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.ExternalDocs.description"));
        } else
          goto handle_unusual;
        continue;
      // string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.ExternalDocs.url"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExternalDocs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ExternalDocs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.ExternalDocs.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.ExternalDocs.url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ExternalDocs)
  return target;
}

size_t ExternalDocs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ExternalDocs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string description = 1;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExternalDocs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExternalDocs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExternalDocs::GetClassData() const { return &_class_data_; }


void ExternalDocs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExternalDocs*>(&to_msg);
  auto& from = static_cast<const ExternalDocs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ExternalDocs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExternalDocs::CopyFrom(const ExternalDocs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ExternalDocs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalDocs::IsInitialized() const {
  return true;
}

void ExternalDocs::InternalSwap(ExternalDocs* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ExternalDocs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[17]);
}

// ===================================================================

class Header::_Internal {
 public:
  static const ::gnostic::openapi::v3::SchemaOrReference& schema(const Header* msg);
  static const ::gnostic::openapi::v3::Any& example(const Header* msg);
  static const ::gnostic::openapi::v3::ExamplesOrReferences& examples(const Header* msg);
  static const ::gnostic::openapi::v3::MediaTypes& content(const Header* msg);
};

const ::gnostic::openapi::v3::SchemaOrReference&
Header::_Internal::schema(const Header* msg) {
  return *msg->_impl_.schema_;
}
const ::gnostic::openapi::v3::Any&
Header::_Internal::example(const Header* msg) {
  return *msg->_impl_.example_;
}
const ::gnostic::openapi::v3::ExamplesOrReferences&
Header::_Internal::examples(const Header* msg) {
  return *msg->_impl_.examples_;
}
const ::gnostic::openapi::v3::MediaTypes&
Header::_Internal::content(const Header* msg) {
  return *msg->_impl_.content_;
}
Header::Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Header)
}
Header::Header(const Header& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Header* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.description_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.schema_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.required_){}
    , decltype(_impl_.deprecated_){}
    , decltype(_impl_.allow_empty_value_){}
    , decltype(_impl_.explode_){}
    , decltype(_impl_.allow_reserved_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_style().empty()) {
    _this->_impl_.style_.Set(from._internal_style(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_schema()) {
    _this->_impl_.schema_ = new ::gnostic::openapi::v3::SchemaOrReference(*from._impl_.schema_);
  }
  if (from._internal_has_example()) {
    _this->_impl_.example_ = new ::gnostic::openapi::v3::Any(*from._impl_.example_);
  }
  if (from._internal_has_examples()) {
    _this->_impl_.examples_ = new ::gnostic::openapi::v3::ExamplesOrReferences(*from._impl_.examples_);
  }
  if (from._internal_has_content()) {
    _this->_impl_.content_ = new ::gnostic::openapi::v3::MediaTypes(*from._impl_.content_);
  }
  ::memcpy(&_impl_.required_, &from._impl_.required_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allow_reserved_) -
    reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.allow_reserved_));
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Header)
}

inline void Header::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.description_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.schema_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.required_){false}
    , decltype(_impl_.deprecated_){false}
    , decltype(_impl_.allow_empty_value_){false}
    , decltype(_impl_.explode_){false}
    , decltype(_impl_.allow_reserved_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Header)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Header::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.description_.Destroy();
  _impl_.style_.Destroy();
  if (this != internal_default_instance()) delete _impl_.schema_;
  if (this != internal_default_instance()) delete _impl_.example_;
  if (this != internal_default_instance()) delete _impl_.examples_;
  if (this != internal_default_instance()) delete _impl_.content_;
}

void Header::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Header)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.description_.ClearToEmpty();
  _impl_.style_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
  ::memset(&_impl_.required_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.allow_reserved_) -
      reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.allow_reserved_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Header::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Header.description"));
        } else
          goto handle_unusual;
        continue;
      // bool required = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool deprecated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_empty_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.allow_empty_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_style();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Header.style"));
        } else
          goto handle_unusual;
        continue;
      // bool explode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.explode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_reserved = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.allow_reserved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.SchemaOrReference schema = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Any example = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_example(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExamplesOrReferences examples = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_examples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.MediaTypes content = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Header::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Header)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Header.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // bool required = 2;
  if (this->_internal_required() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_required(), target);
  }

  // bool deprecated = 3;
  if (this->_internal_deprecated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_deprecated(), target);
  }

  // bool allow_empty_value = 4;
  if (this->_internal_allow_empty_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_allow_empty_value(), target);
  }

  // string style = 5;
  if (!this->_internal_style().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_style().data(), static_cast<int>(this->_internal_style().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Header.style");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_style(), target);
  }

  // bool explode = 6;
  if (this->_internal_explode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_explode(), target);
  }

  // bool allow_reserved = 7;
  if (this->_internal_allow_reserved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_allow_reserved(), target);
  }

  // .gnostic.openapi.v3.SchemaOrReference schema = 8;
  if (this->_internal_has_schema()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Any example = 9;
  if (this->_internal_has_example()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::example(this),
        _Internal::example(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 10;
  if (this->_internal_has_examples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::examples(this),
        _Internal::examples(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.MediaTypes content = 11;
  if (this->_internal_has_content()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::content(this),
        _Internal::content(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Header)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 12;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string description = 1;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string style = 5;
  if (!this->_internal_style().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_style());
  }

  // .gnostic.openapi.v3.SchemaOrReference schema = 8;
  if (this->_internal_has_schema()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.schema_);
  }

  // .gnostic.openapi.v3.Any example = 9;
  if (this->_internal_has_example()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.example_);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 10;
  if (this->_internal_has_examples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.examples_);
  }

  // .gnostic.openapi.v3.MediaTypes content = 11;
  if (this->_internal_has_content()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.content_);
  }

  // bool required = 2;
  if (this->_internal_required() != 0) {
    total_size += 1 + 1;
  }

  // bool deprecated = 3;
  if (this->_internal_deprecated() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_empty_value = 4;
  if (this->_internal_allow_empty_value() != 0) {
    total_size += 1 + 1;
  }

  // bool explode = 6;
  if (this->_internal_explode() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_reserved = 7;
  if (this->_internal_allow_reserved() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Header::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Header::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Header::GetClassData() const { return &_class_data_; }


void Header::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Header*>(&to_msg);
  auto& from = static_cast<const Header&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Header)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_style().empty()) {
    _this->_internal_set_style(from._internal_style());
  }
  if (from._internal_has_schema()) {
    _this->_internal_mutable_schema()->::gnostic::openapi::v3::SchemaOrReference::MergeFrom(
        from._internal_schema());
  }
  if (from._internal_has_example()) {
    _this->_internal_mutable_example()->::gnostic::openapi::v3::Any::MergeFrom(
        from._internal_example());
  }
  if (from._internal_has_examples()) {
    _this->_internal_mutable_examples()->::gnostic::openapi::v3::ExamplesOrReferences::MergeFrom(
        from._internal_examples());
  }
  if (from._internal_has_content()) {
    _this->_internal_mutable_content()->::gnostic::openapi::v3::MediaTypes::MergeFrom(
        from._internal_content());
  }
  if (from._internal_required() != 0) {
    _this->_internal_set_required(from._internal_required());
  }
  if (from._internal_deprecated() != 0) {
    _this->_internal_set_deprecated(from._internal_deprecated());
  }
  if (from._internal_allow_empty_value() != 0) {
    _this->_internal_set_allow_empty_value(from._internal_allow_empty_value());
  }
  if (from._internal_explode() != 0) {
    _this->_internal_set_explode(from._internal_explode());
  }
  if (from._internal_allow_reserved() != 0) {
    _this->_internal_set_allow_reserved(from._internal_allow_reserved());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::InternalSwap(Header* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.style_, lhs_arena,
      &other->_impl_.style_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Header, _impl_.allow_reserved_)
      + sizeof(Header::_impl_.allow_reserved_)
      - PROTOBUF_FIELD_OFFSET(Header, _impl_.schema_)>(
          reinterpret_cast<char*>(&_impl_.schema_),
          reinterpret_cast<char*>(&other->_impl_.schema_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Header::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[18]);
}

// ===================================================================

class HeaderOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::Header& header(const HeaderOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const HeaderOrReference* msg);
};

const ::gnostic::openapi::v3::Header&
HeaderOrReference::_Internal::header(const HeaderOrReference* msg) {
  return *msg->_impl_.oneof_.header_;
}
const ::gnostic::openapi::v3::Reference&
HeaderOrReference::_Internal::reference(const HeaderOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void HeaderOrReference::set_allocated_header(::gnostic::openapi::v3::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
    _impl_.oneof_.header_ = header;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.HeaderOrReference.header)
}
void HeaderOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.HeaderOrReference.reference)
}
HeaderOrReference::HeaderOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.HeaderOrReference)
}
HeaderOrReference::HeaderOrReference(const HeaderOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeaderOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kHeader: {
      _this->_internal_mutable_header()->::gnostic::openapi::v3::Header::MergeFrom(
          from._internal_header());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.HeaderOrReference)
}

inline void HeaderOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

HeaderOrReference::~HeaderOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.HeaderOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeaderOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void HeaderOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeaderOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.HeaderOrReference)
  switch (oneof_case()) {
    case kHeader: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.header_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void HeaderOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.HeaderOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeaderOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeaderOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.HeaderOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Header header = 1;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.HeaderOrReference)
  return target;
}

size_t HeaderOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.HeaderOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Header header = 1;
    case kHeader: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.header_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeaderOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeaderOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeaderOrReference::GetClassData() const { return &_class_data_; }


void HeaderOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeaderOrReference*>(&to_msg);
  auto& from = static_cast<const HeaderOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.HeaderOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kHeader: {
      _this->_internal_mutable_header()->::gnostic::openapi::v3::Header::MergeFrom(
          from._internal_header());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeaderOrReference::CopyFrom(const HeaderOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.HeaderOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeaderOrReference::IsInitialized() const {
  return true;
}

void HeaderOrReference::InternalSwap(HeaderOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata HeaderOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[19]);
}

// ===================================================================

class HeadersOrReferences::_Internal {
 public:
};

HeadersOrReferences::HeadersOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.HeadersOrReferences)
}
HeadersOrReferences::HeadersOrReferences(const HeadersOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeadersOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.HeadersOrReferences)
}

inline void HeadersOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HeadersOrReferences::~HeadersOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.HeadersOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeadersOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void HeadersOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeadersOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.HeadersOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeadersOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeadersOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.HeadersOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.HeadersOrReferences)
  return target;
}

size_t HeadersOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.HeadersOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeadersOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeadersOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeadersOrReferences::GetClassData() const { return &_class_data_; }


void HeadersOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeadersOrReferences*>(&to_msg);
  auto& from = static_cast<const HeadersOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.HeadersOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeadersOrReferences::CopyFrom(const HeadersOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.HeadersOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeadersOrReferences::IsInitialized() const {
  return true;
}

void HeadersOrReferences::InternalSwap(HeadersOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HeadersOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[20]);
}

// ===================================================================

class Info::_Internal {
 public:
  static const ::gnostic::openapi::v3::Contact& contact(const Info* msg);
  static const ::gnostic::openapi::v3::License& license(const Info* msg);
};

const ::gnostic::openapi::v3::Contact&
Info::_Internal::contact(const Info* msg) {
  return *msg->_impl_.contact_;
}
const ::gnostic::openapi::v3::License&
Info::_Internal::license(const Info* msg) {
  return *msg->_impl_.license_;
}
Info::Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Info)
}
Info::Info(const Info& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Info* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.title_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.terms_of_service_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.contact_){nullptr}
    , decltype(_impl_.license_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.terms_of_service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terms_of_service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_terms_of_service().empty()) {
    _this->_impl_.terms_of_service_.Set(from._internal_terms_of_service(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_summary().empty()) {
    _this->_impl_.summary_.Set(from._internal_summary(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_contact()) {
    _this->_impl_.contact_ = new ::gnostic::openapi::v3::Contact(*from._impl_.contact_);
  }
  if (from._internal_has_license()) {
    _this->_impl_.license_ = new ::gnostic::openapi::v3::License(*from._impl_.license_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Info)
}

inline void Info::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.title_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.terms_of_service_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.contact_){nullptr}
    , decltype(_impl_.license_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.terms_of_service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terms_of_service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Info::~Info() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Info)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.description_.Destroy();
  _impl_.terms_of_service_.Destroy();
  _impl_.version_.Destroy();
  _impl_.summary_.Destroy();
  if (this != internal_default_instance()) delete _impl_.contact_;
  if (this != internal_default_instance()) delete _impl_.license_;
}

void Info::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Info::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Info)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.terms_of_service_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  _impl_.summary_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.contact_ != nullptr) {
    delete _impl_.contact_;
  }
  _impl_.contact_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.license_ != nullptr) {
    delete _impl_.license_;
  }
  _impl_.license_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Info::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Info.title"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Info.description"));
        } else
          goto handle_unusual;
        continue;
      // string terms_of_service = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_terms_of_service();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Info.terms_of_service"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Contact contact = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_contact(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.License license = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_license(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Info.version"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string summary = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_summary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Info.summary"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Info::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Info)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string title = 1;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Info.title");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Info.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // string terms_of_service = 3;
  if (!this->_internal_terms_of_service().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_terms_of_service().data(), static_cast<int>(this->_internal_terms_of_service().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Info.terms_of_service");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_terms_of_service(), target);
  }

  // .gnostic.openapi.v3.Contact contact = 4;
  if (this->_internal_has_contact()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::contact(this),
        _Internal::contact(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.License license = 5;
  if (this->_internal_has_license()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::license(this),
        _Internal::license(this).GetCachedSize(), target, stream);
  }

  // string version = 6;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Info.version");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_version(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string summary = 8;
  if (!this->_internal_summary().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_summary().data(), static_cast<int>(this->_internal_summary().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Info.summary");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_summary(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Info)
  return target;
}

size_t Info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Info)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string title = 1;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string terms_of_service = 3;
  if (!this->_internal_terms_of_service().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_terms_of_service());
  }

  // string version = 6;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // string summary = 8;
  if (!this->_internal_summary().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_summary());
  }

  // .gnostic.openapi.v3.Contact contact = 4;
  if (this->_internal_has_contact()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.contact_);
  }

  // .gnostic.openapi.v3.License license = 5;
  if (this->_internal_has_license()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.license_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Info::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Info::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Info::GetClassData() const { return &_class_data_; }


void Info::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Info*>(&to_msg);
  auto& from = static_cast<const Info&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Info)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_terms_of_service().empty()) {
    _this->_internal_set_terms_of_service(from._internal_terms_of_service());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_summary().empty()) {
    _this->_internal_set_summary(from._internal_summary());
  }
  if (from._internal_has_contact()) {
    _this->_internal_mutable_contact()->::gnostic::openapi::v3::Contact::MergeFrom(
        from._internal_contact());
  }
  if (from._internal_has_license()) {
    _this->_internal_mutable_license()->::gnostic::openapi::v3::License::MergeFrom(
        from._internal_license());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Info::CopyFrom(const Info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Info::IsInitialized() const {
  return true;
}

void Info::InternalSwap(Info* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.terms_of_service_, lhs_arena,
      &other->_impl_.terms_of_service_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.summary_, lhs_arena,
      &other->_impl_.summary_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Info, _impl_.license_)
      + sizeof(Info::_impl_.license_)
      - PROTOBUF_FIELD_OFFSET(Info, _impl_.contact_)>(
          reinterpret_cast<char*>(&_impl_.contact_),
          reinterpret_cast<char*>(&other->_impl_.contact_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Info::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[21]);
}

// ===================================================================

class ItemsItem::_Internal {
 public:
};

ItemsItem::ItemsItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ItemsItem)
}
ItemsItem::ItemsItem(const ItemsItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ItemsItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.schema_or_reference_){from._impl_.schema_or_reference_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ItemsItem)
}

inline void ItemsItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.schema_or_reference_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ItemsItem::~ItemsItem() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ItemsItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ItemsItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.schema_or_reference_.~RepeatedPtrField();
}

void ItemsItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ItemsItem::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ItemsItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.schema_or_reference_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ItemsItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_schema_or_reference(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ItemsItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ItemsItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_schema_or_reference_size()); i < n; i++) {
    const auto& repfield = this->_internal_schema_or_reference(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ItemsItem)
  return target;
}

size_t ItemsItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ItemsItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
  total_size += 1UL * this->_internal_schema_or_reference_size();
  for (const auto& msg : this->_impl_.schema_or_reference_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ItemsItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ItemsItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ItemsItem::GetClassData() const { return &_class_data_; }


void ItemsItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ItemsItem*>(&to_msg);
  auto& from = static_cast<const ItemsItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ItemsItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.schema_or_reference_.MergeFrom(from._impl_.schema_or_reference_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ItemsItem::CopyFrom(const ItemsItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ItemsItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemsItem::IsInitialized() const {
  return true;
}

void ItemsItem::InternalSwap(ItemsItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.schema_or_reference_.InternalSwap(&other->_impl_.schema_or_reference_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ItemsItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[22]);
}

// ===================================================================

class License::_Internal {
 public:
};

License::License(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.License)
}
License::License(const License& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  License* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.License)
}

inline void License::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

License::~License() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.License)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void License::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.url_.Destroy();
}

void License::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void License::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.License)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.url_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* License::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.License.name"));
        } else
          goto handle_unusual;
        continue;
      // string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.License.url"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* License::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.License)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.License.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.License.url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.License)
  return target;
}

size_t License::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.License)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData License::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    License::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*License::GetClassData() const { return &_class_data_; }


void License::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<License*>(&to_msg);
  auto& from = static_cast<const License&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.License)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void License::CopyFrom(const License& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.License)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool License::IsInitialized() const {
  return true;
}

void License::InternalSwap(License* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata License::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[23]);
}

// ===================================================================

class Link::_Internal {
 public:
  static const ::gnostic::openapi::v3::AnyOrExpression& parameters(const Link* msg);
  static const ::gnostic::openapi::v3::AnyOrExpression& request_body(const Link* msg);
  static const ::gnostic::openapi::v3::Server& server(const Link* msg);
};

const ::gnostic::openapi::v3::AnyOrExpression&
Link::_Internal::parameters(const Link* msg) {
  return *msg->_impl_.parameters_;
}
const ::gnostic::openapi::v3::AnyOrExpression&
Link::_Internal::request_body(const Link* msg) {
  return *msg->_impl_.request_body_;
}
const ::gnostic::openapi::v3::Server&
Link::_Internal::server(const Link* msg) {
  return *msg->_impl_.server_;
}
Link::Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Link)
}
Link::Link(const Link& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Link* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.operation_ref_){}
    , decltype(_impl_.operation_id_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.parameters_){nullptr}
    , decltype(_impl_.request_body_){nullptr}
    , decltype(_impl_.server_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operation_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_ref().empty()) {
    _this->_impl_.operation_ref_.Set(from._internal_operation_ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.operation_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operation_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_id().empty()) {
    _this->_impl_.operation_id_.Set(from._internal_operation_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_parameters()) {
    _this->_impl_.parameters_ = new ::gnostic::openapi::v3::AnyOrExpression(*from._impl_.parameters_);
  }
  if (from._internal_has_request_body()) {
    _this->_impl_.request_body_ = new ::gnostic::openapi::v3::AnyOrExpression(*from._impl_.request_body_);
  }
  if (from._internal_has_server()) {
    _this->_impl_.server_ = new ::gnostic::openapi::v3::Server(*from._impl_.server_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Link)
}

inline void Link::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.operation_ref_){}
    , decltype(_impl_.operation_id_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.parameters_){nullptr}
    , decltype(_impl_.request_body_){nullptr}
    , decltype(_impl_.server_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.operation_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operation_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.operation_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operation_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Link::~Link() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Link)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Link::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.operation_ref_.Destroy();
  _impl_.operation_id_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.parameters_;
  if (this != internal_default_instance()) delete _impl_.request_body_;
  if (this != internal_default_instance()) delete _impl_.server_;
}

void Link::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Link::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Link)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.operation_ref_.ClearToEmpty();
  _impl_.operation_id_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.parameters_ != nullptr) {
    delete _impl_.parameters_;
  }
  _impl_.parameters_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.request_body_ != nullptr) {
    delete _impl_.request_body_;
  }
  _impl_.request_body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.server_ != nullptr) {
    delete _impl_.server_;
  }
  _impl_.server_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Link::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string operation_ref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_operation_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Link.operation_ref"));
        } else
          goto handle_unusual;
        continue;
      // string operation_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Link.operation_id"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.AnyOrExpression parameters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.AnyOrExpression request_body = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Link.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Server server = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_server(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Link::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Link)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string operation_ref = 1;
  if (!this->_internal_operation_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_operation_ref().data(), static_cast<int>(this->_internal_operation_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Link.operation_ref");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_operation_ref(), target);
  }

  // string operation_id = 2;
  if (!this->_internal_operation_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_operation_id().data(), static_cast<int>(this->_internal_operation_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Link.operation_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_operation_id(), target);
  }

  // .gnostic.openapi.v3.AnyOrExpression parameters = 3;
  if (this->_internal_has_parameters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parameters(this),
        _Internal::parameters(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.AnyOrExpression request_body = 4;
  if (this->_internal_has_request_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::request_body(this),
        _Internal::request_body(this).GetCachedSize(), target, stream);
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Link.description");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.Server server = 6;
  if (this->_internal_has_server()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::server(this),
        _Internal::server(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Link)
  return target;
}

size_t Link::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Link)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string operation_ref = 1;
  if (!this->_internal_operation_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_operation_ref());
  }

  // string operation_id = 2;
  if (!this->_internal_operation_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_operation_id());
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .gnostic.openapi.v3.AnyOrExpression parameters = 3;
  if (this->_internal_has_parameters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parameters_);
  }

  // .gnostic.openapi.v3.AnyOrExpression request_body = 4;
  if (this->_internal_has_request_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.request_body_);
  }

  // .gnostic.openapi.v3.Server server = 6;
  if (this->_internal_has_server()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.server_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Link::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Link::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Link::GetClassData() const { return &_class_data_; }


void Link::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Link*>(&to_msg);
  auto& from = static_cast<const Link&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Link)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_operation_ref().empty()) {
    _this->_internal_set_operation_ref(from._internal_operation_ref());
  }
  if (!from._internal_operation_id().empty()) {
    _this->_internal_set_operation_id(from._internal_operation_id());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_parameters()) {
    _this->_internal_mutable_parameters()->::gnostic::openapi::v3::AnyOrExpression::MergeFrom(
        from._internal_parameters());
  }
  if (from._internal_has_request_body()) {
    _this->_internal_mutable_request_body()->::gnostic::openapi::v3::AnyOrExpression::MergeFrom(
        from._internal_request_body());
  }
  if (from._internal_has_server()) {
    _this->_internal_mutable_server()->::gnostic::openapi::v3::Server::MergeFrom(
        from._internal_server());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Link::CopyFrom(const Link& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Link)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Link::IsInitialized() const {
  return true;
}

void Link::InternalSwap(Link* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.operation_ref_, lhs_arena,
      &other->_impl_.operation_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.operation_id_, lhs_arena,
      &other->_impl_.operation_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Link, _impl_.server_)
      + sizeof(Link::_impl_.server_)
      - PROTOBUF_FIELD_OFFSET(Link, _impl_.parameters_)>(
          reinterpret_cast<char*>(&_impl_.parameters_),
          reinterpret_cast<char*>(&other->_impl_.parameters_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Link::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[24]);
}

// ===================================================================

class LinkOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::Link& link(const LinkOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const LinkOrReference* msg);
};

const ::gnostic::openapi::v3::Link&
LinkOrReference::_Internal::link(const LinkOrReference* msg) {
  return *msg->_impl_.oneof_.link_;
}
const ::gnostic::openapi::v3::Reference&
LinkOrReference::_Internal::reference(const LinkOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void LinkOrReference::set_allocated_link(::gnostic::openapi::v3::Link* link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(link);
    if (message_arena != submessage_arena) {
      link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    set_has_link();
    _impl_.oneof_.link_ = link;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.LinkOrReference.link)
}
void LinkOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.LinkOrReference.reference)
}
LinkOrReference::LinkOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.LinkOrReference)
}
LinkOrReference::LinkOrReference(const LinkOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinkOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kLink: {
      _this->_internal_mutable_link()->::gnostic::openapi::v3::Link::MergeFrom(
          from._internal_link());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.LinkOrReference)
}

inline void LinkOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

LinkOrReference::~LinkOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.LinkOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinkOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void LinkOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinkOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.LinkOrReference)
  switch (oneof_case()) {
    case kLink: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.link_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void LinkOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.LinkOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinkOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Link link = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_link(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinkOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.LinkOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Link link = 1;
  if (_internal_has_link()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::link(this),
        _Internal::link(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.LinkOrReference)
  return target;
}

size_t LinkOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.LinkOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Link link = 1;
    case kLink: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.link_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinkOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinkOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinkOrReference::GetClassData() const { return &_class_data_; }


void LinkOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinkOrReference*>(&to_msg);
  auto& from = static_cast<const LinkOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.LinkOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kLink: {
      _this->_internal_mutable_link()->::gnostic::openapi::v3::Link::MergeFrom(
          from._internal_link());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinkOrReference::CopyFrom(const LinkOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.LinkOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinkOrReference::IsInitialized() const {
  return true;
}

void LinkOrReference::InternalSwap(LinkOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LinkOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[25]);
}

// ===================================================================

class LinksOrReferences::_Internal {
 public:
};

LinksOrReferences::LinksOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.LinksOrReferences)
}
LinksOrReferences::LinksOrReferences(const LinksOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinksOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.LinksOrReferences)
}

inline void LinksOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LinksOrReferences::~LinksOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.LinksOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinksOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void LinksOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinksOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.LinksOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinksOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinksOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.LinksOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.LinksOrReferences)
  return target;
}

size_t LinksOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.LinksOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinksOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinksOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinksOrReferences::GetClassData() const { return &_class_data_; }


void LinksOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinksOrReferences*>(&to_msg);
  auto& from = static_cast<const LinksOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.LinksOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinksOrReferences::CopyFrom(const LinksOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.LinksOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinksOrReferences::IsInitialized() const {
  return true;
}

void LinksOrReferences::InternalSwap(LinksOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LinksOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[26]);
}

// ===================================================================

class MediaType::_Internal {
 public:
  static const ::gnostic::openapi::v3::SchemaOrReference& schema(const MediaType* msg);
  static const ::gnostic::openapi::v3::Any& example(const MediaType* msg);
  static const ::gnostic::openapi::v3::ExamplesOrReferences& examples(const MediaType* msg);
  static const ::gnostic::openapi::v3::Encodings& encoding(const MediaType* msg);
};

const ::gnostic::openapi::v3::SchemaOrReference&
MediaType::_Internal::schema(const MediaType* msg) {
  return *msg->_impl_.schema_;
}
const ::gnostic::openapi::v3::Any&
MediaType::_Internal::example(const MediaType* msg) {
  return *msg->_impl_.example_;
}
const ::gnostic::openapi::v3::ExamplesOrReferences&
MediaType::_Internal::examples(const MediaType* msg) {
  return *msg->_impl_.examples_;
}
const ::gnostic::openapi::v3::Encodings&
MediaType::_Internal::encoding(const MediaType* msg) {
  return *msg->_impl_.encoding_;
}
MediaType::MediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.MediaType)
}
MediaType::MediaType(const MediaType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.schema_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.encoding_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_schema()) {
    _this->_impl_.schema_ = new ::gnostic::openapi::v3::SchemaOrReference(*from._impl_.schema_);
  }
  if (from._internal_has_example()) {
    _this->_impl_.example_ = new ::gnostic::openapi::v3::Any(*from._impl_.example_);
  }
  if (from._internal_has_examples()) {
    _this->_impl_.examples_ = new ::gnostic::openapi::v3::ExamplesOrReferences(*from._impl_.examples_);
  }
  if (from._internal_has_encoding()) {
    _this->_impl_.encoding_ = new ::gnostic::openapi::v3::Encodings(*from._impl_.encoding_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.MediaType)
}

inline void MediaType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.schema_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.encoding_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MediaType::~MediaType() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.MediaType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.schema_;
  if (this != internal_default_instance()) delete _impl_.example_;
  if (this != internal_default_instance()) delete _impl_.examples_;
  if (this != internal_default_instance()) delete _impl_.encoding_;
}

void MediaType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaType::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.MediaType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.encoding_ != nullptr) {
    delete _impl_.encoding_;
  }
  _impl_.encoding_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.SchemaOrReference schema = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Any example = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_example(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExamplesOrReferences examples = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_examples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Encodings encoding = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_encoding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.MediaType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.SchemaOrReference schema = 1;
  if (this->_internal_has_schema()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Any example = 2;
  if (this->_internal_has_example()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::example(this),
        _Internal::example(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 3;
  if (this->_internal_has_examples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::examples(this),
        _Internal::examples(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Encodings encoding = 4;
  if (this->_internal_has_encoding()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::encoding(this),
        _Internal::encoding(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.MediaType)
  return target;
}

size_t MediaType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.MediaType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .gnostic.openapi.v3.SchemaOrReference schema = 1;
  if (this->_internal_has_schema()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.schema_);
  }

  // .gnostic.openapi.v3.Any example = 2;
  if (this->_internal_has_example()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.example_);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 3;
  if (this->_internal_has_examples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.examples_);
  }

  // .gnostic.openapi.v3.Encodings encoding = 4;
  if (this->_internal_has_encoding()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.encoding_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaType::GetClassData() const { return &_class_data_; }


void MediaType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaType*>(&to_msg);
  auto& from = static_cast<const MediaType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.MediaType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (from._internal_has_schema()) {
    _this->_internal_mutable_schema()->::gnostic::openapi::v3::SchemaOrReference::MergeFrom(
        from._internal_schema());
  }
  if (from._internal_has_example()) {
    _this->_internal_mutable_example()->::gnostic::openapi::v3::Any::MergeFrom(
        from._internal_example());
  }
  if (from._internal_has_examples()) {
    _this->_internal_mutable_examples()->::gnostic::openapi::v3::ExamplesOrReferences::MergeFrom(
        from._internal_examples());
  }
  if (from._internal_has_encoding()) {
    _this->_internal_mutable_encoding()->::gnostic::openapi::v3::Encodings::MergeFrom(
        from._internal_encoding());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaType::CopyFrom(const MediaType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.MediaType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaType::IsInitialized() const {
  return true;
}

void MediaType::InternalSwap(MediaType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaType, _impl_.encoding_)
      + sizeof(MediaType::_impl_.encoding_)
      - PROTOBUF_FIELD_OFFSET(MediaType, _impl_.schema_)>(
          reinterpret_cast<char*>(&_impl_.schema_),
          reinterpret_cast<char*>(&other->_impl_.schema_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[27]);
}

// ===================================================================

class MediaTypes::_Internal {
 public:
};

MediaTypes::MediaTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.MediaTypes)
}
MediaTypes::MediaTypes(const MediaTypes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaTypes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.MediaTypes)
}

inline void MediaTypes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MediaTypes::~MediaTypes() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.MediaTypes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaTypes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void MediaTypes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaTypes::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.MediaTypes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaTypes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedMediaType additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaTypes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.MediaTypes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedMediaType additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.MediaTypes)
  return target;
}

size_t MediaTypes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.MediaTypes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedMediaType additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaTypes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaTypes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaTypes::GetClassData() const { return &_class_data_; }


void MediaTypes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaTypes*>(&to_msg);
  auto& from = static_cast<const MediaTypes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.MediaTypes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaTypes::CopyFrom(const MediaTypes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.MediaTypes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaTypes::IsInitialized() const {
  return true;
}

void MediaTypes::InternalSwap(MediaTypes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaTypes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[28]);
}

// ===================================================================

class NamedAny::_Internal {
 public:
  static const ::gnostic::openapi::v3::Any& value(const NamedAny* msg);
};

const ::gnostic::openapi::v3::Any&
NamedAny::_Internal::value(const NamedAny* msg) {
  return *msg->_impl_.value_;
}
NamedAny::NamedAny(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedAny)
}
NamedAny::NamedAny(const NamedAny& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedAny* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::Any(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedAny)
}

inline void NamedAny::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedAny::~NamedAny() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedAny)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedAny::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedAny::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedAny::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedAny)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedAny::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedAny.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Any value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedAny::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedAny)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedAny.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.Any value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedAny)
  return target;
}

size_t NamedAny::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedAny)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.Any value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedAny::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedAny::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedAny::GetClassData() const { return &_class_data_; }


void NamedAny::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedAny*>(&to_msg);
  auto& from = static_cast<const NamedAny&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedAny)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::Any::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedAny::CopyFrom(const NamedAny& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedAny)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedAny::IsInitialized() const {
  return true;
}

void NamedAny::InternalSwap(NamedAny* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedAny::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[29]);
}

// ===================================================================

class NamedCallbackOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::CallbackOrReference& value(const NamedCallbackOrReference* msg);
};

const ::gnostic::openapi::v3::CallbackOrReference&
NamedCallbackOrReference::_Internal::value(const NamedCallbackOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedCallbackOrReference::NamedCallbackOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedCallbackOrReference)
}
NamedCallbackOrReference::NamedCallbackOrReference(const NamedCallbackOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedCallbackOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::CallbackOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedCallbackOrReference)
}

inline void NamedCallbackOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedCallbackOrReference::~NamedCallbackOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedCallbackOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedCallbackOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedCallbackOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedCallbackOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedCallbackOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedCallbackOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedCallbackOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.CallbackOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedCallbackOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedCallbackOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedCallbackOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.CallbackOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedCallbackOrReference)
  return target;
}

size_t NamedCallbackOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedCallbackOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.CallbackOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedCallbackOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedCallbackOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedCallbackOrReference::GetClassData() const { return &_class_data_; }


void NamedCallbackOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedCallbackOrReference*>(&to_msg);
  auto& from = static_cast<const NamedCallbackOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedCallbackOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::CallbackOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedCallbackOrReference::CopyFrom(const NamedCallbackOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedCallbackOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedCallbackOrReference::IsInitialized() const {
  return true;
}

void NamedCallbackOrReference::InternalSwap(NamedCallbackOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedCallbackOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[30]);
}

// ===================================================================

class NamedEncoding::_Internal {
 public:
  static const ::gnostic::openapi::v3::Encoding& value(const NamedEncoding* msg);
};

const ::gnostic::openapi::v3::Encoding&
NamedEncoding::_Internal::value(const NamedEncoding* msg) {
  return *msg->_impl_.value_;
}
NamedEncoding::NamedEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedEncoding)
}
NamedEncoding::NamedEncoding(const NamedEncoding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedEncoding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::Encoding(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedEncoding)
}

inline void NamedEncoding::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedEncoding::~NamedEncoding() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedEncoding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedEncoding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedEncoding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedEncoding::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedEncoding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedEncoding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedEncoding.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Encoding value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedEncoding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedEncoding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedEncoding.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.Encoding value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedEncoding)
  return target;
}

size_t NamedEncoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedEncoding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.Encoding value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedEncoding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedEncoding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedEncoding::GetClassData() const { return &_class_data_; }


void NamedEncoding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedEncoding*>(&to_msg);
  auto& from = static_cast<const NamedEncoding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedEncoding)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::Encoding::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedEncoding::CopyFrom(const NamedEncoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedEncoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedEncoding::IsInitialized() const {
  return true;
}

void NamedEncoding::InternalSwap(NamedEncoding* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedEncoding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[31]);
}

// ===================================================================

class NamedExampleOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::ExampleOrReference& value(const NamedExampleOrReference* msg);
};

const ::gnostic::openapi::v3::ExampleOrReference&
NamedExampleOrReference::_Internal::value(const NamedExampleOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedExampleOrReference::NamedExampleOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedExampleOrReference)
}
NamedExampleOrReference::NamedExampleOrReference(const NamedExampleOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedExampleOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::ExampleOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedExampleOrReference)
}

inline void NamedExampleOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedExampleOrReference::~NamedExampleOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedExampleOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedExampleOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedExampleOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedExampleOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedExampleOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedExampleOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedExampleOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExampleOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedExampleOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedExampleOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedExampleOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.ExampleOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedExampleOrReference)
  return target;
}

size_t NamedExampleOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedExampleOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.ExampleOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedExampleOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedExampleOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedExampleOrReference::GetClassData() const { return &_class_data_; }


void NamedExampleOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedExampleOrReference*>(&to_msg);
  auto& from = static_cast<const NamedExampleOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedExampleOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::ExampleOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedExampleOrReference::CopyFrom(const NamedExampleOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedExampleOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedExampleOrReference::IsInitialized() const {
  return true;
}

void NamedExampleOrReference::InternalSwap(NamedExampleOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedExampleOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[32]);
}

// ===================================================================

class NamedHeaderOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::HeaderOrReference& value(const NamedHeaderOrReference* msg);
};

const ::gnostic::openapi::v3::HeaderOrReference&
NamedHeaderOrReference::_Internal::value(const NamedHeaderOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedHeaderOrReference::NamedHeaderOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedHeaderOrReference)
}
NamedHeaderOrReference::NamedHeaderOrReference(const NamedHeaderOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedHeaderOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::HeaderOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedHeaderOrReference)
}

inline void NamedHeaderOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedHeaderOrReference::~NamedHeaderOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedHeaderOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedHeaderOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedHeaderOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedHeaderOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedHeaderOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedHeaderOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedHeaderOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.HeaderOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedHeaderOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedHeaderOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedHeaderOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.HeaderOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedHeaderOrReference)
  return target;
}

size_t NamedHeaderOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedHeaderOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.HeaderOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedHeaderOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedHeaderOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedHeaderOrReference::GetClassData() const { return &_class_data_; }


void NamedHeaderOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedHeaderOrReference*>(&to_msg);
  auto& from = static_cast<const NamedHeaderOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedHeaderOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::HeaderOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedHeaderOrReference::CopyFrom(const NamedHeaderOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedHeaderOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedHeaderOrReference::IsInitialized() const {
  return true;
}

void NamedHeaderOrReference::InternalSwap(NamedHeaderOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedHeaderOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[33]);
}

// ===================================================================

class NamedLinkOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::LinkOrReference& value(const NamedLinkOrReference* msg);
};

const ::gnostic::openapi::v3::LinkOrReference&
NamedLinkOrReference::_Internal::value(const NamedLinkOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedLinkOrReference::NamedLinkOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedLinkOrReference)
}
NamedLinkOrReference::NamedLinkOrReference(const NamedLinkOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedLinkOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::LinkOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedLinkOrReference)
}

inline void NamedLinkOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedLinkOrReference::~NamedLinkOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedLinkOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedLinkOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedLinkOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedLinkOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedLinkOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedLinkOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedLinkOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.LinkOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedLinkOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedLinkOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedLinkOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.LinkOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedLinkOrReference)
  return target;
}

size_t NamedLinkOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedLinkOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.LinkOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedLinkOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedLinkOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedLinkOrReference::GetClassData() const { return &_class_data_; }


void NamedLinkOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedLinkOrReference*>(&to_msg);
  auto& from = static_cast<const NamedLinkOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedLinkOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::LinkOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedLinkOrReference::CopyFrom(const NamedLinkOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedLinkOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedLinkOrReference::IsInitialized() const {
  return true;
}

void NamedLinkOrReference::InternalSwap(NamedLinkOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedLinkOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[34]);
}

// ===================================================================

class NamedMediaType::_Internal {
 public:
  static const ::gnostic::openapi::v3::MediaType& value(const NamedMediaType* msg);
};

const ::gnostic::openapi::v3::MediaType&
NamedMediaType::_Internal::value(const NamedMediaType* msg) {
  return *msg->_impl_.value_;
}
NamedMediaType::NamedMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedMediaType)
}
NamedMediaType::NamedMediaType(const NamedMediaType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedMediaType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::MediaType(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedMediaType)
}

inline void NamedMediaType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedMediaType::~NamedMediaType() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedMediaType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedMediaType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedMediaType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedMediaType::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedMediaType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedMediaType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedMediaType.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.MediaType value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedMediaType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedMediaType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedMediaType.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.MediaType value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedMediaType)
  return target;
}

size_t NamedMediaType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedMediaType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.MediaType value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedMediaType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedMediaType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedMediaType::GetClassData() const { return &_class_data_; }


void NamedMediaType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedMediaType*>(&to_msg);
  auto& from = static_cast<const NamedMediaType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedMediaType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::MediaType::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedMediaType::CopyFrom(const NamedMediaType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedMediaType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedMediaType::IsInitialized() const {
  return true;
}

void NamedMediaType::InternalSwap(NamedMediaType* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedMediaType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[35]);
}

// ===================================================================

class NamedParameterOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::ParameterOrReference& value(const NamedParameterOrReference* msg);
};

const ::gnostic::openapi::v3::ParameterOrReference&
NamedParameterOrReference::_Internal::value(const NamedParameterOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedParameterOrReference::NamedParameterOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedParameterOrReference)
}
NamedParameterOrReference::NamedParameterOrReference(const NamedParameterOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedParameterOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::ParameterOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedParameterOrReference)
}

inline void NamedParameterOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedParameterOrReference::~NamedParameterOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedParameterOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedParameterOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedParameterOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedParameterOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedParameterOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedParameterOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedParameterOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ParameterOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedParameterOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedParameterOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedParameterOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.ParameterOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedParameterOrReference)
  return target;
}

size_t NamedParameterOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedParameterOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.ParameterOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedParameterOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedParameterOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedParameterOrReference::GetClassData() const { return &_class_data_; }


void NamedParameterOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedParameterOrReference*>(&to_msg);
  auto& from = static_cast<const NamedParameterOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedParameterOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::ParameterOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedParameterOrReference::CopyFrom(const NamedParameterOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedParameterOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedParameterOrReference::IsInitialized() const {
  return true;
}

void NamedParameterOrReference::InternalSwap(NamedParameterOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedParameterOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[36]);
}

// ===================================================================

class NamedPathItem::_Internal {
 public:
  static const ::gnostic::openapi::v3::PathItem& value(const NamedPathItem* msg);
};

const ::gnostic::openapi::v3::PathItem&
NamedPathItem::_Internal::value(const NamedPathItem* msg) {
  return *msg->_impl_.value_;
}
NamedPathItem::NamedPathItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedPathItem)
}
NamedPathItem::NamedPathItem(const NamedPathItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedPathItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::PathItem(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedPathItem)
}

inline void NamedPathItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedPathItem::~NamedPathItem() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedPathItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedPathItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedPathItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedPathItem::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedPathItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedPathItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedPathItem.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.PathItem value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedPathItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedPathItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedPathItem.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.PathItem value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedPathItem)
  return target;
}

size_t NamedPathItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedPathItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.PathItem value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedPathItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedPathItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedPathItem::GetClassData() const { return &_class_data_; }


void NamedPathItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedPathItem*>(&to_msg);
  auto& from = static_cast<const NamedPathItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedPathItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::PathItem::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedPathItem::CopyFrom(const NamedPathItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedPathItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedPathItem::IsInitialized() const {
  return true;
}

void NamedPathItem::InternalSwap(NamedPathItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedPathItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[37]);
}

// ===================================================================

class NamedRequestBodyOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::RequestBodyOrReference& value(const NamedRequestBodyOrReference* msg);
};

const ::gnostic::openapi::v3::RequestBodyOrReference&
NamedRequestBodyOrReference::_Internal::value(const NamedRequestBodyOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedRequestBodyOrReference::NamedRequestBodyOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedRequestBodyOrReference)
}
NamedRequestBodyOrReference::NamedRequestBodyOrReference(const NamedRequestBodyOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedRequestBodyOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::RequestBodyOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedRequestBodyOrReference)
}

inline void NamedRequestBodyOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedRequestBodyOrReference::~NamedRequestBodyOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedRequestBodyOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedRequestBodyOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedRequestBodyOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedRequestBodyOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedRequestBodyOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedRequestBodyOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedRequestBodyOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.RequestBodyOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedRequestBodyOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedRequestBodyOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedRequestBodyOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.RequestBodyOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedRequestBodyOrReference)
  return target;
}

size_t NamedRequestBodyOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedRequestBodyOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.RequestBodyOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedRequestBodyOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedRequestBodyOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedRequestBodyOrReference::GetClassData() const { return &_class_data_; }


void NamedRequestBodyOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedRequestBodyOrReference*>(&to_msg);
  auto& from = static_cast<const NamedRequestBodyOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedRequestBodyOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::RequestBodyOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedRequestBodyOrReference::CopyFrom(const NamedRequestBodyOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedRequestBodyOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedRequestBodyOrReference::IsInitialized() const {
  return true;
}

void NamedRequestBodyOrReference::InternalSwap(NamedRequestBodyOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedRequestBodyOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[38]);
}

// ===================================================================

class NamedResponseOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::ResponseOrReference& value(const NamedResponseOrReference* msg);
};

const ::gnostic::openapi::v3::ResponseOrReference&
NamedResponseOrReference::_Internal::value(const NamedResponseOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedResponseOrReference::NamedResponseOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedResponseOrReference)
}
NamedResponseOrReference::NamedResponseOrReference(const NamedResponseOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedResponseOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::ResponseOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedResponseOrReference)
}

inline void NamedResponseOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedResponseOrReference::~NamedResponseOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedResponseOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedResponseOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedResponseOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedResponseOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedResponseOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedResponseOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedResponseOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ResponseOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedResponseOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedResponseOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedResponseOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.ResponseOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedResponseOrReference)
  return target;
}

size_t NamedResponseOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedResponseOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.ResponseOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedResponseOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedResponseOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedResponseOrReference::GetClassData() const { return &_class_data_; }


void NamedResponseOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedResponseOrReference*>(&to_msg);
  auto& from = static_cast<const NamedResponseOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedResponseOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::ResponseOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedResponseOrReference::CopyFrom(const NamedResponseOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedResponseOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedResponseOrReference::IsInitialized() const {
  return true;
}

void NamedResponseOrReference::InternalSwap(NamedResponseOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedResponseOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[39]);
}

// ===================================================================

class NamedSchemaOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::SchemaOrReference& value(const NamedSchemaOrReference* msg);
};

const ::gnostic::openapi::v3::SchemaOrReference&
NamedSchemaOrReference::_Internal::value(const NamedSchemaOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedSchemaOrReference::NamedSchemaOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedSchemaOrReference)
}
NamedSchemaOrReference::NamedSchemaOrReference(const NamedSchemaOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedSchemaOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::SchemaOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedSchemaOrReference)
}

inline void NamedSchemaOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedSchemaOrReference::~NamedSchemaOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedSchemaOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedSchemaOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedSchemaOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedSchemaOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedSchemaOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedSchemaOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedSchemaOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.SchemaOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedSchemaOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedSchemaOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedSchemaOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.SchemaOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedSchemaOrReference)
  return target;
}

size_t NamedSchemaOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedSchemaOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.SchemaOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedSchemaOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedSchemaOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedSchemaOrReference::GetClassData() const { return &_class_data_; }


void NamedSchemaOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedSchemaOrReference*>(&to_msg);
  auto& from = static_cast<const NamedSchemaOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedSchemaOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::SchemaOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedSchemaOrReference::CopyFrom(const NamedSchemaOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedSchemaOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedSchemaOrReference::IsInitialized() const {
  return true;
}

void NamedSchemaOrReference::InternalSwap(NamedSchemaOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedSchemaOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[40]);
}

// ===================================================================

class NamedSecuritySchemeOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::SecuritySchemeOrReference& value(const NamedSecuritySchemeOrReference* msg);
};

const ::gnostic::openapi::v3::SecuritySchemeOrReference&
NamedSecuritySchemeOrReference::_Internal::value(const NamedSecuritySchemeOrReference* msg) {
  return *msg->_impl_.value_;
}
NamedSecuritySchemeOrReference::NamedSecuritySchemeOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
}
NamedSecuritySchemeOrReference::NamedSecuritySchemeOrReference(const NamedSecuritySchemeOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedSecuritySchemeOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::SecuritySchemeOrReference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
}

inline void NamedSecuritySchemeOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedSecuritySchemeOrReference::~NamedSecuritySchemeOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedSecuritySchemeOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedSecuritySchemeOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedSecuritySchemeOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedSecuritySchemeOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedSecuritySchemeOrReference.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.SecuritySchemeOrReference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedSecuritySchemeOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedSecuritySchemeOrReference.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.SecuritySchemeOrReference value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
  return target;
}

size_t NamedSecuritySchemeOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.SecuritySchemeOrReference value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedSecuritySchemeOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedSecuritySchemeOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedSecuritySchemeOrReference::GetClassData() const { return &_class_data_; }


void NamedSecuritySchemeOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedSecuritySchemeOrReference*>(&to_msg);
  auto& from = static_cast<const NamedSecuritySchemeOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::SecuritySchemeOrReference::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedSecuritySchemeOrReference::CopyFrom(const NamedSecuritySchemeOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedSecuritySchemeOrReference::IsInitialized() const {
  return true;
}

void NamedSecuritySchemeOrReference::InternalSwap(NamedSecuritySchemeOrReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedSecuritySchemeOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[41]);
}

// ===================================================================

class NamedServerVariable::_Internal {
 public:
  static const ::gnostic::openapi::v3::ServerVariable& value(const NamedServerVariable* msg);
};

const ::gnostic::openapi::v3::ServerVariable&
NamedServerVariable::_Internal::value(const NamedServerVariable* msg) {
  return *msg->_impl_.value_;
}
NamedServerVariable::NamedServerVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedServerVariable)
}
NamedServerVariable::NamedServerVariable(const NamedServerVariable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedServerVariable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::ServerVariable(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedServerVariable)
}

inline void NamedServerVariable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedServerVariable::~NamedServerVariable() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedServerVariable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedServerVariable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedServerVariable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedServerVariable::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedServerVariable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedServerVariable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedServerVariable.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ServerVariable value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedServerVariable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedServerVariable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedServerVariable.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.ServerVariable value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedServerVariable)
  return target;
}

size_t NamedServerVariable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedServerVariable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.ServerVariable value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedServerVariable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedServerVariable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedServerVariable::GetClassData() const { return &_class_data_; }


void NamedServerVariable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedServerVariable*>(&to_msg);
  auto& from = static_cast<const NamedServerVariable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedServerVariable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::ServerVariable::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedServerVariable::CopyFrom(const NamedServerVariable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedServerVariable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedServerVariable::IsInitialized() const {
  return true;
}

void NamedServerVariable::InternalSwap(NamedServerVariable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedServerVariable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[42]);
}

// ===================================================================

class NamedString::_Internal {
 public:
};

NamedString::NamedString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedString)
}
NamedString::NamedString(const NamedString& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedString)
}

inline void NamedString::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedString::~NamedString() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void NamedString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedString::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedString.name"));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedString.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedString.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedString.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedString)
  return target;
}

size_t NamedString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedString::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedString::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedString::GetClassData() const { return &_class_data_; }


void NamedString::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedString*>(&to_msg);
  auto& from = static_cast<const NamedString&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedString)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedString::CopyFrom(const NamedString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedString::IsInitialized() const {
  return true;
}

void NamedString::InternalSwap(NamedString* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedString::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[43]);
}

// ===================================================================

class NamedStringArray::_Internal {
 public:
  static const ::gnostic::openapi::v3::StringArray& value(const NamedStringArray* msg);
};

const ::gnostic::openapi::v3::StringArray&
NamedStringArray::_Internal::value(const NamedStringArray* msg) {
  return *msg->_impl_.value_;
}
NamedStringArray::NamedStringArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.NamedStringArray)
}
NamedStringArray::NamedStringArray(const NamedStringArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedStringArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::gnostic::openapi::v3::StringArray(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.NamedStringArray)
}

inline void NamedStringArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamedStringArray::~NamedStringArray() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.NamedStringArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedStringArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void NamedStringArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedStringArray::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.NamedStringArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedStringArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.NamedStringArray.name"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.StringArray value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedStringArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.NamedStringArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.NamedStringArray.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .gnostic.openapi.v3.StringArray value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.NamedStringArray)
  return target;
}

size_t NamedStringArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.NamedStringArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gnostic.openapi.v3.StringArray value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedStringArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedStringArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedStringArray::GetClassData() const { return &_class_data_; }


void NamedStringArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedStringArray*>(&to_msg);
  auto& from = static_cast<const NamedStringArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.NamedStringArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::gnostic::openapi::v3::StringArray::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedStringArray::CopyFrom(const NamedStringArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.NamedStringArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedStringArray::IsInitialized() const {
  return true;
}

void NamedStringArray::InternalSwap(NamedStringArray* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedStringArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[44]);
}

// ===================================================================

class OauthFlow::_Internal {
 public:
  static const ::gnostic::openapi::v3::Strings& scopes(const OauthFlow* msg);
};

const ::gnostic::openapi::v3::Strings&
OauthFlow::_Internal::scopes(const OauthFlow* msg) {
  return *msg->_impl_.scopes_;
}
OauthFlow::OauthFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.OauthFlow)
}
OauthFlow::OauthFlow(const OauthFlow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OauthFlow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.authorization_url_){}
    , decltype(_impl_.token_url_){}
    , decltype(_impl_.refresh_url_){}
    , decltype(_impl_.scopes_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.authorization_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_url().empty()) {
    _this->_impl_.authorization_url_.Set(from._internal_authorization_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.token_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_token_url().empty()) {
    _this->_impl_.token_url_.Set(from._internal_token_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.refresh_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.refresh_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_refresh_url().empty()) {
    _this->_impl_.refresh_url_.Set(from._internal_refresh_url(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_scopes()) {
    _this->_impl_.scopes_ = new ::gnostic::openapi::v3::Strings(*from._impl_.scopes_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.OauthFlow)
}

inline void OauthFlow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.authorization_url_){}
    , decltype(_impl_.token_url_){}
    , decltype(_impl_.refresh_url_){}
    , decltype(_impl_.scopes_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.authorization_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.token_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.refresh_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.refresh_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OauthFlow::~OauthFlow() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.OauthFlow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OauthFlow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.authorization_url_.Destroy();
  _impl_.token_url_.Destroy();
  _impl_.refresh_url_.Destroy();
  if (this != internal_default_instance()) delete _impl_.scopes_;
}

void OauthFlow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OauthFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.OauthFlow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.authorization_url_.ClearToEmpty();
  _impl_.token_url_.ClearToEmpty();
  _impl_.refresh_url_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.scopes_ != nullptr) {
    delete _impl_.scopes_;
  }
  _impl_.scopes_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OauthFlow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string authorization_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_authorization_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.OauthFlow.authorization_url"));
        } else
          goto handle_unusual;
        continue;
      // string token_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.OauthFlow.token_url"));
        } else
          goto handle_unusual;
        continue;
      // string refresh_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_refresh_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.OauthFlow.refresh_url"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Strings scopes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_scopes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OauthFlow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.OauthFlow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string authorization_url = 1;
  if (!this->_internal_authorization_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_url().data(), static_cast<int>(this->_internal_authorization_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.OauthFlow.authorization_url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_authorization_url(), target);
  }

  // string token_url = 2;
  if (!this->_internal_token_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_token_url().data(), static_cast<int>(this->_internal_token_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.OauthFlow.token_url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token_url(), target);
  }

  // string refresh_url = 3;
  if (!this->_internal_refresh_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_refresh_url().data(), static_cast<int>(this->_internal_refresh_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.OauthFlow.refresh_url");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_refresh_url(), target);
  }

  // .gnostic.openapi.v3.Strings scopes = 4;
  if (this->_internal_has_scopes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::scopes(this),
        _Internal::scopes(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.OauthFlow)
  return target;
}

size_t OauthFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.OauthFlow)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string authorization_url = 1;
  if (!this->_internal_authorization_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_url());
  }

  // string token_url = 2;
  if (!this->_internal_token_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token_url());
  }

  // string refresh_url = 3;
  if (!this->_internal_refresh_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_refresh_url());
  }

  // .gnostic.openapi.v3.Strings scopes = 4;
  if (this->_internal_has_scopes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scopes_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OauthFlow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OauthFlow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OauthFlow::GetClassData() const { return &_class_data_; }


void OauthFlow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OauthFlow*>(&to_msg);
  auto& from = static_cast<const OauthFlow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.OauthFlow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_authorization_url().empty()) {
    _this->_internal_set_authorization_url(from._internal_authorization_url());
  }
  if (!from._internal_token_url().empty()) {
    _this->_internal_set_token_url(from._internal_token_url());
  }
  if (!from._internal_refresh_url().empty()) {
    _this->_internal_set_refresh_url(from._internal_refresh_url());
  }
  if (from._internal_has_scopes()) {
    _this->_internal_mutable_scopes()->::gnostic::openapi::v3::Strings::MergeFrom(
        from._internal_scopes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OauthFlow::CopyFrom(const OauthFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.OauthFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OauthFlow::IsInitialized() const {
  return true;
}

void OauthFlow::InternalSwap(OauthFlow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_url_, lhs_arena,
      &other->_impl_.authorization_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_url_, lhs_arena,
      &other->_impl_.token_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.refresh_url_, lhs_arena,
      &other->_impl_.refresh_url_, rhs_arena
  );
  swap(_impl_.scopes_, other->_impl_.scopes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OauthFlow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[45]);
}

// ===================================================================

class OauthFlows::_Internal {
 public:
  static const ::gnostic::openapi::v3::OauthFlow& implicit(const OauthFlows* msg);
  static const ::gnostic::openapi::v3::OauthFlow& password(const OauthFlows* msg);
  static const ::gnostic::openapi::v3::OauthFlow& client_credentials(const OauthFlows* msg);
  static const ::gnostic::openapi::v3::OauthFlow& authorization_code(const OauthFlows* msg);
};

const ::gnostic::openapi::v3::OauthFlow&
OauthFlows::_Internal::implicit(const OauthFlows* msg) {
  return *msg->_impl_.implicit_;
}
const ::gnostic::openapi::v3::OauthFlow&
OauthFlows::_Internal::password(const OauthFlows* msg) {
  return *msg->_impl_.password_;
}
const ::gnostic::openapi::v3::OauthFlow&
OauthFlows::_Internal::client_credentials(const OauthFlows* msg) {
  return *msg->_impl_.client_credentials_;
}
const ::gnostic::openapi::v3::OauthFlow&
OauthFlows::_Internal::authorization_code(const OauthFlows* msg) {
  return *msg->_impl_.authorization_code_;
}
OauthFlows::OauthFlows(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.OauthFlows)
}
OauthFlows::OauthFlows(const OauthFlows& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OauthFlows* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.implicit_){nullptr}
    , decltype(_impl_.password_){nullptr}
    , decltype(_impl_.client_credentials_){nullptr}
    , decltype(_impl_.authorization_code_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_implicit()) {
    _this->_impl_.implicit_ = new ::gnostic::openapi::v3::OauthFlow(*from._impl_.implicit_);
  }
  if (from._internal_has_password()) {
    _this->_impl_.password_ = new ::gnostic::openapi::v3::OauthFlow(*from._impl_.password_);
  }
  if (from._internal_has_client_credentials()) {
    _this->_impl_.client_credentials_ = new ::gnostic::openapi::v3::OauthFlow(*from._impl_.client_credentials_);
  }
  if (from._internal_has_authorization_code()) {
    _this->_impl_.authorization_code_ = new ::gnostic::openapi::v3::OauthFlow(*from._impl_.authorization_code_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.OauthFlows)
}

inline void OauthFlows::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.implicit_){nullptr}
    , decltype(_impl_.password_){nullptr}
    , decltype(_impl_.client_credentials_){nullptr}
    , decltype(_impl_.authorization_code_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OauthFlows::~OauthFlows() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.OauthFlows)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OauthFlows::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.implicit_;
  if (this != internal_default_instance()) delete _impl_.password_;
  if (this != internal_default_instance()) delete _impl_.client_credentials_;
  if (this != internal_default_instance()) delete _impl_.authorization_code_;
}

void OauthFlows::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OauthFlows::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.OauthFlows)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.implicit_ != nullptr) {
    delete _impl_.implicit_;
  }
  _impl_.implicit_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.password_ != nullptr) {
    delete _impl_.password_;
  }
  _impl_.password_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.client_credentials_ != nullptr) {
    delete _impl_.client_credentials_;
  }
  _impl_.client_credentials_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.authorization_code_ != nullptr) {
    delete _impl_.authorization_code_;
  }
  _impl_.authorization_code_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OauthFlows::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.OauthFlow implicit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_implicit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.OauthFlow password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_password(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.OauthFlow client_credentials = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.OauthFlow authorization_code = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_authorization_code(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OauthFlows::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.OauthFlows)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.OauthFlow implicit = 1;
  if (this->_internal_has_implicit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::implicit(this),
        _Internal::implicit(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.OauthFlow password = 2;
  if (this->_internal_has_password()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::password(this),
        _Internal::password(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.OauthFlow client_credentials = 3;
  if (this->_internal_has_client_credentials()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::client_credentials(this),
        _Internal::client_credentials(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.OauthFlow authorization_code = 4;
  if (this->_internal_has_authorization_code()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::authorization_code(this),
        _Internal::authorization_code(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.OauthFlows)
  return target;
}

size_t OauthFlows::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.OauthFlows)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .gnostic.openapi.v3.OauthFlow implicit = 1;
  if (this->_internal_has_implicit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.implicit_);
  }

  // .gnostic.openapi.v3.OauthFlow password = 2;
  if (this->_internal_has_password()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.password_);
  }

  // .gnostic.openapi.v3.OauthFlow client_credentials = 3;
  if (this->_internal_has_client_credentials()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.client_credentials_);
  }

  // .gnostic.openapi.v3.OauthFlow authorization_code = 4;
  if (this->_internal_has_authorization_code()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.authorization_code_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OauthFlows::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OauthFlows::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OauthFlows::GetClassData() const { return &_class_data_; }


void OauthFlows::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OauthFlows*>(&to_msg);
  auto& from = static_cast<const OauthFlows&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.OauthFlows)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (from._internal_has_implicit()) {
    _this->_internal_mutable_implicit()->::gnostic::openapi::v3::OauthFlow::MergeFrom(
        from._internal_implicit());
  }
  if (from._internal_has_password()) {
    _this->_internal_mutable_password()->::gnostic::openapi::v3::OauthFlow::MergeFrom(
        from._internal_password());
  }
  if (from._internal_has_client_credentials()) {
    _this->_internal_mutable_client_credentials()->::gnostic::openapi::v3::OauthFlow::MergeFrom(
        from._internal_client_credentials());
  }
  if (from._internal_has_authorization_code()) {
    _this->_internal_mutable_authorization_code()->::gnostic::openapi::v3::OauthFlow::MergeFrom(
        from._internal_authorization_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OauthFlows::CopyFrom(const OauthFlows& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.OauthFlows)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OauthFlows::IsInitialized() const {
  return true;
}

void OauthFlows::InternalSwap(OauthFlows* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OauthFlows, _impl_.authorization_code_)
      + sizeof(OauthFlows::_impl_.authorization_code_)
      - PROTOBUF_FIELD_OFFSET(OauthFlows, _impl_.implicit_)>(
          reinterpret_cast<char*>(&_impl_.implicit_),
          reinterpret_cast<char*>(&other->_impl_.implicit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OauthFlows::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[46]);
}

// ===================================================================

class Object::_Internal {
 public:
};

Object::Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Object)
}
Object::Object(const Object& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Object* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Object)
}

inline void Object::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Object::~Object() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Object)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Object::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void Object::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Object::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Object)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Object::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Object::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Object)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Object)
  return target;
}

size_t Object::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Object)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Object::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Object::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Object::GetClassData() const { return &_class_data_; }


void Object::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Object*>(&to_msg);
  auto& from = static_cast<const Object&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Object)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Object::CopyFrom(const Object& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Object)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Object::IsInitialized() const {
  return true;
}

void Object::InternalSwap(Object* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Object::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[47]);
}

// ===================================================================

class Operation::_Internal {
 public:
  static const ::gnostic::openapi::v3::ExternalDocs& external_docs(const Operation* msg);
  static const ::gnostic::openapi::v3::RequestBodyOrReference& request_body(const Operation* msg);
  static const ::gnostic::openapi::v3::Responses& responses(const Operation* msg);
  static const ::gnostic::openapi::v3::CallbacksOrReferences& callbacks(const Operation* msg);
};

const ::gnostic::openapi::v3::ExternalDocs&
Operation::_Internal::external_docs(const Operation* msg) {
  return *msg->_impl_.external_docs_;
}
const ::gnostic::openapi::v3::RequestBodyOrReference&
Operation::_Internal::request_body(const Operation* msg) {
  return *msg->_impl_.request_body_;
}
const ::gnostic::openapi::v3::Responses&
Operation::_Internal::responses(const Operation* msg) {
  return *msg->_impl_.responses_;
}
const ::gnostic::openapi::v3::CallbacksOrReferences&
Operation::_Internal::callbacks(const Operation* msg) {
  return *msg->_impl_.callbacks_;
}
Operation::Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Operation)
}
Operation::Operation(const Operation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Operation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tags_){from._impl_.tags_}
    , decltype(_impl_.parameters_){from._impl_.parameters_}
    , decltype(_impl_.security_){from._impl_.security_}
    , decltype(_impl_.servers_){from._impl_.servers_}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.operation_id_){}
    , decltype(_impl_.external_docs_){nullptr}
    , decltype(_impl_.request_body_){nullptr}
    , decltype(_impl_.responses_){nullptr}
    , decltype(_impl_.callbacks_){nullptr}
    , decltype(_impl_.deprecated_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_summary().empty()) {
    _this->_impl_.summary_.Set(from._internal_summary(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.operation_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operation_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_id().empty()) {
    _this->_impl_.operation_id_.Set(from._internal_operation_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_external_docs()) {
    _this->_impl_.external_docs_ = new ::gnostic::openapi::v3::ExternalDocs(*from._impl_.external_docs_);
  }
  if (from._internal_has_request_body()) {
    _this->_impl_.request_body_ = new ::gnostic::openapi::v3::RequestBodyOrReference(*from._impl_.request_body_);
  }
  if (from._internal_has_responses()) {
    _this->_impl_.responses_ = new ::gnostic::openapi::v3::Responses(*from._impl_.responses_);
  }
  if (from._internal_has_callbacks()) {
    _this->_impl_.callbacks_ = new ::gnostic::openapi::v3::CallbacksOrReferences(*from._impl_.callbacks_);
  }
  _this->_impl_.deprecated_ = from._impl_.deprecated_;
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Operation)
}

inline void Operation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tags_){arena}
    , decltype(_impl_.parameters_){arena}
    , decltype(_impl_.security_){arena}
    , decltype(_impl_.servers_){arena}
    , decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.operation_id_){}
    , decltype(_impl_.external_docs_){nullptr}
    , decltype(_impl_.request_body_){nullptr}
    , decltype(_impl_.responses_){nullptr}
    , decltype(_impl_.callbacks_){nullptr}
    , decltype(_impl_.deprecated_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.operation_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operation_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Operation::~Operation() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Operation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Operation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tags_.~RepeatedPtrField();
  _impl_.parameters_.~RepeatedPtrField();
  _impl_.security_.~RepeatedPtrField();
  _impl_.servers_.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.summary_.Destroy();
  _impl_.description_.Destroy();
  _impl_.operation_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.external_docs_;
  if (this != internal_default_instance()) delete _impl_.request_body_;
  if (this != internal_default_instance()) delete _impl_.responses_;
  if (this != internal_default_instance()) delete _impl_.callbacks_;
}

void Operation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Operation::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Operation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tags_.Clear();
  _impl_.parameters_.Clear();
  _impl_.security_.Clear();
  _impl_.servers_.Clear();
  _impl_.specification_extension_.Clear();
  _impl_.summary_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.operation_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.request_body_ != nullptr) {
    delete _impl_.request_body_;
  }
  _impl_.request_body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.responses_ != nullptr) {
    delete _impl_.responses_;
  }
  _impl_.responses_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.callbacks_ != nullptr) {
    delete _impl_.callbacks_;
  }
  _impl_.callbacks_ = nullptr;
  _impl_.deprecated_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Operation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string tags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Operation.tags"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string summary = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_summary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Operation.summary"));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Operation.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExternalDocs external_docs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_docs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string operation_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_operation_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Operation.operation_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.RequestBodyOrReference request_body = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Responses responses = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_responses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_callbacks(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool deprecated = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.SecurityRequirement security = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_security(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.Server servers = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_servers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Operation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Operation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string tags = 1;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Operation.tags");
    target = stream->WriteString(1, s, target);
  }

  // string summary = 2;
  if (!this->_internal_summary().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_summary().data(), static_cast<int>(this->_internal_summary().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Operation.summary");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_summary(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Operation.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 4;
  if (this->_internal_has_external_docs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::external_docs(this),
        _Internal::external_docs(this).GetCachedSize(), target, stream);
  }

  // string operation_id = 5;
  if (!this->_internal_operation_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_operation_id().data(), static_cast<int>(this->_internal_operation_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Operation.operation_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_operation_id(), target);
  }

  // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.RequestBodyOrReference request_body = 7;
  if (this->_internal_has_request_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::request_body(this),
        _Internal::request_body(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Responses responses = 8;
  if (this->_internal_has_responses()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::responses(this),
        _Internal::responses(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
  if (this->_internal_has_callbacks()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::callbacks(this),
        _Internal::callbacks(this).GetCachedSize(), target, stream);
  }

  // bool deprecated = 10;
  if (this->_internal_deprecated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_deprecated(), target);
  }

  // repeated .gnostic.openapi.v3.SecurityRequirement security = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_security_size()); i < n; i++) {
    const auto& repfield = this->_internal_security(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.Server servers = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_servers_size()); i < n; i++) {
    const auto& repfield = this->_internal_servers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Operation)
  return target;
}

size_t Operation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Operation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string tags = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.tags_.size());
  for (int i = 0, n = _impl_.tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.tags_.Get(i));
  }

  // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 6;
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->_impl_.parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.SecurityRequirement security = 11;
  total_size += 1UL * this->_internal_security_size();
  for (const auto& msg : this->_impl_.security_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.Server servers = 12;
  total_size += 1UL * this->_internal_servers_size();
  for (const auto& msg : this->_impl_.servers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 13;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string summary = 2;
  if (!this->_internal_summary().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_summary());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string operation_id = 5;
  if (!this->_internal_operation_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_operation_id());
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 4;
  if (this->_internal_has_external_docs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.external_docs_);
  }

  // .gnostic.openapi.v3.RequestBodyOrReference request_body = 7;
  if (this->_internal_has_request_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.request_body_);
  }

  // .gnostic.openapi.v3.Responses responses = 8;
  if (this->_internal_has_responses()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.responses_);
  }

  // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
  if (this->_internal_has_callbacks()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.callbacks_);
  }

  // bool deprecated = 10;
  if (this->_internal_deprecated() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Operation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Operation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Operation::GetClassData() const { return &_class_data_; }


void Operation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Operation*>(&to_msg);
  auto& from = static_cast<const Operation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Operation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tags_.MergeFrom(from._impl_.tags_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  _this->_impl_.security_.MergeFrom(from._impl_.security_);
  _this->_impl_.servers_.MergeFrom(from._impl_.servers_);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_summary().empty()) {
    _this->_internal_set_summary(from._internal_summary());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_operation_id().empty()) {
    _this->_internal_set_operation_id(from._internal_operation_id());
  }
  if (from._internal_has_external_docs()) {
    _this->_internal_mutable_external_docs()->::gnostic::openapi::v3::ExternalDocs::MergeFrom(
        from._internal_external_docs());
  }
  if (from._internal_has_request_body()) {
    _this->_internal_mutable_request_body()->::gnostic::openapi::v3::RequestBodyOrReference::MergeFrom(
        from._internal_request_body());
  }
  if (from._internal_has_responses()) {
    _this->_internal_mutable_responses()->::gnostic::openapi::v3::Responses::MergeFrom(
        from._internal_responses());
  }
  if (from._internal_has_callbacks()) {
    _this->_internal_mutable_callbacks()->::gnostic::openapi::v3::CallbacksOrReferences::MergeFrom(
        from._internal_callbacks());
  }
  if (from._internal_deprecated() != 0) {
    _this->_internal_set_deprecated(from._internal_deprecated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Operation::CopyFrom(const Operation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operation::IsInitialized() const {
  return true;
}

void Operation::InternalSwap(Operation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tags_.InternalSwap(&other->_impl_.tags_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  _impl_.security_.InternalSwap(&other->_impl_.security_);
  _impl_.servers_.InternalSwap(&other->_impl_.servers_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.summary_, lhs_arena,
      &other->_impl_.summary_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.operation_id_, lhs_arena,
      &other->_impl_.operation_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Operation, _impl_.deprecated_)
      + sizeof(Operation::_impl_.deprecated_)
      - PROTOBUF_FIELD_OFFSET(Operation, _impl_.external_docs_)>(
          reinterpret_cast<char*>(&_impl_.external_docs_),
          reinterpret_cast<char*>(&other->_impl_.external_docs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Operation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[48]);
}

// ===================================================================

class Parameter::_Internal {
 public:
  static const ::gnostic::openapi::v3::SchemaOrReference& schema(const Parameter* msg);
  static const ::gnostic::openapi::v3::Any& example(const Parameter* msg);
  static const ::gnostic::openapi::v3::ExamplesOrReferences& examples(const Parameter* msg);
  static const ::gnostic::openapi::v3::MediaTypes& content(const Parameter* msg);
};

const ::gnostic::openapi::v3::SchemaOrReference&
Parameter::_Internal::schema(const Parameter* msg) {
  return *msg->_impl_.schema_;
}
const ::gnostic::openapi::v3::Any&
Parameter::_Internal::example(const Parameter* msg) {
  return *msg->_impl_.example_;
}
const ::gnostic::openapi::v3::ExamplesOrReferences&
Parameter::_Internal::examples(const Parameter* msg) {
  return *msg->_impl_.examples_;
}
const ::gnostic::openapi::v3::MediaTypes&
Parameter::_Internal::content(const Parameter* msg) {
  return *msg->_impl_.content_;
}
Parameter::Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Parameter)
}
Parameter::Parameter(const Parameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Parameter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.in_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.schema_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.required_){}
    , decltype(_impl_.deprecated_){}
    , decltype(_impl_.allow_empty_value_){}
    , decltype(_impl_.explode_){}
    , decltype(_impl_.allow_reserved_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.in_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.in_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_in().empty()) {
    _this->_impl_.in_.Set(from._internal_in(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_style().empty()) {
    _this->_impl_.style_.Set(from._internal_style(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_schema()) {
    _this->_impl_.schema_ = new ::gnostic::openapi::v3::SchemaOrReference(*from._impl_.schema_);
  }
  if (from._internal_has_example()) {
    _this->_impl_.example_ = new ::gnostic::openapi::v3::Any(*from._impl_.example_);
  }
  if (from._internal_has_examples()) {
    _this->_impl_.examples_ = new ::gnostic::openapi::v3::ExamplesOrReferences(*from._impl_.examples_);
  }
  if (from._internal_has_content()) {
    _this->_impl_.content_ = new ::gnostic::openapi::v3::MediaTypes(*from._impl_.content_);
  }
  ::memcpy(&_impl_.required_, &from._impl_.required_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allow_reserved_) -
    reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.allow_reserved_));
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Parameter)
}

inline void Parameter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.in_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.schema_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.examples_){nullptr}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.required_){false}
    , decltype(_impl_.deprecated_){false}
    , decltype(_impl_.allow_empty_value_){false}
    , decltype(_impl_.explode_){false}
    , decltype(_impl_.allow_reserved_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.in_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.in_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Parameter::~Parameter() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Parameter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Parameter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.in_.Destroy();
  _impl_.description_.Destroy();
  _impl_.style_.Destroy();
  if (this != internal_default_instance()) delete _impl_.schema_;
  if (this != internal_default_instance()) delete _impl_.example_;
  if (this != internal_default_instance()) delete _impl_.examples_;
  if (this != internal_default_instance()) delete _impl_.content_;
}

void Parameter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Parameter::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Parameter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.in_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.style_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
  ::memset(&_impl_.required_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.allow_reserved_) -
      reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.allow_reserved_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Parameter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Parameter.name"));
        } else
          goto handle_unusual;
        continue;
      // string in = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_in();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Parameter.in"));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Parameter.description"));
        } else
          goto handle_unusual;
        continue;
      // bool required = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool deprecated = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_empty_value = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.allow_empty_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string style = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_style();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Parameter.style"));
        } else
          goto handle_unusual;
        continue;
      // bool explode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.explode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_reserved = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.allow_reserved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.SchemaOrReference schema = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Any example = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_example(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExamplesOrReferences examples = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_examples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.MediaTypes content = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Parameter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Parameter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Parameter.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string in = 2;
  if (!this->_internal_in().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_in().data(), static_cast<int>(this->_internal_in().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Parameter.in");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_in(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Parameter.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // bool required = 4;
  if (this->_internal_required() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_required(), target);
  }

  // bool deprecated = 5;
  if (this->_internal_deprecated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_deprecated(), target);
  }

  // bool allow_empty_value = 6;
  if (this->_internal_allow_empty_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_allow_empty_value(), target);
  }

  // string style = 7;
  if (!this->_internal_style().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_style().data(), static_cast<int>(this->_internal_style().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Parameter.style");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_style(), target);
  }

  // bool explode = 8;
  if (this->_internal_explode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_explode(), target);
  }

  // bool allow_reserved = 9;
  if (this->_internal_allow_reserved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_allow_reserved(), target);
  }

  // .gnostic.openapi.v3.SchemaOrReference schema = 10;
  if (this->_internal_has_schema()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Any example = 11;
  if (this->_internal_has_example()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::example(this),
        _Internal::example(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 12;
  if (this->_internal_has_examples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::examples(this),
        _Internal::examples(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.MediaTypes content = 13;
  if (this->_internal_has_content()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::content(this),
        _Internal::content(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Parameter)
  return target;
}

size_t Parameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Parameter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string in = 2;
  if (!this->_internal_in().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_in());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string style = 7;
  if (!this->_internal_style().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_style());
  }

  // .gnostic.openapi.v3.SchemaOrReference schema = 10;
  if (this->_internal_has_schema()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.schema_);
  }

  // .gnostic.openapi.v3.Any example = 11;
  if (this->_internal_has_example()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.example_);
  }

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 12;
  if (this->_internal_has_examples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.examples_);
  }

  // .gnostic.openapi.v3.MediaTypes content = 13;
  if (this->_internal_has_content()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.content_);
  }

  // bool required = 4;
  if (this->_internal_required() != 0) {
    total_size += 1 + 1;
  }

  // bool deprecated = 5;
  if (this->_internal_deprecated() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_empty_value = 6;
  if (this->_internal_allow_empty_value() != 0) {
    total_size += 1 + 1;
  }

  // bool explode = 8;
  if (this->_internal_explode() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_reserved = 9;
  if (this->_internal_allow_reserved() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Parameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Parameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Parameter::GetClassData() const { return &_class_data_; }


void Parameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Parameter*>(&to_msg);
  auto& from = static_cast<const Parameter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Parameter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_in().empty()) {
    _this->_internal_set_in(from._internal_in());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_style().empty()) {
    _this->_internal_set_style(from._internal_style());
  }
  if (from._internal_has_schema()) {
    _this->_internal_mutable_schema()->::gnostic::openapi::v3::SchemaOrReference::MergeFrom(
        from._internal_schema());
  }
  if (from._internal_has_example()) {
    _this->_internal_mutable_example()->::gnostic::openapi::v3::Any::MergeFrom(
        from._internal_example());
  }
  if (from._internal_has_examples()) {
    _this->_internal_mutable_examples()->::gnostic::openapi::v3::ExamplesOrReferences::MergeFrom(
        from._internal_examples());
  }
  if (from._internal_has_content()) {
    _this->_internal_mutable_content()->::gnostic::openapi::v3::MediaTypes::MergeFrom(
        from._internal_content());
  }
  if (from._internal_required() != 0) {
    _this->_internal_set_required(from._internal_required());
  }
  if (from._internal_deprecated() != 0) {
    _this->_internal_set_deprecated(from._internal_deprecated());
  }
  if (from._internal_allow_empty_value() != 0) {
    _this->_internal_set_allow_empty_value(from._internal_allow_empty_value());
  }
  if (from._internal_explode() != 0) {
    _this->_internal_set_explode(from._internal_explode());
  }
  if (from._internal_allow_reserved() != 0) {
    _this->_internal_set_allow_reserved(from._internal_allow_reserved());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Parameter::CopyFrom(const Parameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Parameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parameter::IsInitialized() const {
  return true;
}

void Parameter::InternalSwap(Parameter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.in_, lhs_arena,
      &other->_impl_.in_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.style_, lhs_arena,
      &other->_impl_.style_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Parameter, _impl_.allow_reserved_)
      + sizeof(Parameter::_impl_.allow_reserved_)
      - PROTOBUF_FIELD_OFFSET(Parameter, _impl_.schema_)>(
          reinterpret_cast<char*>(&_impl_.schema_),
          reinterpret_cast<char*>(&other->_impl_.schema_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Parameter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[49]);
}

// ===================================================================

class ParameterOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::Parameter& parameter(const ParameterOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const ParameterOrReference* msg);
};

const ::gnostic::openapi::v3::Parameter&
ParameterOrReference::_Internal::parameter(const ParameterOrReference* msg) {
  return *msg->_impl_.oneof_.parameter_;
}
const ::gnostic::openapi::v3::Reference&
ParameterOrReference::_Internal::reference(const ParameterOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void ParameterOrReference::set_allocated_parameter(::gnostic::openapi::v3::Parameter* parameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (parameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parameter);
    if (message_arena != submessage_arena) {
      parameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameter, submessage_arena);
    }
    set_has_parameter();
    _impl_.oneof_.parameter_ = parameter;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ParameterOrReference.parameter)
}
void ParameterOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ParameterOrReference.reference)
}
ParameterOrReference::ParameterOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ParameterOrReference)
}
ParameterOrReference::ParameterOrReference(const ParameterOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ParameterOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kParameter: {
      _this->_internal_mutable_parameter()->::gnostic::openapi::v3::Parameter::MergeFrom(
          from._internal_parameter());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ParameterOrReference)
}

inline void ParameterOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

ParameterOrReference::~ParameterOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ParameterOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ParameterOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void ParameterOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ParameterOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.ParameterOrReference)
  switch (oneof_case()) {
    case kParameter: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.parameter_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void ParameterOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ParameterOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParameterOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Parameter parameter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_parameter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ParameterOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ParameterOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Parameter parameter = 1;
  if (_internal_has_parameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::parameter(this),
        _Internal::parameter(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ParameterOrReference)
  return target;
}

size_t ParameterOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ParameterOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Parameter parameter = 1;
    case kParameter: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.parameter_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParameterOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ParameterOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParameterOrReference::GetClassData() const { return &_class_data_; }


void ParameterOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ParameterOrReference*>(&to_msg);
  auto& from = static_cast<const ParameterOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ParameterOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kParameter: {
      _this->_internal_mutable_parameter()->::gnostic::openapi::v3::Parameter::MergeFrom(
          from._internal_parameter());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ParameterOrReference::CopyFrom(const ParameterOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ParameterOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterOrReference::IsInitialized() const {
  return true;
}

void ParameterOrReference::InternalSwap(ParameterOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ParameterOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[50]);
}

// ===================================================================

class ParametersOrReferences::_Internal {
 public:
};

ParametersOrReferences::ParametersOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ParametersOrReferences)
}
ParametersOrReferences::ParametersOrReferences(const ParametersOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ParametersOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ParametersOrReferences)
}

inline void ParametersOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ParametersOrReferences::~ParametersOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ParametersOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ParametersOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void ParametersOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ParametersOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ParametersOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParametersOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ParametersOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ParametersOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ParametersOrReferences)
  return target;
}

size_t ParametersOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ParametersOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParametersOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ParametersOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParametersOrReferences::GetClassData() const { return &_class_data_; }


void ParametersOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ParametersOrReferences*>(&to_msg);
  auto& from = static_cast<const ParametersOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ParametersOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ParametersOrReferences::CopyFrom(const ParametersOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ParametersOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParametersOrReferences::IsInitialized() const {
  return true;
}

void ParametersOrReferences::InternalSwap(ParametersOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ParametersOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[51]);
}

// ===================================================================

class PathItem::_Internal {
 public:
  static const ::gnostic::openapi::v3::Operation& get(const PathItem* msg);
  static const ::gnostic::openapi::v3::Operation& put(const PathItem* msg);
  static const ::gnostic::openapi::v3::Operation& post(const PathItem* msg);
  static const ::gnostic::openapi::v3::Operation& delete_(const PathItem* msg);
  static const ::gnostic::openapi::v3::Operation& options(const PathItem* msg);
  static const ::gnostic::openapi::v3::Operation& head(const PathItem* msg);
  static const ::gnostic::openapi::v3::Operation& patch(const PathItem* msg);
  static const ::gnostic::openapi::v3::Operation& trace(const PathItem* msg);
};

const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::get(const PathItem* msg) {
  return *msg->_impl_.get_;
}
const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::put(const PathItem* msg) {
  return *msg->_impl_.put_;
}
const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::post(const PathItem* msg) {
  return *msg->_impl_.post_;
}
const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::delete_(const PathItem* msg) {
  return *msg->_impl_.delete__;
}
const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::options(const PathItem* msg) {
  return *msg->_impl_.options_;
}
const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::head(const PathItem* msg) {
  return *msg->_impl_.head_;
}
const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::patch(const PathItem* msg) {
  return *msg->_impl_.patch_;
}
const ::gnostic::openapi::v3::Operation&
PathItem::_Internal::trace(const PathItem* msg) {
  return *msg->_impl_.trace_;
}
PathItem::PathItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.PathItem)
}
PathItem::PathItem(const PathItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PathItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.servers_){from._impl_.servers_}
    , decltype(_impl_.parameters_){from._impl_.parameters_}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_._ref_){}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.get_){nullptr}
    , decltype(_impl_.put_){nullptr}
    , decltype(_impl_.post_){nullptr}
    , decltype(_impl_.delete__){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.head_){nullptr}
    , decltype(_impl_.patch_){nullptr}
    , decltype(_impl_.trace_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal__ref().empty()) {
    _this->_impl_._ref_.Set(from._internal__ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_summary().empty()) {
    _this->_impl_.summary_.Set(from._internal_summary(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_get()) {
    _this->_impl_.get_ = new ::gnostic::openapi::v3::Operation(*from._impl_.get_);
  }
  if (from._internal_has_put()) {
    _this->_impl_.put_ = new ::gnostic::openapi::v3::Operation(*from._impl_.put_);
  }
  if (from._internal_has_post()) {
    _this->_impl_.post_ = new ::gnostic::openapi::v3::Operation(*from._impl_.post_);
  }
  if (from._internal_has_delete_()) {
    _this->_impl_.delete__ = new ::gnostic::openapi::v3::Operation(*from._impl_.delete__);
  }
  if (from._internal_has_options()) {
    _this->_impl_.options_ = new ::gnostic::openapi::v3::Operation(*from._impl_.options_);
  }
  if (from._internal_has_head()) {
    _this->_impl_.head_ = new ::gnostic::openapi::v3::Operation(*from._impl_.head_);
  }
  if (from._internal_has_patch()) {
    _this->_impl_.patch_ = new ::gnostic::openapi::v3::Operation(*from._impl_.patch_);
  }
  if (from._internal_has_trace()) {
    _this->_impl_.trace_ = new ::gnostic::openapi::v3::Operation(*from._impl_.trace_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.PathItem)
}

inline void PathItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.servers_){arena}
    , decltype(_impl_.parameters_){arena}
    , decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_._ref_){}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.get_){nullptr}
    , decltype(_impl_.put_){nullptr}
    , decltype(_impl_.post_){nullptr}
    , decltype(_impl_.delete__){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.head_){nullptr}
    , decltype(_impl_.patch_){nullptr}
    , decltype(_impl_.trace_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_._ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PathItem::~PathItem() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.PathItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.servers_.~RepeatedPtrField();
  _impl_.parameters_.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_._ref_.Destroy();
  _impl_.summary_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.get_;
  if (this != internal_default_instance()) delete _impl_.put_;
  if (this != internal_default_instance()) delete _impl_.post_;
  if (this != internal_default_instance()) delete _impl_.delete__;
  if (this != internal_default_instance()) delete _impl_.options_;
  if (this != internal_default_instance()) delete _impl_.head_;
  if (this != internal_default_instance()) delete _impl_.patch_;
  if (this != internal_default_instance()) delete _impl_.trace_;
}

void PathItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathItem::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.PathItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.servers_.Clear();
  _impl_.parameters_.Clear();
  _impl_.specification_extension_.Clear();
  _impl_._ref_.ClearToEmpty();
  _impl_.summary_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.get_ != nullptr) {
    delete _impl_.get_;
  }
  _impl_.get_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.put_ != nullptr) {
    delete _impl_.put_;
  }
  _impl_.put_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.post_ != nullptr) {
    delete _impl_.post_;
  }
  _impl_.post_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.delete__ != nullptr) {
    delete _impl_.delete__;
  }
  _impl_.delete__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.patch_ != nullptr) {
    delete _impl_.patch_;
  }
  _impl_.patch_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.trace_ != nullptr) {
    delete _impl_.trace_;
  }
  _impl_.trace_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string _ref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.PathItem._ref"));
        } else
          goto handle_unusual;
        continue;
      // string summary = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_summary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.PathItem.summary"));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.PathItem.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation get = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_get(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation put = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_put(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation post = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_post(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation delete = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_delete_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation options = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation head = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_head(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation patch = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_patch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Operation trace = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_trace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.Server servers = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_servers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PathItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.PathItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string _ref = 1;
  if (!this->_internal__ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal__ref().data(), static_cast<int>(this->_internal__ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.PathItem._ref");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__ref(), target);
  }

  // string summary = 2;
  if (!this->_internal_summary().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_summary().data(), static_cast<int>(this->_internal_summary().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.PathItem.summary");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_summary(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.PathItem.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.Operation get = 4;
  if (this->_internal_has_get()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::get(this),
        _Internal::get(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Operation put = 5;
  if (this->_internal_has_put()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::put(this),
        _Internal::put(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Operation post = 6;
  if (this->_internal_has_post()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::post(this),
        _Internal::post(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Operation delete = 7;
  if (this->_internal_has_delete_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::delete_(this),
        _Internal::delete_(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Operation options = 8;
  if (this->_internal_has_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Operation head = 9;
  if (this->_internal_has_head()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::head(this),
        _Internal::head(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Operation patch = 10;
  if (this->_internal_has_patch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::patch(this),
        _Internal::patch(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Operation trace = 11;
  if (this->_internal_has_trace()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::trace(this),
        _Internal::trace(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.Server servers = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_servers_size()); i < n; i++) {
    const auto& repfield = this->_internal_servers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.PathItem)
  return target;
}

size_t PathItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.PathItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.Server servers = 12;
  total_size += 1UL * this->_internal_servers_size();
  for (const auto& msg : this->_impl_.servers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 13;
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->_impl_.parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string _ref = 1;
  if (!this->_internal__ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__ref());
  }

  // string summary = 2;
  if (!this->_internal_summary().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_summary());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .gnostic.openapi.v3.Operation get = 4;
  if (this->_internal_has_get()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.get_);
  }

  // .gnostic.openapi.v3.Operation put = 5;
  if (this->_internal_has_put()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.put_);
  }

  // .gnostic.openapi.v3.Operation post = 6;
  if (this->_internal_has_post()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.post_);
  }

  // .gnostic.openapi.v3.Operation delete = 7;
  if (this->_internal_has_delete_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.delete__);
  }

  // .gnostic.openapi.v3.Operation options = 8;
  if (this->_internal_has_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.options_);
  }

  // .gnostic.openapi.v3.Operation head = 9;
  if (this->_internal_has_head()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.head_);
  }

  // .gnostic.openapi.v3.Operation patch = 10;
  if (this->_internal_has_patch()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.patch_);
  }

  // .gnostic.openapi.v3.Operation trace = 11;
  if (this->_internal_has_trace()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.trace_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PathItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathItem::GetClassData() const { return &_class_data_; }


void PathItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PathItem*>(&to_msg);
  auto& from = static_cast<const PathItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.PathItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.servers_.MergeFrom(from._impl_.servers_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal__ref().empty()) {
    _this->_internal_set__ref(from._internal__ref());
  }
  if (!from._internal_summary().empty()) {
    _this->_internal_set_summary(from._internal_summary());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_get()) {
    _this->_internal_mutable_get()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_get());
  }
  if (from._internal_has_put()) {
    _this->_internal_mutable_put()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_put());
  }
  if (from._internal_has_post()) {
    _this->_internal_mutable_post()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_post());
  }
  if (from._internal_has_delete_()) {
    _this->_internal_mutable_delete_()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_delete_());
  }
  if (from._internal_has_options()) {
    _this->_internal_mutable_options()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_options());
  }
  if (from._internal_has_head()) {
    _this->_internal_mutable_head()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_head());
  }
  if (from._internal_has_patch()) {
    _this->_internal_mutable_patch()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_patch());
  }
  if (from._internal_has_trace()) {
    _this->_internal_mutable_trace()->::gnostic::openapi::v3::Operation::MergeFrom(
        from._internal_trace());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathItem::CopyFrom(const PathItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.PathItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathItem::IsInitialized() const {
  return true;
}

void PathItem::InternalSwap(PathItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.servers_.InternalSwap(&other->_impl_.servers_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._ref_, lhs_arena,
      &other->_impl_._ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.summary_, lhs_arena,
      &other->_impl_.summary_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathItem, _impl_.trace_)
      + sizeof(PathItem::_impl_.trace_)
      - PROTOBUF_FIELD_OFFSET(PathItem, _impl_.get_)>(
          reinterpret_cast<char*>(&_impl_.get_),
          reinterpret_cast<char*>(&other->_impl_.get_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[52]);
}

// ===================================================================

class Paths::_Internal {
 public:
};

Paths::Paths(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Paths)
}
Paths::Paths(const Paths& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Paths* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){from._impl_.path_}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Paths)
}

inline void Paths::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){arena}
    , decltype(_impl_.specification_extension_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Paths::~Paths() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Paths)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Paths::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
}

void Paths::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Paths::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Paths)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.Clear();
  _impl_.specification_extension_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Paths::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_path(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Paths::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Paths)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_path_size()); i < n; i++) {
    const auto& repfield = this->_internal_path(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Paths)
  return target;
}

size_t Paths::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Paths)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
  total_size += 1UL * this->_internal_path_size();
  for (const auto& msg : this->_impl_.path_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Paths::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Paths::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Paths::GetClassData() const { return &_class_data_; }


void Paths::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Paths*>(&to_msg);
  auto& from = static_cast<const Paths&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Paths)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.path_.MergeFrom(from._impl_.path_);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Paths::CopyFrom(const Paths& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Paths)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Paths::IsInitialized() const {
  return true;
}

void Paths::InternalSwap(Paths* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Paths::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[53]);
}

// ===================================================================

class Properties::_Internal {
 public:
};

Properties::Properties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Properties)
}
Properties::Properties(const Properties& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Properties* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Properties)
}

inline void Properties::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Properties::~Properties() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Properties)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Properties::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void Properties::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Properties::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Properties)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Properties::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Properties::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Properties)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Properties)
  return target;
}

size_t Properties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Properties)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Properties::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Properties::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Properties::GetClassData() const { return &_class_data_; }


void Properties::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Properties*>(&to_msg);
  auto& from = static_cast<const Properties&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Properties)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Properties::CopyFrom(const Properties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Properties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Properties::IsInitialized() const {
  return true;
}

void Properties::InternalSwap(Properties* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Properties::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[54]);
}

// ===================================================================

class Reference::_Internal {
 public:
};

Reference::Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Reference)
}
Reference::Reference(const Reference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Reference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._ref_){}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal__ref().empty()) {
    _this->_impl_._ref_.Set(from._internal__ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_summary().empty()) {
    _this->_impl_.summary_.Set(from._internal_summary(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Reference)
}

inline void Reference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._ref_){}
    , decltype(_impl_.summary_){}
    , decltype(_impl_.description_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_._ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.summary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Reference::~Reference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Reference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Reference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._ref_.Destroy();
  _impl_.summary_.Destroy();
  _impl_.description_.Destroy();
}

void Reference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Reference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Reference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._ref_.ClearToEmpty();
  _impl_.summary_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Reference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string _ref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Reference._ref"));
        } else
          goto handle_unusual;
        continue;
      // string summary = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_summary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Reference.summary"));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Reference.description"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Reference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Reference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string _ref = 1;
  if (!this->_internal__ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal__ref().data(), static_cast<int>(this->_internal__ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Reference._ref");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__ref(), target);
  }

  // string summary = 2;
  if (!this->_internal_summary().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_summary().data(), static_cast<int>(this->_internal_summary().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Reference.summary");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_summary(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Reference.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Reference)
  return target;
}

size_t Reference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Reference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string _ref = 1;
  if (!this->_internal__ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__ref());
  }

  // string summary = 2;
  if (!this->_internal_summary().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_summary());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Reference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Reference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Reference::GetClassData() const { return &_class_data_; }


void Reference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Reference*>(&to_msg);
  auto& from = static_cast<const Reference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Reference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal__ref().empty()) {
    _this->_internal_set__ref(from._internal__ref());
  }
  if (!from._internal_summary().empty()) {
    _this->_internal_set_summary(from._internal_summary());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Reference::CopyFrom(const Reference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Reference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reference::IsInitialized() const {
  return true;
}

void Reference::InternalSwap(Reference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._ref_, lhs_arena,
      &other->_impl_._ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.summary_, lhs_arena,
      &other->_impl_.summary_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Reference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[55]);
}

// ===================================================================

class RequestBodiesOrReferences::_Internal {
 public:
};

RequestBodiesOrReferences::RequestBodiesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.RequestBodiesOrReferences)
}
RequestBodiesOrReferences::RequestBodiesOrReferences(const RequestBodiesOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestBodiesOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.RequestBodiesOrReferences)
}

inline void RequestBodiesOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RequestBodiesOrReferences::~RequestBodiesOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.RequestBodiesOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestBodiesOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void RequestBodiesOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestBodiesOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.RequestBodiesOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestBodiesOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestBodiesOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.RequestBodiesOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.RequestBodiesOrReferences)
  return target;
}

size_t RequestBodiesOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.RequestBodiesOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestBodiesOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestBodiesOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestBodiesOrReferences::GetClassData() const { return &_class_data_; }


void RequestBodiesOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestBodiesOrReferences*>(&to_msg);
  auto& from = static_cast<const RequestBodiesOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.RequestBodiesOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestBodiesOrReferences::CopyFrom(const RequestBodiesOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.RequestBodiesOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBodiesOrReferences::IsInitialized() const {
  return true;
}

void RequestBodiesOrReferences::InternalSwap(RequestBodiesOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestBodiesOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[56]);
}

// ===================================================================

class RequestBody::_Internal {
 public:
  static const ::gnostic::openapi::v3::MediaTypes& content(const RequestBody* msg);
};

const ::gnostic::openapi::v3::MediaTypes&
RequestBody::_Internal::content(const RequestBody* msg) {
  return *msg->_impl_.content_;
}
RequestBody::RequestBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.RequestBody)
}
RequestBody::RequestBody(const RequestBody& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestBody* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.description_){}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.required_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_content()) {
    _this->_impl_.content_ = new ::gnostic::openapi::v3::MediaTypes(*from._impl_.content_);
  }
  _this->_impl_.required_ = from._impl_.required_;
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.RequestBody)
}

inline void RequestBody::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.description_){}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.required_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestBody::~RequestBody() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.RequestBody)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestBody::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.content_;
}

void RequestBody::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestBody::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.RequestBody)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
  _impl_.required_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestBody::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.RequestBody.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.MediaTypes content = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool required = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestBody::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.RequestBody)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.RequestBody.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.MediaTypes content = 2;
  if (this->_internal_has_content()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::content(this),
        _Internal::content(this).GetCachedSize(), target, stream);
  }

  // bool required = 3;
  if (this->_internal_required() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_required(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.RequestBody)
  return target;
}

size_t RequestBody::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.RequestBody)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string description = 1;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .gnostic.openapi.v3.MediaTypes content = 2;
  if (this->_internal_has_content()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.content_);
  }

  // bool required = 3;
  if (this->_internal_required() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestBody::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestBody::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestBody::GetClassData() const { return &_class_data_; }


void RequestBody::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestBody*>(&to_msg);
  auto& from = static_cast<const RequestBody&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.RequestBody)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_content()) {
    _this->_internal_mutable_content()->::gnostic::openapi::v3::MediaTypes::MergeFrom(
        from._internal_content());
  }
  if (from._internal_required() != 0) {
    _this->_internal_set_required(from._internal_required());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestBody::CopyFrom(const RequestBody& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.RequestBody)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBody::IsInitialized() const {
  return true;
}

void RequestBody::InternalSwap(RequestBody* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestBody, _impl_.required_)
      + sizeof(RequestBody::_impl_.required_)
      - PROTOBUF_FIELD_OFFSET(RequestBody, _impl_.content_)>(
          reinterpret_cast<char*>(&_impl_.content_),
          reinterpret_cast<char*>(&other->_impl_.content_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestBody::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[57]);
}

// ===================================================================

class RequestBodyOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::RequestBody& request_body(const RequestBodyOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const RequestBodyOrReference* msg);
};

const ::gnostic::openapi::v3::RequestBody&
RequestBodyOrReference::_Internal::request_body(const RequestBodyOrReference* msg) {
  return *msg->_impl_.oneof_.request_body_;
}
const ::gnostic::openapi::v3::Reference&
RequestBodyOrReference::_Internal::reference(const RequestBodyOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void RequestBodyOrReference::set_allocated_request_body(::gnostic::openapi::v3::RequestBody* request_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (request_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_body);
    if (message_arena != submessage_arena) {
      request_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_body, submessage_arena);
    }
    set_has_request_body();
    _impl_.oneof_.request_body_ = request_body;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.RequestBodyOrReference.request_body)
}
void RequestBodyOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.RequestBodyOrReference.reference)
}
RequestBodyOrReference::RequestBodyOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.RequestBodyOrReference)
}
RequestBodyOrReference::RequestBodyOrReference(const RequestBodyOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestBodyOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kRequestBody: {
      _this->_internal_mutable_request_body()->::gnostic::openapi::v3::RequestBody::MergeFrom(
          from._internal_request_body());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.RequestBodyOrReference)
}

inline void RequestBodyOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

RequestBodyOrReference::~RequestBodyOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.RequestBodyOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestBodyOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void RequestBodyOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestBodyOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.RequestBodyOrReference)
  switch (oneof_case()) {
    case kRequestBody: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.request_body_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void RequestBodyOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.RequestBodyOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestBodyOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.RequestBody request_body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestBodyOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.RequestBodyOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.RequestBody request_body = 1;
  if (_internal_has_request_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::request_body(this),
        _Internal::request_body(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.RequestBodyOrReference)
  return target;
}

size_t RequestBodyOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.RequestBodyOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.RequestBody request_body = 1;
    case kRequestBody: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.request_body_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestBodyOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestBodyOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestBodyOrReference::GetClassData() const { return &_class_data_; }


void RequestBodyOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestBodyOrReference*>(&to_msg);
  auto& from = static_cast<const RequestBodyOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.RequestBodyOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kRequestBody: {
      _this->_internal_mutable_request_body()->::gnostic::openapi::v3::RequestBody::MergeFrom(
          from._internal_request_body());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestBodyOrReference::CopyFrom(const RequestBodyOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.RequestBodyOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBodyOrReference::IsInitialized() const {
  return true;
}

void RequestBodyOrReference::InternalSwap(RequestBodyOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestBodyOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[58]);
}

// ===================================================================

class Response::_Internal {
 public:
  static const ::gnostic::openapi::v3::HeadersOrReferences& headers(const Response* msg);
  static const ::gnostic::openapi::v3::MediaTypes& content(const Response* msg);
  static const ::gnostic::openapi::v3::LinksOrReferences& links(const Response* msg);
};

const ::gnostic::openapi::v3::HeadersOrReferences&
Response::_Internal::headers(const Response* msg) {
  return *msg->_impl_.headers_;
}
const ::gnostic::openapi::v3::MediaTypes&
Response::_Internal::content(const Response* msg) {
  return *msg->_impl_.content_;
}
const ::gnostic::openapi::v3::LinksOrReferences&
Response::_Internal::links(const Response* msg) {
  return *msg->_impl_.links_;
}
Response::Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.description_){}
    , decltype(_impl_.headers_){nullptr}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.links_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_headers()) {
    _this->_impl_.headers_ = new ::gnostic::openapi::v3::HeadersOrReferences(*from._impl_.headers_);
  }
  if (from._internal_has_content()) {
    _this->_impl_.content_ = new ::gnostic::openapi::v3::MediaTypes(*from._impl_.content_);
  }
  if (from._internal_has_links()) {
    _this->_impl_.links_ = new ::gnostic::openapi::v3::LinksOrReferences(*from._impl_.links_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Response)
}

inline void Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.description_){}
    , decltype(_impl_.headers_){nullptr}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.links_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.headers_;
  if (this != internal_default_instance()) delete _impl_.content_;
  if (this != internal_default_instance()) delete _impl_.links_;
}

void Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.headers_ != nullptr) {
    delete _impl_.headers_;
  }
  _impl_.headers_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.links_ != nullptr) {
    delete _impl_.links_;
  }
  _impl_.links_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Response.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.MediaTypes content = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.LinksOrReferences links = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_links(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Response.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
  if (this->_internal_has_headers()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::headers(this),
        _Internal::headers(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.MediaTypes content = 3;
  if (this->_internal_has_content()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::content(this),
        _Internal::content(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.LinksOrReferences links = 4;
  if (this->_internal_has_links()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::links(this),
        _Internal::links(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string description = 1;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
  if (this->_internal_has_headers()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.headers_);
  }

  // .gnostic.openapi.v3.MediaTypes content = 3;
  if (this->_internal_has_content()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.content_);
  }

  // .gnostic.openapi.v3.LinksOrReferences links = 4;
  if (this->_internal_has_links()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.links_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Response::GetClassData() const { return &_class_data_; }


void Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Response*>(&to_msg);
  auto& from = static_cast<const Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_headers()) {
    _this->_internal_mutable_headers()->::gnostic::openapi::v3::HeadersOrReferences::MergeFrom(
        from._internal_headers());
  }
  if (from._internal_has_content()) {
    _this->_internal_mutable_content()->::gnostic::openapi::v3::MediaTypes::MergeFrom(
        from._internal_content());
  }
  if (from._internal_has_links()) {
    _this->_internal_mutable_links()->::gnostic::openapi::v3::LinksOrReferences::MergeFrom(
        from._internal_links());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Response, _impl_.links_)
      + sizeof(Response::_impl_.links_)
      - PROTOBUF_FIELD_OFFSET(Response, _impl_.headers_)>(
          reinterpret_cast<char*>(&_impl_.headers_),
          reinterpret_cast<char*>(&other->_impl_.headers_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[59]);
}

// ===================================================================

class ResponseOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::Response& response(const ResponseOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const ResponseOrReference* msg);
};

const ::gnostic::openapi::v3::Response&
ResponseOrReference::_Internal::response(const ResponseOrReference* msg) {
  return *msg->_impl_.oneof_.response_;
}
const ::gnostic::openapi::v3::Reference&
ResponseOrReference::_Internal::reference(const ResponseOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void ResponseOrReference::set_allocated_response(::gnostic::openapi::v3::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    set_has_response();
    _impl_.oneof_.response_ = response;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ResponseOrReference.response)
}
void ResponseOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ResponseOrReference.reference)
}
ResponseOrReference::ResponseOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ResponseOrReference)
}
ResponseOrReference::ResponseOrReference(const ResponseOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kResponse: {
      _this->_internal_mutable_response()->::gnostic::openapi::v3::Response::MergeFrom(
          from._internal_response());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ResponseOrReference)
}

inline void ResponseOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

ResponseOrReference::~ResponseOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ResponseOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void ResponseOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.ResponseOrReference)
  switch (oneof_case()) {
    case kResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.response_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void ResponseOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ResponseOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Response response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ResponseOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Response response = 1;
  if (_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ResponseOrReference)
  return target;
}

size_t ResponseOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ResponseOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Response response = 1;
    case kResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.response_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseOrReference::GetClassData() const { return &_class_data_; }


void ResponseOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseOrReference*>(&to_msg);
  auto& from = static_cast<const ResponseOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ResponseOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kResponse: {
      _this->_internal_mutable_response()->::gnostic::openapi::v3::Response::MergeFrom(
          from._internal_response());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseOrReference::CopyFrom(const ResponseOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ResponseOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseOrReference::IsInitialized() const {
  return true;
}

void ResponseOrReference::InternalSwap(ResponseOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[60]);
}

// ===================================================================

class Responses::_Internal {
 public:
  static const ::gnostic::openapi::v3::ResponseOrReference& default_(const Responses* msg);
};

const ::gnostic::openapi::v3::ResponseOrReference&
Responses::_Internal::default_(const Responses* msg) {
  return *msg->_impl_.default__;
}
Responses::Responses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Responses)
}
Responses::Responses(const Responses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Responses* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_or_reference_){from._impl_.response_or_reference_}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.default__){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_default_()) {
    _this->_impl_.default__ = new ::gnostic::openapi::v3::ResponseOrReference(*from._impl_.default__);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Responses)
}

inline void Responses::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.response_or_reference_){arena}
    , decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.default__){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Responses::~Responses() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Responses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Responses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.response_or_reference_.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.default__;
}

void Responses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Responses::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Responses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_or_reference_.Clear();
  _impl_.specification_extension_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.default__ != nullptr) {
    delete _impl_.default__;
  }
  _impl_.default__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Responses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.ResponseOrReference default = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_response_or_reference(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Responses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Responses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.ResponseOrReference default = 1;
  if (this->_internal_has_default_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::default_(this),
        _Internal::default_(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_response_or_reference_size()); i < n; i++) {
    const auto& repfield = this->_internal_response_or_reference(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Responses)
  return target;
}

size_t Responses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Responses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2;
  total_size += 1UL * this->_internal_response_or_reference_size();
  for (const auto& msg : this->_impl_.response_or_reference_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .gnostic.openapi.v3.ResponseOrReference default = 1;
  if (this->_internal_has_default_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Responses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Responses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Responses::GetClassData() const { return &_class_data_; }


void Responses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Responses*>(&to_msg);
  auto& from = static_cast<const Responses&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Responses)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.response_or_reference_.MergeFrom(from._impl_.response_or_reference_);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (from._internal_has_default_()) {
    _this->_internal_mutable_default_()->::gnostic::openapi::v3::ResponseOrReference::MergeFrom(
        from._internal_default_());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Responses::CopyFrom(const Responses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Responses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Responses::IsInitialized() const {
  return true;
}

void Responses::InternalSwap(Responses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.response_or_reference_.InternalSwap(&other->_impl_.response_or_reference_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  swap(_impl_.default__, other->_impl_.default__);
}

::PROTOBUF_NAMESPACE_ID::Metadata Responses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[61]);
}

// ===================================================================

class ResponsesOrReferences::_Internal {
 public:
};

ResponsesOrReferences::ResponsesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ResponsesOrReferences)
}
ResponsesOrReferences::ResponsesOrReferences(const ResponsesOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponsesOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ResponsesOrReferences)
}

inline void ResponsesOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResponsesOrReferences::~ResponsesOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ResponsesOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponsesOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void ResponsesOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponsesOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ResponsesOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponsesOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponsesOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ResponsesOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ResponsesOrReferences)
  return target;
}

size_t ResponsesOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ResponsesOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponsesOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponsesOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponsesOrReferences::GetClassData() const { return &_class_data_; }


void ResponsesOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponsesOrReferences*>(&to_msg);
  auto& from = static_cast<const ResponsesOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ResponsesOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponsesOrReferences::CopyFrom(const ResponsesOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ResponsesOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponsesOrReferences::IsInitialized() const {
  return true;
}

void ResponsesOrReferences::InternalSwap(ResponsesOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponsesOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[62]);
}

// ===================================================================

class Schema::_Internal {
 public:
  static const ::gnostic::openapi::v3::Discriminator& discriminator(const Schema* msg);
  static const ::gnostic::openapi::v3::Xml& xml(const Schema* msg);
  static const ::gnostic::openapi::v3::ExternalDocs& external_docs(const Schema* msg);
  static const ::gnostic::openapi::v3::Any& example(const Schema* msg);
  static const ::gnostic::openapi::v3::Schema& not_(const Schema* msg);
  static const ::gnostic::openapi::v3::ItemsItem& items(const Schema* msg);
  static const ::gnostic::openapi::v3::Properties& properties(const Schema* msg);
  static const ::gnostic::openapi::v3::AdditionalPropertiesItem& additional_properties(const Schema* msg);
  static const ::gnostic::openapi::v3::DefaultType& default_(const Schema* msg);
};

const ::gnostic::openapi::v3::Discriminator&
Schema::_Internal::discriminator(const Schema* msg) {
  return *msg->_impl_.discriminator_;
}
const ::gnostic::openapi::v3::Xml&
Schema::_Internal::xml(const Schema* msg) {
  return *msg->_impl_.xml_;
}
const ::gnostic::openapi::v3::ExternalDocs&
Schema::_Internal::external_docs(const Schema* msg) {
  return *msg->_impl_.external_docs_;
}
const ::gnostic::openapi::v3::Any&
Schema::_Internal::example(const Schema* msg) {
  return *msg->_impl_.example_;
}
const ::gnostic::openapi::v3::Schema&
Schema::_Internal::not_(const Schema* msg) {
  return *msg->_impl_.not__;
}
const ::gnostic::openapi::v3::ItemsItem&
Schema::_Internal::items(const Schema* msg) {
  return *msg->_impl_.items_;
}
const ::gnostic::openapi::v3::Properties&
Schema::_Internal::properties(const Schema* msg) {
  return *msg->_impl_.properties_;
}
const ::gnostic::openapi::v3::AdditionalPropertiesItem&
Schema::_Internal::additional_properties(const Schema* msg) {
  return *msg->_impl_.additional_properties_;
}
const ::gnostic::openapi::v3::DefaultType&
Schema::_Internal::default_(const Schema* msg) {
  return *msg->_impl_.default__;
}
Schema::Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Schema)
}
Schema::Schema(const Schema& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Schema* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.required_){from._impl_.required_}
    , decltype(_impl_.enum__){from._impl_.enum__}
    , decltype(_impl_.all_of_){from._impl_.all_of_}
    , decltype(_impl_.one_of_){from._impl_.one_of_}
    , decltype(_impl_.any_of_){from._impl_.any_of_}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.title_){}
    , decltype(_impl_.pattern_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.discriminator_){nullptr}
    , decltype(_impl_.xml_){nullptr}
    , decltype(_impl_.external_docs_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.not__){nullptr}
    , decltype(_impl_.items_){nullptr}
    , decltype(_impl_.properties_){nullptr}
    , decltype(_impl_.additional_properties_){nullptr}
    , decltype(_impl_.default__){nullptr}
    , decltype(_impl_.nullable_){}
    , decltype(_impl_.read_only_){}
    , decltype(_impl_.write_only_){}
    , decltype(_impl_.deprecated_){}
    , decltype(_impl_.exclusive_maximum_){}
    , decltype(_impl_.exclusive_minimum_){}
    , decltype(_impl_.unique_items_){}
    , decltype(_impl_.multiple_of_){}
    , decltype(_impl_.maximum_){}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.max_length_){}
    , decltype(_impl_.min_length_){}
    , decltype(_impl_.max_items_){}
    , decltype(_impl_.min_items_){}
    , decltype(_impl_.max_properties_){}
    , decltype(_impl_.min_properties_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pattern().empty()) {
    _this->_impl_.pattern_.Set(from._internal_pattern(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_format().empty()) {
    _this->_impl_.format_.Set(from._internal_format(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_discriminator()) {
    _this->_impl_.discriminator_ = new ::gnostic::openapi::v3::Discriminator(*from._impl_.discriminator_);
  }
  if (from._internal_has_xml()) {
    _this->_impl_.xml_ = new ::gnostic::openapi::v3::Xml(*from._impl_.xml_);
  }
  if (from._internal_has_external_docs()) {
    _this->_impl_.external_docs_ = new ::gnostic::openapi::v3::ExternalDocs(*from._impl_.external_docs_);
  }
  if (from._internal_has_example()) {
    _this->_impl_.example_ = new ::gnostic::openapi::v3::Any(*from._impl_.example_);
  }
  if (from._internal_has_not_()) {
    _this->_impl_.not__ = new ::gnostic::openapi::v3::Schema(*from._impl_.not__);
  }
  if (from._internal_has_items()) {
    _this->_impl_.items_ = new ::gnostic::openapi::v3::ItemsItem(*from._impl_.items_);
  }
  if (from._internal_has_properties()) {
    _this->_impl_.properties_ = new ::gnostic::openapi::v3::Properties(*from._impl_.properties_);
  }
  if (from._internal_has_additional_properties()) {
    _this->_impl_.additional_properties_ = new ::gnostic::openapi::v3::AdditionalPropertiesItem(*from._impl_.additional_properties_);
  }
  if (from._internal_has_default_()) {
    _this->_impl_.default__ = new ::gnostic::openapi::v3::DefaultType(*from._impl_.default__);
  }
  ::memcpy(&_impl_.nullable_, &from._impl_.nullable_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_properties_) -
    reinterpret_cast<char*>(&_impl_.nullable_)) + sizeof(_impl_.min_properties_));
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Schema)
}

inline void Schema::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.required_){arena}
    , decltype(_impl_.enum__){arena}
    , decltype(_impl_.all_of_){arena}
    , decltype(_impl_.one_of_){arena}
    , decltype(_impl_.any_of_){arena}
    , decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.title_){}
    , decltype(_impl_.pattern_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.discriminator_){nullptr}
    , decltype(_impl_.xml_){nullptr}
    , decltype(_impl_.external_docs_){nullptr}
    , decltype(_impl_.example_){nullptr}
    , decltype(_impl_.not__){nullptr}
    , decltype(_impl_.items_){nullptr}
    , decltype(_impl_.properties_){nullptr}
    , decltype(_impl_.additional_properties_){nullptr}
    , decltype(_impl_.default__){nullptr}
    , decltype(_impl_.nullable_){false}
    , decltype(_impl_.read_only_){false}
    , decltype(_impl_.write_only_){false}
    , decltype(_impl_.deprecated_){false}
    , decltype(_impl_.exclusive_maximum_){false}
    , decltype(_impl_.exclusive_minimum_){false}
    , decltype(_impl_.unique_items_){false}
    , decltype(_impl_.multiple_of_){0}
    , decltype(_impl_.maximum_){0}
    , decltype(_impl_.minimum_){0}
    , decltype(_impl_.max_length_){int64_t{0}}
    , decltype(_impl_.min_length_){int64_t{0}}
    , decltype(_impl_.max_items_){int64_t{0}}
    , decltype(_impl_.min_items_){int64_t{0}}
    , decltype(_impl_.max_properties_){int64_t{0}}
    , decltype(_impl_.min_properties_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Schema::~Schema() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Schema)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Schema::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.required_.~RepeatedPtrField();
  _impl_.enum__.~RepeatedPtrField();
  _impl_.all_of_.~RepeatedPtrField();
  _impl_.one_of_.~RepeatedPtrField();
  _impl_.any_of_.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.pattern_.Destroy();
  _impl_.type_.Destroy();
  _impl_.description_.Destroy();
  _impl_.format_.Destroy();
  if (this != internal_default_instance()) delete _impl_.discriminator_;
  if (this != internal_default_instance()) delete _impl_.xml_;
  if (this != internal_default_instance()) delete _impl_.external_docs_;
  if (this != internal_default_instance()) delete _impl_.example_;
  if (this != internal_default_instance()) delete _impl_.not__;
  if (this != internal_default_instance()) delete _impl_.items_;
  if (this != internal_default_instance()) delete _impl_.properties_;
  if (this != internal_default_instance()) delete _impl_.additional_properties_;
  if (this != internal_default_instance()) delete _impl_.default__;
}

void Schema::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Schema::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Schema)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.required_.Clear();
  _impl_.enum__.Clear();
  _impl_.all_of_.Clear();
  _impl_.one_of_.Clear();
  _impl_.any_of_.Clear();
  _impl_.specification_extension_.Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.pattern_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.format_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.discriminator_ != nullptr) {
    delete _impl_.discriminator_;
  }
  _impl_.discriminator_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.xml_ != nullptr) {
    delete _impl_.xml_;
  }
  _impl_.xml_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.not__ != nullptr) {
    delete _impl_.not__;
  }
  _impl_.not__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.items_ != nullptr) {
    delete _impl_.items_;
  }
  _impl_.items_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.properties_ != nullptr) {
    delete _impl_.properties_;
  }
  _impl_.properties_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.additional_properties_ != nullptr) {
    delete _impl_.additional_properties_;
  }
  _impl_.additional_properties_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.default__ != nullptr) {
    delete _impl_.default__;
  }
  _impl_.default__ = nullptr;
  ::memset(&_impl_.nullable_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.min_properties_) -
      reinterpret_cast<char*>(&_impl_.nullable_)) + sizeof(_impl_.min_properties_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Schema::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool nullable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nullable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Discriminator discriminator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_discriminator(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool read_only = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.read_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool write_only = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.write_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Xml xml = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_xml(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExternalDocs external_docs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_docs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Any example = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_example(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool deprecated = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string title = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Schema.title"));
        } else
          goto handle_unusual;
        continue;
      // double multiple_of = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.multiple_of_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double maximum = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool exclusive_maximum = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.exclusive_maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double minimum = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _impl_.minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool exclusive_minimum = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.exclusive_minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max_length = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.max_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 min_length = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.min_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string pattern = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_pattern();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Schema.pattern"));
        } else
          goto handle_unusual;
        continue;
      // int64 max_items = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.max_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 min_items = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.min_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool unique_items = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.unique_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max_properties = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.max_properties_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 min_properties = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.min_properties_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string required = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_required();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Schema.required"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.Any enum = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_enum_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string type = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Schema.type"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.SchemaOrReference all_of = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_all_of(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<210>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.SchemaOrReference one_of = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_one_of(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.SchemaOrReference any_of = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_any_of(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Schema not = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_not_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ItemsItem items = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_items(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Properties properties = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_additional_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.DefaultType default = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string description = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Schema.description"));
        } else
          goto handle_unusual;
        continue;
      // string format = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Schema.format"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<290>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Schema::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Schema)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool nullable = 1;
  if (this->_internal_nullable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_nullable(), target);
  }

  // .gnostic.openapi.v3.Discriminator discriminator = 2;
  if (this->_internal_has_discriminator()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::discriminator(this),
        _Internal::discriminator(this).GetCachedSize(), target, stream);
  }

  // bool read_only = 3;
  if (this->_internal_read_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_read_only(), target);
  }

  // bool write_only = 4;
  if (this->_internal_write_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_write_only(), target);
  }

  // .gnostic.openapi.v3.Xml xml = 5;
  if (this->_internal_has_xml()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::xml(this),
        _Internal::xml(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 6;
  if (this->_internal_has_external_docs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::external_docs(this),
        _Internal::external_docs(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Any example = 7;
  if (this->_internal_has_example()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::example(this),
        _Internal::example(this).GetCachedSize(), target, stream);
  }

  // bool deprecated = 8;
  if (this->_internal_deprecated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_deprecated(), target);
  }

  // string title = 9;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Schema.title");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_title(), target);
  }

  // double multiple_of = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_multiple_of = this->_internal_multiple_of();
  uint64_t raw_multiple_of;
  memcpy(&raw_multiple_of, &tmp_multiple_of, sizeof(tmp_multiple_of));
  if (raw_multiple_of != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_multiple_of(), target);
  }

  // double maximum = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maximum = this->_internal_maximum();
  uint64_t raw_maximum;
  memcpy(&raw_maximum, &tmp_maximum, sizeof(tmp_maximum));
  if (raw_maximum != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_maximum(), target);
  }

  // bool exclusive_maximum = 12;
  if (this->_internal_exclusive_maximum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_exclusive_maximum(), target);
  }

  // double minimum = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_minimum = this->_internal_minimum();
  uint64_t raw_minimum;
  memcpy(&raw_minimum, &tmp_minimum, sizeof(tmp_minimum));
  if (raw_minimum != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_minimum(), target);
  }

  // bool exclusive_minimum = 14;
  if (this->_internal_exclusive_minimum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_exclusive_minimum(), target);
  }

  // int64 max_length = 15;
  if (this->_internal_max_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_max_length(), target);
  }

  // int64 min_length = 16;
  if (this->_internal_min_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(16, this->_internal_min_length(), target);
  }

  // string pattern = 17;
  if (!this->_internal_pattern().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pattern().data(), static_cast<int>(this->_internal_pattern().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Schema.pattern");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_pattern(), target);
  }

  // int64 max_items = 18;
  if (this->_internal_max_items() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(18, this->_internal_max_items(), target);
  }

  // int64 min_items = 19;
  if (this->_internal_min_items() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(19, this->_internal_min_items(), target);
  }

  // bool unique_items = 20;
  if (this->_internal_unique_items() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_unique_items(), target);
  }

  // int64 max_properties = 21;
  if (this->_internal_max_properties() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(21, this->_internal_max_properties(), target);
  }

  // int64 min_properties = 22;
  if (this->_internal_min_properties() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(22, this->_internal_min_properties(), target);
  }

  // repeated string required = 23;
  for (int i = 0, n = this->_internal_required_size(); i < n; i++) {
    const auto& s = this->_internal_required(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Schema.required");
    target = stream->WriteString(23, s, target);
  }

  // repeated .gnostic.openapi.v3.Any enum = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_enum__size()); i < n; i++) {
    const auto& repfield = this->_internal_enum_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string type = 25;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Schema.type");
    target = stream->WriteStringMaybeAliased(
        25, this->_internal_type(), target);
  }

  // repeated .gnostic.openapi.v3.SchemaOrReference all_of = 26;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_all_of_size()); i < n; i++) {
    const auto& repfield = this->_internal_all_of(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(26, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.SchemaOrReference one_of = 27;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_one_of_size()); i < n; i++) {
    const auto& repfield = this->_internal_one_of(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.SchemaOrReference any_of = 28;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_any_of_size()); i < n; i++) {
    const auto& repfield = this->_internal_any_of(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Schema not = 29;
  if (this->_internal_has_not_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::not_(this),
        _Internal::not_(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.ItemsItem items = 30;
  if (this->_internal_has_items()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::items(this),
        _Internal::items(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Properties properties = 31;
  if (this->_internal_has_properties()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::properties(this),
        _Internal::properties(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32;
  if (this->_internal_has_additional_properties()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::additional_properties(this),
        _Internal::additional_properties(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.DefaultType default = 33;
  if (this->_internal_has_default_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::default_(this),
        _Internal::default_(this).GetCachedSize(), target, stream);
  }

  // string description = 34;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Schema.description");
    target = stream->WriteStringMaybeAliased(
        34, this->_internal_description(), target);
  }

  // string format = 35;
  if (!this->_internal_format().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_format().data(), static_cast<int>(this->_internal_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Schema.format");
    target = stream->WriteStringMaybeAliased(
        35, this->_internal_format(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 36;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(36, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Schema)
  return target;
}

size_t Schema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Schema)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string required = 23;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.required_.size());
  for (int i = 0, n = _impl_.required_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.required_.Get(i));
  }

  // repeated .gnostic.openapi.v3.Any enum = 24;
  total_size += 2UL * this->_internal_enum__size();
  for (const auto& msg : this->_impl_.enum__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.SchemaOrReference all_of = 26;
  total_size += 2UL * this->_internal_all_of_size();
  for (const auto& msg : this->_impl_.all_of_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.SchemaOrReference one_of = 27;
  total_size += 2UL * this->_internal_one_of_size();
  for (const auto& msg : this->_impl_.one_of_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.SchemaOrReference any_of = 28;
  total_size += 2UL * this->_internal_any_of_size();
  for (const auto& msg : this->_impl_.any_of_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 36;
  total_size += 2UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string title = 9;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string pattern = 17;
  if (!this->_internal_pattern().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pattern());
  }

  // string type = 25;
  if (!this->_internal_type().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string description = 34;
  if (!this->_internal_description().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string format = 35;
  if (!this->_internal_format().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_format());
  }

  // .gnostic.openapi.v3.Discriminator discriminator = 2;
  if (this->_internal_has_discriminator()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.discriminator_);
  }

  // .gnostic.openapi.v3.Xml xml = 5;
  if (this->_internal_has_xml()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.xml_);
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 6;
  if (this->_internal_has_external_docs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.external_docs_);
  }

  // .gnostic.openapi.v3.Any example = 7;
  if (this->_internal_has_example()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.example_);
  }

  // .gnostic.openapi.v3.Schema not = 29;
  if (this->_internal_has_not_()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.not__);
  }

  // .gnostic.openapi.v3.ItemsItem items = 30;
  if (this->_internal_has_items()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.items_);
  }

  // .gnostic.openapi.v3.Properties properties = 31;
  if (this->_internal_has_properties()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.properties_);
  }

  // .gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32;
  if (this->_internal_has_additional_properties()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.additional_properties_);
  }

  // .gnostic.openapi.v3.DefaultType default = 33;
  if (this->_internal_has_default_()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default__);
  }

  // bool nullable = 1;
  if (this->_internal_nullable() != 0) {
    total_size += 1 + 1;
  }

  // bool read_only = 3;
  if (this->_internal_read_only() != 0) {
    total_size += 1 + 1;
  }

  // bool write_only = 4;
  if (this->_internal_write_only() != 0) {
    total_size += 1 + 1;
  }

  // bool deprecated = 8;
  if (this->_internal_deprecated() != 0) {
    total_size += 1 + 1;
  }

  // bool exclusive_maximum = 12;
  if (this->_internal_exclusive_maximum() != 0) {
    total_size += 1 + 1;
  }

  // bool exclusive_minimum = 14;
  if (this->_internal_exclusive_minimum() != 0) {
    total_size += 1 + 1;
  }

  // bool unique_items = 20;
  if (this->_internal_unique_items() != 0) {
    total_size += 2 + 1;
  }

  // double multiple_of = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_multiple_of = this->_internal_multiple_of();
  uint64_t raw_multiple_of;
  memcpy(&raw_multiple_of, &tmp_multiple_of, sizeof(tmp_multiple_of));
  if (raw_multiple_of != 0) {
    total_size += 1 + 8;
  }

  // double maximum = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maximum = this->_internal_maximum();
  uint64_t raw_maximum;
  memcpy(&raw_maximum, &tmp_maximum, sizeof(tmp_maximum));
  if (raw_maximum != 0) {
    total_size += 1 + 8;
  }

  // double minimum = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_minimum = this->_internal_minimum();
  uint64_t raw_minimum;
  memcpy(&raw_minimum, &tmp_minimum, sizeof(tmp_minimum));
  if (raw_minimum != 0) {
    total_size += 1 + 8;
  }

  // int64 max_length = 15;
  if (this->_internal_max_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_length());
  }

  // int64 min_length = 16;
  if (this->_internal_min_length() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_min_length());
  }

  // int64 max_items = 18;
  if (this->_internal_max_items() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_max_items());
  }

  // int64 min_items = 19;
  if (this->_internal_min_items() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_min_items());
  }

  // int64 max_properties = 21;
  if (this->_internal_max_properties() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_max_properties());
  }

  // int64 min_properties = 22;
  if (this->_internal_min_properties() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_min_properties());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Schema::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Schema::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Schema::GetClassData() const { return &_class_data_; }


void Schema::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Schema*>(&to_msg);
  auto& from = static_cast<const Schema&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Schema)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.required_.MergeFrom(from._impl_.required_);
  _this->_impl_.enum__.MergeFrom(from._impl_.enum__);
  _this->_impl_.all_of_.MergeFrom(from._impl_.all_of_);
  _this->_impl_.one_of_.MergeFrom(from._impl_.one_of_);
  _this->_impl_.any_of_.MergeFrom(from._impl_.any_of_);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_pattern().empty()) {
    _this->_internal_set_pattern(from._internal_pattern());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_format().empty()) {
    _this->_internal_set_format(from._internal_format());
  }
  if (from._internal_has_discriminator()) {
    _this->_internal_mutable_discriminator()->::gnostic::openapi::v3::Discriminator::MergeFrom(
        from._internal_discriminator());
  }
  if (from._internal_has_xml()) {
    _this->_internal_mutable_xml()->::gnostic::openapi::v3::Xml::MergeFrom(
        from._internal_xml());
  }
  if (from._internal_has_external_docs()) {
    _this->_internal_mutable_external_docs()->::gnostic::openapi::v3::ExternalDocs::MergeFrom(
        from._internal_external_docs());
  }
  if (from._internal_has_example()) {
    _this->_internal_mutable_example()->::gnostic::openapi::v3::Any::MergeFrom(
        from._internal_example());
  }
  if (from._internal_has_not_()) {
    _this->_internal_mutable_not_()->::gnostic::openapi::v3::Schema::MergeFrom(
        from._internal_not_());
  }
  if (from._internal_has_items()) {
    _this->_internal_mutable_items()->::gnostic::openapi::v3::ItemsItem::MergeFrom(
        from._internal_items());
  }
  if (from._internal_has_properties()) {
    _this->_internal_mutable_properties()->::gnostic::openapi::v3::Properties::MergeFrom(
        from._internal_properties());
  }
  if (from._internal_has_additional_properties()) {
    _this->_internal_mutable_additional_properties()->::gnostic::openapi::v3::AdditionalPropertiesItem::MergeFrom(
        from._internal_additional_properties());
  }
  if (from._internal_has_default_()) {
    _this->_internal_mutable_default_()->::gnostic::openapi::v3::DefaultType::MergeFrom(
        from._internal_default_());
  }
  if (from._internal_nullable() != 0) {
    _this->_internal_set_nullable(from._internal_nullable());
  }
  if (from._internal_read_only() != 0) {
    _this->_internal_set_read_only(from._internal_read_only());
  }
  if (from._internal_write_only() != 0) {
    _this->_internal_set_write_only(from._internal_write_only());
  }
  if (from._internal_deprecated() != 0) {
    _this->_internal_set_deprecated(from._internal_deprecated());
  }
  if (from._internal_exclusive_maximum() != 0) {
    _this->_internal_set_exclusive_maximum(from._internal_exclusive_maximum());
  }
  if (from._internal_exclusive_minimum() != 0) {
    _this->_internal_set_exclusive_minimum(from._internal_exclusive_minimum());
  }
  if (from._internal_unique_items() != 0) {
    _this->_internal_set_unique_items(from._internal_unique_items());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_multiple_of = from._internal_multiple_of();
  uint64_t raw_multiple_of;
  memcpy(&raw_multiple_of, &tmp_multiple_of, sizeof(tmp_multiple_of));
  if (raw_multiple_of != 0) {
    _this->_internal_set_multiple_of(from._internal_multiple_of());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_maximum = from._internal_maximum();
  uint64_t raw_maximum;
  memcpy(&raw_maximum, &tmp_maximum, sizeof(tmp_maximum));
  if (raw_maximum != 0) {
    _this->_internal_set_maximum(from._internal_maximum());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_minimum = from._internal_minimum();
  uint64_t raw_minimum;
  memcpy(&raw_minimum, &tmp_minimum, sizeof(tmp_minimum));
  if (raw_minimum != 0) {
    _this->_internal_set_minimum(from._internal_minimum());
  }
  if (from._internal_max_length() != 0) {
    _this->_internal_set_max_length(from._internal_max_length());
  }
  if (from._internal_min_length() != 0) {
    _this->_internal_set_min_length(from._internal_min_length());
  }
  if (from._internal_max_items() != 0) {
    _this->_internal_set_max_items(from._internal_max_items());
  }
  if (from._internal_min_items() != 0) {
    _this->_internal_set_min_items(from._internal_min_items());
  }
  if (from._internal_max_properties() != 0) {
    _this->_internal_set_max_properties(from._internal_max_properties());
  }
  if (from._internal_min_properties() != 0) {
    _this->_internal_set_min_properties(from._internal_min_properties());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Schema::CopyFrom(const Schema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Schema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Schema::IsInitialized() const {
  return true;
}

void Schema::InternalSwap(Schema* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.required_.InternalSwap(&other->_impl_.required_);
  _impl_.enum__.InternalSwap(&other->_impl_.enum__);
  _impl_.all_of_.InternalSwap(&other->_impl_.all_of_);
  _impl_.one_of_.InternalSwap(&other->_impl_.one_of_);
  _impl_.any_of_.InternalSwap(&other->_impl_.any_of_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pattern_, lhs_arena,
      &other->_impl_.pattern_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.format_, lhs_arena,
      &other->_impl_.format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Schema, _impl_.min_properties_)
      + sizeof(Schema::_impl_.min_properties_)
      - PROTOBUF_FIELD_OFFSET(Schema, _impl_.discriminator_)>(
          reinterpret_cast<char*>(&_impl_.discriminator_),
          reinterpret_cast<char*>(&other->_impl_.discriminator_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Schema::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[63]);
}

// ===================================================================

class SchemaOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::Schema& schema(const SchemaOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const SchemaOrReference* msg);
};

const ::gnostic::openapi::v3::Schema&
SchemaOrReference::_Internal::schema(const SchemaOrReference* msg) {
  return *msg->_impl_.oneof_.schema_;
}
const ::gnostic::openapi::v3::Reference&
SchemaOrReference::_Internal::reference(const SchemaOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void SchemaOrReference::set_allocated_schema(::gnostic::openapi::v3::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    set_has_schema();
    _impl_.oneof_.schema_ = schema;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SchemaOrReference.schema)
}
void SchemaOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SchemaOrReference.reference)
}
SchemaOrReference::SchemaOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.SchemaOrReference)
}
SchemaOrReference::SchemaOrReference(const SchemaOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchemaOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kSchema: {
      _this->_internal_mutable_schema()->::gnostic::openapi::v3::Schema::MergeFrom(
          from._internal_schema());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.SchemaOrReference)
}

inline void SchemaOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

SchemaOrReference::~SchemaOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.SchemaOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchemaOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void SchemaOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchemaOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.SchemaOrReference)
  switch (oneof_case()) {
    case kSchema: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.schema_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void SchemaOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.SchemaOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchemaOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.Schema schema = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchemaOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.SchemaOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.Schema schema = 1;
  if (_internal_has_schema()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.SchemaOrReference)
  return target;
}

size_t SchemaOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.SchemaOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.Schema schema = 1;
    case kSchema: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.schema_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchemaOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchemaOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchemaOrReference::GetClassData() const { return &_class_data_; }


void SchemaOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchemaOrReference*>(&to_msg);
  auto& from = static_cast<const SchemaOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.SchemaOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kSchema: {
      _this->_internal_mutable_schema()->::gnostic::openapi::v3::Schema::MergeFrom(
          from._internal_schema());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchemaOrReference::CopyFrom(const SchemaOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.SchemaOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchemaOrReference::IsInitialized() const {
  return true;
}

void SchemaOrReference::InternalSwap(SchemaOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SchemaOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[64]);
}

// ===================================================================

class SchemasOrReferences::_Internal {
 public:
};

SchemasOrReferences::SchemasOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.SchemasOrReferences)
}
SchemasOrReferences::SchemasOrReferences(const SchemasOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchemasOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.SchemasOrReferences)
}

inline void SchemasOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SchemasOrReferences::~SchemasOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.SchemasOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchemasOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void SchemasOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchemasOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.SchemasOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchemasOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchemasOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.SchemasOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.SchemasOrReferences)
  return target;
}

size_t SchemasOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.SchemasOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchemasOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchemasOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchemasOrReferences::GetClassData() const { return &_class_data_; }


void SchemasOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchemasOrReferences*>(&to_msg);
  auto& from = static_cast<const SchemasOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.SchemasOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchemasOrReferences::CopyFrom(const SchemasOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.SchemasOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchemasOrReferences::IsInitialized() const {
  return true;
}

void SchemasOrReferences::InternalSwap(SchemasOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SchemasOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[65]);
}

// ===================================================================

class SecurityRequirement::_Internal {
 public:
};

SecurityRequirement::SecurityRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.SecurityRequirement)
}
SecurityRequirement::SecurityRequirement(const SecurityRequirement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecurityRequirement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.SecurityRequirement)
}

inline void SecurityRequirement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SecurityRequirement::~SecurityRequirement() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.SecurityRequirement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecurityRequirement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void SecurityRequirement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecurityRequirement::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.SecurityRequirement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecurityRequirement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedStringArray additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecurityRequirement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.SecurityRequirement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedStringArray additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.SecurityRequirement)
  return target;
}

size_t SecurityRequirement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.SecurityRequirement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedStringArray additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecurityRequirement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecurityRequirement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecurityRequirement::GetClassData() const { return &_class_data_; }


void SecurityRequirement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecurityRequirement*>(&to_msg);
  auto& from = static_cast<const SecurityRequirement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.SecurityRequirement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecurityRequirement::CopyFrom(const SecurityRequirement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.SecurityRequirement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityRequirement::IsInitialized() const {
  return true;
}

void SecurityRequirement::InternalSwap(SecurityRequirement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecurityRequirement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[66]);
}

// ===================================================================

class SecurityScheme::_Internal {
 public:
  static const ::gnostic::openapi::v3::OauthFlows& flows(const SecurityScheme* msg);
};

const ::gnostic::openapi::v3::OauthFlows&
SecurityScheme::_Internal::flows(const SecurityScheme* msg) {
  return *msg->_impl_.flows_;
}
SecurityScheme::SecurityScheme(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.SecurityScheme)
}
SecurityScheme::SecurityScheme(const SecurityScheme& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecurityScheme* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.in_){}
    , decltype(_impl_.scheme_){}
    , decltype(_impl_.bearer_format_){}
    , decltype(_impl_.open_id_connect_url_){}
    , decltype(_impl_.flows_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.in_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.in_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_in().empty()) {
    _this->_impl_.in_.Set(from._internal_in(), 
      _this->GetArenaForAllocation());
  }
  _impl_.scheme_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scheme_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_scheme().empty()) {
    _this->_impl_.scheme_.Set(from._internal_scheme(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bearer_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bearer_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bearer_format().empty()) {
    _this->_impl_.bearer_format_.Set(from._internal_bearer_format(), 
      _this->GetArenaForAllocation());
  }
  _impl_.open_id_connect_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.open_id_connect_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_open_id_connect_url().empty()) {
    _this->_impl_.open_id_connect_url_.Set(from._internal_open_id_connect_url(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_flows()) {
    _this->_impl_.flows_ = new ::gnostic::openapi::v3::OauthFlows(*from._impl_.flows_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.SecurityScheme)
}

inline void SecurityScheme::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.type_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.in_){}
    , decltype(_impl_.scheme_){}
    , decltype(_impl_.bearer_format_){}
    , decltype(_impl_.open_id_connect_url_){}
    , decltype(_impl_.flows_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.in_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.in_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scheme_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scheme_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bearer_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bearer_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.open_id_connect_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.open_id_connect_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecurityScheme::~SecurityScheme() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.SecurityScheme)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecurityScheme::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.type_.Destroy();
  _impl_.description_.Destroy();
  _impl_.name_.Destroy();
  _impl_.in_.Destroy();
  _impl_.scheme_.Destroy();
  _impl_.bearer_format_.Destroy();
  _impl_.open_id_connect_url_.Destroy();
  if (this != internal_default_instance()) delete _impl_.flows_;
}

void SecurityScheme::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecurityScheme::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.SecurityScheme)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.type_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.in_.ClearToEmpty();
  _impl_.scheme_.ClearToEmpty();
  _impl_.bearer_format_.ClearToEmpty();
  _impl_.open_id_connect_url_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.flows_ != nullptr) {
    delete _impl_.flows_;
  }
  _impl_.flows_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecurityScheme::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SecurityScheme.type"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SecurityScheme.description"));
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SecurityScheme.name"));
        } else
          goto handle_unusual;
        continue;
      // string in = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_in();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SecurityScheme.in"));
        } else
          goto handle_unusual;
        continue;
      // string scheme = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_scheme();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SecurityScheme.scheme"));
        } else
          goto handle_unusual;
        continue;
      // string bearer_format = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_bearer_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SecurityScheme.bearer_format"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.OauthFlows flows = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_flows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string open_id_connect_url = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_open_id_connect_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SecurityScheme.open_id_connect_url"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecurityScheme::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.SecurityScheme)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SecurityScheme.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SecurityScheme.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SecurityScheme.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // string in = 4;
  if (!this->_internal_in().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_in().data(), static_cast<int>(this->_internal_in().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SecurityScheme.in");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_in(), target);
  }

  // string scheme = 5;
  if (!this->_internal_scheme().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_scheme().data(), static_cast<int>(this->_internal_scheme().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SecurityScheme.scheme");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_scheme(), target);
  }

  // string bearer_format = 6;
  if (!this->_internal_bearer_format().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bearer_format().data(), static_cast<int>(this->_internal_bearer_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SecurityScheme.bearer_format");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_bearer_format(), target);
  }

  // .gnostic.openapi.v3.OauthFlows flows = 7;
  if (this->_internal_has_flows()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::flows(this),
        _Internal::flows(this).GetCachedSize(), target, stream);
  }

  // string open_id_connect_url = 8;
  if (!this->_internal_open_id_connect_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_open_id_connect_url().data(), static_cast<int>(this->_internal_open_id_connect_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SecurityScheme.open_id_connect_url");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_open_id_connect_url(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.SecurityScheme)
  return target;
}

size_t SecurityScheme::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.SecurityScheme)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string type = 1;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string in = 4;
  if (!this->_internal_in().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_in());
  }

  // string scheme = 5;
  if (!this->_internal_scheme().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scheme());
  }

  // string bearer_format = 6;
  if (!this->_internal_bearer_format().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bearer_format());
  }

  // string open_id_connect_url = 8;
  if (!this->_internal_open_id_connect_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_open_id_connect_url());
  }

  // .gnostic.openapi.v3.OauthFlows flows = 7;
  if (this->_internal_has_flows()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flows_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecurityScheme::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecurityScheme::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecurityScheme::GetClassData() const { return &_class_data_; }


void SecurityScheme::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecurityScheme*>(&to_msg);
  auto& from = static_cast<const SecurityScheme&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.SecurityScheme)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_in().empty()) {
    _this->_internal_set_in(from._internal_in());
  }
  if (!from._internal_scheme().empty()) {
    _this->_internal_set_scheme(from._internal_scheme());
  }
  if (!from._internal_bearer_format().empty()) {
    _this->_internal_set_bearer_format(from._internal_bearer_format());
  }
  if (!from._internal_open_id_connect_url().empty()) {
    _this->_internal_set_open_id_connect_url(from._internal_open_id_connect_url());
  }
  if (from._internal_has_flows()) {
    _this->_internal_mutable_flows()->::gnostic::openapi::v3::OauthFlows::MergeFrom(
        from._internal_flows());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecurityScheme::CopyFrom(const SecurityScheme& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.SecurityScheme)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityScheme::IsInitialized() const {
  return true;
}

void SecurityScheme::InternalSwap(SecurityScheme* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.in_, lhs_arena,
      &other->_impl_.in_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scheme_, lhs_arena,
      &other->_impl_.scheme_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bearer_format_, lhs_arena,
      &other->_impl_.bearer_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.open_id_connect_url_, lhs_arena,
      &other->_impl_.open_id_connect_url_, rhs_arena
  );
  swap(_impl_.flows_, other->_impl_.flows_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecurityScheme::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[67]);
}

// ===================================================================

class SecuritySchemeOrReference::_Internal {
 public:
  static const ::gnostic::openapi::v3::SecurityScheme& security_scheme(const SecuritySchemeOrReference* msg);
  static const ::gnostic::openapi::v3::Reference& reference(const SecuritySchemeOrReference* msg);
};

const ::gnostic::openapi::v3::SecurityScheme&
SecuritySchemeOrReference::_Internal::security_scheme(const SecuritySchemeOrReference* msg) {
  return *msg->_impl_.oneof_.security_scheme_;
}
const ::gnostic::openapi::v3::Reference&
SecuritySchemeOrReference::_Internal::reference(const SecuritySchemeOrReference* msg) {
  return *msg->_impl_.oneof_.reference_;
}
void SecuritySchemeOrReference::set_allocated_security_scheme(::gnostic::openapi::v3::SecurityScheme* security_scheme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (security_scheme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security_scheme);
    if (message_arena != submessage_arena) {
      security_scheme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security_scheme, submessage_arena);
    }
    set_has_security_scheme();
    _impl_.oneof_.security_scheme_ = security_scheme;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecuritySchemeOrReference.security_scheme)
}
void SecuritySchemeOrReference::set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof();
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecuritySchemeOrReference.reference)
}
SecuritySchemeOrReference::SecuritySchemeOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.SecuritySchemeOrReference)
}
SecuritySchemeOrReference::SecuritySchemeOrReference(const SecuritySchemeOrReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecuritySchemeOrReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kSecurityScheme: {
      _this->_internal_mutable_security_scheme()->::gnostic::openapi::v3::SecurityScheme::MergeFrom(
          from._internal_security_scheme());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.SecuritySchemeOrReference)
}

inline void SecuritySchemeOrReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

SecuritySchemeOrReference::~SecuritySchemeOrReference() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.SecuritySchemeOrReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecuritySchemeOrReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void SecuritySchemeOrReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecuritySchemeOrReference::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.SecuritySchemeOrReference)
  switch (oneof_case()) {
    case kSecurityScheme: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.security_scheme_;
      }
      break;
    }
    case kReference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_.reference_;
      }
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void SecuritySchemeOrReference::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.SecuritySchemeOrReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecuritySchemeOrReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gnostic.openapi.v3.SecurityScheme security_scheme = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_security_scheme(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecuritySchemeOrReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.SecuritySchemeOrReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gnostic.openapi.v3.SecurityScheme security_scheme = 1;
  if (_internal_has_security_scheme()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::security_scheme(this),
        _Internal::security_scheme(this).GetCachedSize(), target, stream);
  }

  // .gnostic.openapi.v3.Reference reference = 2;
  if (_internal_has_reference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.SecuritySchemeOrReference)
  return target;
}

size_t SecuritySchemeOrReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.SecuritySchemeOrReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // .gnostic.openapi.v3.SecurityScheme security_scheme = 1;
    case kSecurityScheme: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.security_scheme_);
      break;
    }
    // .gnostic.openapi.v3.Reference reference = 2;
    case kReference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_.reference_);
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecuritySchemeOrReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecuritySchemeOrReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecuritySchemeOrReference::GetClassData() const { return &_class_data_; }


void SecuritySchemeOrReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecuritySchemeOrReference*>(&to_msg);
  auto& from = static_cast<const SecuritySchemeOrReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.SecuritySchemeOrReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kSecurityScheme: {
      _this->_internal_mutable_security_scheme()->::gnostic::openapi::v3::SecurityScheme::MergeFrom(
          from._internal_security_scheme());
      break;
    }
    case kReference: {
      _this->_internal_mutable_reference()->::gnostic::openapi::v3::Reference::MergeFrom(
          from._internal_reference());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecuritySchemeOrReference::CopyFrom(const SecuritySchemeOrReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.SecuritySchemeOrReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecuritySchemeOrReference::IsInitialized() const {
  return true;
}

void SecuritySchemeOrReference::InternalSwap(SecuritySchemeOrReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecuritySchemeOrReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[68]);
}

// ===================================================================

class SecuritySchemesOrReferences::_Internal {
 public:
};

SecuritySchemesOrReferences::SecuritySchemesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.SecuritySchemesOrReferences)
}
SecuritySchemesOrReferences::SecuritySchemesOrReferences(const SecuritySchemesOrReferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecuritySchemesOrReferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.SecuritySchemesOrReferences)
}

inline void SecuritySchemesOrReferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SecuritySchemesOrReferences::~SecuritySchemesOrReferences() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.SecuritySchemesOrReferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecuritySchemesOrReferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void SecuritySchemesOrReferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecuritySchemesOrReferences::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.SecuritySchemesOrReferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecuritySchemesOrReferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecuritySchemesOrReferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.SecuritySchemesOrReferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.SecuritySchemesOrReferences)
  return target;
}

size_t SecuritySchemesOrReferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.SecuritySchemesOrReferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecuritySchemesOrReferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecuritySchemesOrReferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecuritySchemesOrReferences::GetClassData() const { return &_class_data_; }


void SecuritySchemesOrReferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecuritySchemesOrReferences*>(&to_msg);
  auto& from = static_cast<const SecuritySchemesOrReferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.SecuritySchemesOrReferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecuritySchemesOrReferences::CopyFrom(const SecuritySchemesOrReferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.SecuritySchemesOrReferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecuritySchemesOrReferences::IsInitialized() const {
  return true;
}

void SecuritySchemesOrReferences::InternalSwap(SecuritySchemesOrReferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecuritySchemesOrReferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[69]);
}

// ===================================================================

class Server::_Internal {
 public:
  static const ::gnostic::openapi::v3::ServerVariables& variables(const Server* msg);
};

const ::gnostic::openapi::v3::ServerVariables&
Server::_Internal::variables(const Server* msg) {
  return *msg->_impl_.variables_;
}
Server::Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Server)
}
Server::Server(const Server& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Server* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.variables_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_variables()) {
    _this->_impl_.variables_ = new ::gnostic::openapi::v3::ServerVariables(*from._impl_.variables_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Server)
}

inline void Server::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.variables_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Server::~Server() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Server)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Server::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.url_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.variables_;
}

void Server::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Server::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Server)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.url_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.variables_ != nullptr) {
    delete _impl_.variables_;
  }
  _impl_.variables_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Server::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Server.url"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Server.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ServerVariables variables = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_variables(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Server::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Server)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string url = 1;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Server.url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Server.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.ServerVariables variables = 3;
  if (this->_internal_has_variables()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::variables(this),
        _Internal::variables(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Server)
  return target;
}

size_t Server::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Server)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string url = 1;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .gnostic.openapi.v3.ServerVariables variables = 3;
  if (this->_internal_has_variables()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.variables_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Server::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Server::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Server::GetClassData() const { return &_class_data_; }


void Server::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Server*>(&to_msg);
  auto& from = static_cast<const Server&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Server)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_variables()) {
    _this->_internal_mutable_variables()->::gnostic::openapi::v3::ServerVariables::MergeFrom(
        from._internal_variables());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Server::CopyFrom(const Server& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Server)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Server::IsInitialized() const {
  return true;
}

void Server::InternalSwap(Server* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  swap(_impl_.variables_, other->_impl_.variables_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Server::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[70]);
}

// ===================================================================

class ServerVariable::_Internal {
 public:
};

ServerVariable::ServerVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ServerVariable)
}
ServerVariable::ServerVariable(const ServerVariable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServerVariable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.enum__){from._impl_.enum__}
    , decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.default__){}
    , decltype(_impl_.description_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.default__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_().empty()) {
    _this->_impl_.default__.Set(from._internal_default_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ServerVariable)
}

inline void ServerVariable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.enum__){arena}
    , decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.default__){}
    , decltype(_impl_.description_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.default__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServerVariable::~ServerVariable() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ServerVariable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerVariable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.enum__.~RepeatedPtrField();
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.default__.Destroy();
  _impl_.description_.Destroy();
}

void ServerVariable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerVariable::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ServerVariable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enum__.Clear();
  _impl_.specification_extension_.Clear();
  _impl_.default__.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerVariable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string enum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_enum_();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.ServerVariable.enum"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string default = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_default_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.ServerVariable.default"));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.ServerVariable.description"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerVariable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ServerVariable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string enum = 1;
  for (int i = 0, n = this->_internal_enum__size(); i < n; i++) {
    const auto& s = this->_internal_enum_(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.ServerVariable.enum");
    target = stream->WriteString(1, s, target);
  }

  // string default = 2;
  if (!this->_internal_default_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_default_().data(), static_cast<int>(this->_internal_default_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.ServerVariable.default");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_default_(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.ServerVariable.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ServerVariable)
  return target;
}

size_t ServerVariable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ServerVariable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string enum = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.enum__.size());
  for (int i = 0, n = _impl_.enum__.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.enum__.Get(i));
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string default = 2;
  if (!this->_internal_default_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_default_());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerVariable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServerVariable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerVariable::GetClassData() const { return &_class_data_; }


void ServerVariable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServerVariable*>(&to_msg);
  auto& from = static_cast<const ServerVariable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ServerVariable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.enum__.MergeFrom(from._impl_.enum__);
  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_default_().empty()) {
    _this->_internal_set_default_(from._internal_default_());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerVariable::CopyFrom(const ServerVariable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ServerVariable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerVariable::IsInitialized() const {
  return true;
}

void ServerVariable::InternalSwap(ServerVariable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.enum__.InternalSwap(&other->_impl_.enum__);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.default__, lhs_arena,
      &other->_impl_.default__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerVariable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[71]);
}

// ===================================================================

class ServerVariables::_Internal {
 public:
};

ServerVariables::ServerVariables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.ServerVariables)
}
ServerVariables::ServerVariables(const ServerVariables& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServerVariables* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.ServerVariables)
}

inline void ServerVariables::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ServerVariables::~ServerVariables() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.ServerVariables)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerVariables::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void ServerVariables::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerVariables::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.ServerVariables)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerVariables::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedServerVariable additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerVariables::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.ServerVariables)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedServerVariable additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.ServerVariables)
  return target;
}

size_t ServerVariables::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.ServerVariables)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedServerVariable additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerVariables::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServerVariables::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerVariables::GetClassData() const { return &_class_data_; }


void ServerVariables::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServerVariables*>(&to_msg);
  auto& from = static_cast<const ServerVariables&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.ServerVariables)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerVariables::CopyFrom(const ServerVariables& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.ServerVariables)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerVariables::IsInitialized() const {
  return true;
}

void ServerVariables::InternalSwap(ServerVariables* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerVariables::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[72]);
}

// ===================================================================

class SpecificationExtension::_Internal {
 public:
};

SpecificationExtension::SpecificationExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.SpecificationExtension)
}
SpecificationExtension::SpecificationExtension(const SpecificationExtension& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecificationExtension* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_oneof();
  switch (from.oneof_case()) {
    case kNumber: {
      _this->_internal_set_number(from._internal_number());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case kString: {
      _this->_internal_set_string(from._internal_string());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.SpecificationExtension)
}

inline void SpecificationExtension::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof();
}

SpecificationExtension::~SpecificationExtension() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.SpecificationExtension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecificationExtension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_oneof()) {
    clear_oneof();
  }
}

void SpecificationExtension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecificationExtension::clear_oneof() {
// @@protoc_insertion_point(one_of_clear_start:gnostic.openapi.v3.SpecificationExtension)
  switch (oneof_case()) {
    case kNumber: {
      // No need to clear
      break;
    }
    case kBoolean: {
      // No need to clear
      break;
    }
    case kString: {
      _impl_.oneof_.string_.Destroy();
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}


void SpecificationExtension::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.SpecificationExtension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecificationExtension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _internal_set_number(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool boolean = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_boolean(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.SpecificationExtension.string"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecificationExtension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.SpecificationExtension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double number = 1;
  if (_internal_has_number()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_number(), target);
  }

  // bool boolean = 2;
  if (_internal_has_boolean()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_boolean(), target);
  }

  // string string = 3;
  if (_internal_has_string()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_string().data(), static_cast<int>(this->_internal_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.SpecificationExtension.string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.SpecificationExtension)
  return target;
}

size_t SpecificationExtension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.SpecificationExtension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (oneof_case()) {
    // double number = 1;
    case kNumber: {
      total_size += 1 + 8;
      break;
    }
    // bool boolean = 2;
    case kBoolean: {
      total_size += 1 + 1;
      break;
    }
    // string string = 3;
    case kString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecificationExtension::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecificationExtension::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecificationExtension::GetClassData() const { return &_class_data_; }


void SpecificationExtension::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecificationExtension*>(&to_msg);
  auto& from = static_cast<const SpecificationExtension&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.SpecificationExtension)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.oneof_case()) {
    case kNumber: {
      _this->_internal_set_number(from._internal_number());
      break;
    }
    case kBoolean: {
      _this->_internal_set_boolean(from._internal_boolean());
      break;
    }
    case kString: {
      _this->_internal_set_string(from._internal_string());
      break;
    }
    case ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecificationExtension::CopyFrom(const SpecificationExtension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.SpecificationExtension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecificationExtension::IsInitialized() const {
  return true;
}

void SpecificationExtension::InternalSwap(SpecificationExtension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oneof_, other->_impl_.oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecificationExtension::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[73]);
}

// ===================================================================

class StringArray::_Internal {
 public:
};

StringArray::StringArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.StringArray)
}
StringArray::StringArray(const StringArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StringArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){from._impl_.value_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.StringArray)
}

inline void StringArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StringArray::~StringArray() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.StringArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StringArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.~RepeatedPtrField();
}

void StringArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StringArray::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.StringArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StringArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_value();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.StringArray.value"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.StringArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string value = 1;
  for (int i = 0, n = this->_internal_value_size(); i < n; i++) {
    const auto& s = this->_internal_value(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.StringArray.value");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.StringArray)
  return target;
}

size_t StringArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.StringArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string value = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.value_.size());
  for (int i = 0, n = _impl_.value_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.value_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StringArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StringArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StringArray::GetClassData() const { return &_class_data_; }


void StringArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StringArray*>(&to_msg);
  auto& from = static_cast<const StringArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.StringArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.value_.MergeFrom(from._impl_.value_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StringArray::CopyFrom(const StringArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.StringArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringArray::IsInitialized() const {
  return true;
}

void StringArray::InternalSwap(StringArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.value_.InternalSwap(&other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StringArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[74]);
}

// ===================================================================

class Strings::_Internal {
 public:
};

Strings::Strings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Strings)
}
Strings::Strings(const Strings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Strings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){from._impl_.additional_properties_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Strings)
}

inline void Strings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.additional_properties_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Strings::~Strings() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Strings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Strings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_properties_.~RepeatedPtrField();
}

void Strings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Strings::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Strings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_properties_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Strings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gnostic.openapi.v3.NamedString additional_properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Strings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Strings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedString additional_properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Strings)
  return target;
}

size_t Strings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Strings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedString additional_properties = 1;
  total_size += 1UL * this->_internal_additional_properties_size();
  for (const auto& msg : this->_impl_.additional_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Strings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Strings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Strings::GetClassData() const { return &_class_data_; }


void Strings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Strings*>(&to_msg);
  auto& from = static_cast<const Strings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Strings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_properties_.MergeFrom(from._impl_.additional_properties_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Strings::CopyFrom(const Strings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Strings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Strings::IsInitialized() const {
  return true;
}

void Strings::InternalSwap(Strings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_properties_.InternalSwap(&other->_impl_.additional_properties_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Strings::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[75]);
}

// ===================================================================

class Tag::_Internal {
 public:
  static const ::gnostic::openapi::v3::ExternalDocs& external_docs(const Tag* msg);
};

const ::gnostic::openapi::v3::ExternalDocs&
Tag::_Internal::external_docs(const Tag* msg) {
  return *msg->_impl_.external_docs_;
}
Tag::Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Tag)
}
Tag::Tag(const Tag& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tag* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.external_docs_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_external_docs()) {
    _this->_impl_.external_docs_ = new ::gnostic::openapi::v3::ExternalDocs(*from._impl_.external_docs_);
  }
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Tag)
}

inline void Tag::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.external_docs_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Tag::~Tag() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Tag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.external_docs_;
}

void Tag::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tag::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Tag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Tag.name"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Tag.description"));
        } else
          goto handle_unusual;
        continue;
      // .gnostic.openapi.v3.ExternalDocs external_docs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_docs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Tag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Tag.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Tag.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 3;
  if (this->_internal_has_external_docs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::external_docs(this),
        _Internal::external_docs(this).GetCachedSize(), target, stream);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Tag)
  return target;
}

size_t Tag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Tag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .gnostic.openapi.v3.ExternalDocs external_docs = 3;
  if (this->_internal_has_external_docs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.external_docs_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tag::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tag::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tag::GetClassData() const { return &_class_data_; }


void Tag::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tag*>(&to_msg);
  auto& from = static_cast<const Tag&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Tag)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_external_docs()) {
    _this->_internal_mutable_external_docs()->::gnostic::openapi::v3::ExternalDocs::MergeFrom(
        from._internal_external_docs());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tag::CopyFrom(const Tag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Tag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tag::IsInitialized() const {
  return true;
}

void Tag::InternalSwap(Tag* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  swap(_impl_.external_docs_, other->_impl_.external_docs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Tag::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[76]);
}

// ===================================================================

class Xml::_Internal {
 public:
};

Xml::Xml(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gnostic.openapi.v3.Xml)
}
Xml::Xml(const Xml& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Xml* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){from._impl_.specification_extension_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.namespace__){}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.attribute_){}
    , decltype(_impl_.wrapped_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_namespace_().empty()) {
    _this->_impl_.namespace__.Set(from._internal_namespace_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_prefix().empty()) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.attribute_, &from._impl_.attribute_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.wrapped_) -
    reinterpret_cast<char*>(&_impl_.attribute_)) + sizeof(_impl_.wrapped_));
  // @@protoc_insertion_point(copy_constructor:gnostic.openapi.v3.Xml)
}

inline void Xml::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.specification_extension_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.namespace__){}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.attribute_){false}
    , decltype(_impl_.wrapped_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Xml::~Xml() {
  // @@protoc_insertion_point(destructor:gnostic.openapi.v3.Xml)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Xml::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.specification_extension_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.namespace__.Destroy();
  _impl_.prefix_.Destroy();
}

void Xml::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Xml::Clear() {
// @@protoc_insertion_point(message_clear_start:gnostic.openapi.v3.Xml)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.specification_extension_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.namespace__.ClearToEmpty();
  _impl_.prefix_.ClearToEmpty();
  ::memset(&_impl_.attribute_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.wrapped_) -
      reinterpret_cast<char*>(&_impl_.attribute_)) + sizeof(_impl_.wrapped_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Xml::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Xml.name"));
        } else
          goto handle_unusual;
        continue;
      // string namespace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_namespace_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Xml.namespace"));
        } else
          goto handle_unusual;
        continue;
      // string prefix = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gnostic.openapi.v3.Xml.prefix"));
        } else
          goto handle_unusual;
        continue;
      // bool attribute = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.attribute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool wrapped = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.wrapped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_specification_extension(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Xml::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnostic.openapi.v3.Xml)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Xml.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string namespace = 2;
  if (!this->_internal_namespace_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_namespace_().data(), static_cast<int>(this->_internal_namespace_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Xml.namespace");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_namespace_(), target);
  }

  // string prefix = 3;
  if (!this->_internal_prefix().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_prefix().data(), static_cast<int>(this->_internal_prefix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gnostic.openapi.v3.Xml.prefix");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_prefix(), target);
  }

  // bool attribute = 4;
  if (this->_internal_attribute() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_attribute(), target);
  }

  // bool wrapped = 5;
  if (this->_internal_wrapped() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_wrapped(), target);
  }

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_specification_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_specification_extension(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnostic.openapi.v3.Xml)
  return target;
}

size_t Xml::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gnostic.openapi.v3.Xml)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
  total_size += 1UL * this->_internal_specification_extension_size();
  for (const auto& msg : this->_impl_.specification_extension_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string namespace = 2;
  if (!this->_internal_namespace_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_namespace_());
  }

  // string prefix = 3;
  if (!this->_internal_prefix().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_prefix());
  }

  // bool attribute = 4;
  if (this->_internal_attribute() != 0) {
    total_size += 1 + 1;
  }

  // bool wrapped = 5;
  if (this->_internal_wrapped() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Xml::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Xml::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Xml::GetClassData() const { return &_class_data_; }


void Xml::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Xml*>(&to_msg);
  auto& from = static_cast<const Xml&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gnostic.openapi.v3.Xml)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.specification_extension_.MergeFrom(from._impl_.specification_extension_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_namespace_().empty()) {
    _this->_internal_set_namespace_(from._internal_namespace_());
  }
  if (!from._internal_prefix().empty()) {
    _this->_internal_set_prefix(from._internal_prefix());
  }
  if (from._internal_attribute() != 0) {
    _this->_internal_set_attribute(from._internal_attribute());
  }
  if (from._internal_wrapped() != 0) {
    _this->_internal_set_wrapped(from._internal_wrapped());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Xml::CopyFrom(const Xml& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gnostic.openapi.v3.Xml)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Xml::IsInitialized() const {
  return true;
}

void Xml::InternalSwap(Xml* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.specification_extension_.InternalSwap(&other->_impl_.specification_extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.namespace__, lhs_arena,
      &other->_impl_.namespace__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prefix_, lhs_arena,
      &other->_impl_.prefix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Xml, _impl_.wrapped_)
      + sizeof(Xml::_impl_.wrapped_)
      - PROTOBUF_FIELD_OFFSET(Xml, _impl_.attribute_)>(
          reinterpret_cast<char*>(&_impl_.attribute_),
          reinterpret_cast<char*>(&other->_impl_.attribute_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Xml::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_getter, &descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto_once,
      file_level_metadata_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto[77]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v3
}  // namespace openapi
}  // namespace gnostic
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::AdditionalPropertiesItem*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::AdditionalPropertiesItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::AdditionalPropertiesItem >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Any*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Any >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Any >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::AnyOrExpression*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::AnyOrExpression >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::AnyOrExpression >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Callback*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Callback >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Callback >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::CallbackOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::CallbackOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::CallbackOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::CallbacksOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::CallbacksOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::CallbacksOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Components*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Components >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Components >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Contact*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Contact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Contact >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::DefaultType*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::DefaultType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::DefaultType >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Discriminator*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Discriminator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Discriminator >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Document*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Document >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Document >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Encoding*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Encoding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Encoding >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Encodings*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Encodings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Encodings >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Example*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Example >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Example >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ExampleOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ExampleOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ExampleOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ExamplesOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ExamplesOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ExamplesOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Expression*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Expression >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Expression >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ExternalDocs*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ExternalDocs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ExternalDocs >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Header*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Header >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Header >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::HeaderOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::HeaderOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::HeaderOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::HeadersOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::HeadersOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::HeadersOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Info*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Info >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ItemsItem*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ItemsItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ItemsItem >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::License*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::License >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::License >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Link*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Link >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Link >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::LinkOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::LinkOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::LinkOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::LinksOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::LinksOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::LinksOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::MediaType*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::MediaType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::MediaType >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::MediaTypes*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::MediaTypes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::MediaTypes >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedAny*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedAny >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedAny >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedCallbackOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedCallbackOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedCallbackOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedEncoding*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedEncoding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedEncoding >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedExampleOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedExampleOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedExampleOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedHeaderOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedHeaderOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedHeaderOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedLinkOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedLinkOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedLinkOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedMediaType*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedMediaType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedMediaType >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedParameterOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedParameterOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedParameterOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedPathItem*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedPathItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedPathItem >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedRequestBodyOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedRequestBodyOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedRequestBodyOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedResponseOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedResponseOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedResponseOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedSchemaOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedSchemaOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedSchemaOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedSecuritySchemeOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedSecuritySchemeOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedSecuritySchemeOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedServerVariable*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedServerVariable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedServerVariable >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedString*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedString >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::NamedStringArray*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::NamedStringArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::NamedStringArray >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::OauthFlow*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::OauthFlow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::OauthFlow >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::OauthFlows*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::OauthFlows >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::OauthFlows >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Object*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Object >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Object >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Operation*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Operation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Operation >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Parameter*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Parameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Parameter >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ParameterOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ParameterOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ParameterOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ParametersOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ParametersOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ParametersOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::PathItem*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::PathItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::PathItem >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Paths*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Paths >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Paths >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Properties*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Properties >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Properties >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Reference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Reference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::RequestBodiesOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::RequestBodiesOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::RequestBodiesOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::RequestBody*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::RequestBody >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::RequestBody >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::RequestBodyOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::RequestBodyOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::RequestBodyOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Response*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Response >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ResponseOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ResponseOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ResponseOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Responses*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Responses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Responses >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ResponsesOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ResponsesOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ResponsesOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Schema*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Schema >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Schema >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::SchemaOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::SchemaOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::SchemaOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::SchemasOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::SchemasOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::SchemasOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::SecurityRequirement*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::SecurityRequirement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::SecurityRequirement >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::SecurityScheme*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::SecurityScheme >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::SecurityScheme >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::SecuritySchemeOrReference*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::SecuritySchemeOrReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::SecuritySchemeOrReference >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::SecuritySchemesOrReferences*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::SecuritySchemesOrReferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::SecuritySchemesOrReferences >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Server*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Server >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Server >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ServerVariable*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ServerVariable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ServerVariable >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::ServerVariables*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::ServerVariables >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::ServerVariables >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::SpecificationExtension*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::SpecificationExtension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::SpecificationExtension >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::StringArray*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::StringArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::StringArray >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Strings*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Strings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Strings >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Tag*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Tag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Tag >(arena);
}
template<> PROTOBUF_NOINLINE ::gnostic::openapi::v3::Xml*
Arena::CreateMaybeMessage< ::gnostic::openapi::v3::Xml >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gnostic::openapi::v3::Xml >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

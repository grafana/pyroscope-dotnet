// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gnostic/openapi/v3/openapiv3.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
namespace gnostic {
namespace openapi {
namespace v3 {
class AdditionalPropertiesItem;
struct AdditionalPropertiesItemDefaultTypeInternal;
extern AdditionalPropertiesItemDefaultTypeInternal _AdditionalPropertiesItem_default_instance_;
class Any;
struct AnyDefaultTypeInternal;
extern AnyDefaultTypeInternal _Any_default_instance_;
class AnyOrExpression;
struct AnyOrExpressionDefaultTypeInternal;
extern AnyOrExpressionDefaultTypeInternal _AnyOrExpression_default_instance_;
class Callback;
struct CallbackDefaultTypeInternal;
extern CallbackDefaultTypeInternal _Callback_default_instance_;
class CallbackOrReference;
struct CallbackOrReferenceDefaultTypeInternal;
extern CallbackOrReferenceDefaultTypeInternal _CallbackOrReference_default_instance_;
class CallbacksOrReferences;
struct CallbacksOrReferencesDefaultTypeInternal;
extern CallbacksOrReferencesDefaultTypeInternal _CallbacksOrReferences_default_instance_;
class Components;
struct ComponentsDefaultTypeInternal;
extern ComponentsDefaultTypeInternal _Components_default_instance_;
class Contact;
struct ContactDefaultTypeInternal;
extern ContactDefaultTypeInternal _Contact_default_instance_;
class DefaultType;
struct DefaultTypeDefaultTypeInternal;
extern DefaultTypeDefaultTypeInternal _DefaultType_default_instance_;
class Discriminator;
struct DiscriminatorDefaultTypeInternal;
extern DiscriminatorDefaultTypeInternal _Discriminator_default_instance_;
class Document;
struct DocumentDefaultTypeInternal;
extern DocumentDefaultTypeInternal _Document_default_instance_;
class Encoding;
struct EncodingDefaultTypeInternal;
extern EncodingDefaultTypeInternal _Encoding_default_instance_;
class Encodings;
struct EncodingsDefaultTypeInternal;
extern EncodingsDefaultTypeInternal _Encodings_default_instance_;
class Example;
struct ExampleDefaultTypeInternal;
extern ExampleDefaultTypeInternal _Example_default_instance_;
class ExampleOrReference;
struct ExampleOrReferenceDefaultTypeInternal;
extern ExampleOrReferenceDefaultTypeInternal _ExampleOrReference_default_instance_;
class ExamplesOrReferences;
struct ExamplesOrReferencesDefaultTypeInternal;
extern ExamplesOrReferencesDefaultTypeInternal _ExamplesOrReferences_default_instance_;
class Expression;
struct ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class ExternalDocs;
struct ExternalDocsDefaultTypeInternal;
extern ExternalDocsDefaultTypeInternal _ExternalDocs_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class HeaderOrReference;
struct HeaderOrReferenceDefaultTypeInternal;
extern HeaderOrReferenceDefaultTypeInternal _HeaderOrReference_default_instance_;
class HeadersOrReferences;
struct HeadersOrReferencesDefaultTypeInternal;
extern HeadersOrReferencesDefaultTypeInternal _HeadersOrReferences_default_instance_;
class Info;
struct InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class ItemsItem;
struct ItemsItemDefaultTypeInternal;
extern ItemsItemDefaultTypeInternal _ItemsItem_default_instance_;
class License;
struct LicenseDefaultTypeInternal;
extern LicenseDefaultTypeInternal _License_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class LinkOrReference;
struct LinkOrReferenceDefaultTypeInternal;
extern LinkOrReferenceDefaultTypeInternal _LinkOrReference_default_instance_;
class LinksOrReferences;
struct LinksOrReferencesDefaultTypeInternal;
extern LinksOrReferencesDefaultTypeInternal _LinksOrReferences_default_instance_;
class MediaType;
struct MediaTypeDefaultTypeInternal;
extern MediaTypeDefaultTypeInternal _MediaType_default_instance_;
class MediaTypes;
struct MediaTypesDefaultTypeInternal;
extern MediaTypesDefaultTypeInternal _MediaTypes_default_instance_;
class NamedAny;
struct NamedAnyDefaultTypeInternal;
extern NamedAnyDefaultTypeInternal _NamedAny_default_instance_;
class NamedCallbackOrReference;
struct NamedCallbackOrReferenceDefaultTypeInternal;
extern NamedCallbackOrReferenceDefaultTypeInternal _NamedCallbackOrReference_default_instance_;
class NamedEncoding;
struct NamedEncodingDefaultTypeInternal;
extern NamedEncodingDefaultTypeInternal _NamedEncoding_default_instance_;
class NamedExampleOrReference;
struct NamedExampleOrReferenceDefaultTypeInternal;
extern NamedExampleOrReferenceDefaultTypeInternal _NamedExampleOrReference_default_instance_;
class NamedHeaderOrReference;
struct NamedHeaderOrReferenceDefaultTypeInternal;
extern NamedHeaderOrReferenceDefaultTypeInternal _NamedHeaderOrReference_default_instance_;
class NamedLinkOrReference;
struct NamedLinkOrReferenceDefaultTypeInternal;
extern NamedLinkOrReferenceDefaultTypeInternal _NamedLinkOrReference_default_instance_;
class NamedMediaType;
struct NamedMediaTypeDefaultTypeInternal;
extern NamedMediaTypeDefaultTypeInternal _NamedMediaType_default_instance_;
class NamedParameterOrReference;
struct NamedParameterOrReferenceDefaultTypeInternal;
extern NamedParameterOrReferenceDefaultTypeInternal _NamedParameterOrReference_default_instance_;
class NamedPathItem;
struct NamedPathItemDefaultTypeInternal;
extern NamedPathItemDefaultTypeInternal _NamedPathItem_default_instance_;
class NamedRequestBodyOrReference;
struct NamedRequestBodyOrReferenceDefaultTypeInternal;
extern NamedRequestBodyOrReferenceDefaultTypeInternal _NamedRequestBodyOrReference_default_instance_;
class NamedResponseOrReference;
struct NamedResponseOrReferenceDefaultTypeInternal;
extern NamedResponseOrReferenceDefaultTypeInternal _NamedResponseOrReference_default_instance_;
class NamedSchemaOrReference;
struct NamedSchemaOrReferenceDefaultTypeInternal;
extern NamedSchemaOrReferenceDefaultTypeInternal _NamedSchemaOrReference_default_instance_;
class NamedSecuritySchemeOrReference;
struct NamedSecuritySchemeOrReferenceDefaultTypeInternal;
extern NamedSecuritySchemeOrReferenceDefaultTypeInternal _NamedSecuritySchemeOrReference_default_instance_;
class NamedServerVariable;
struct NamedServerVariableDefaultTypeInternal;
extern NamedServerVariableDefaultTypeInternal _NamedServerVariable_default_instance_;
class NamedString;
struct NamedStringDefaultTypeInternal;
extern NamedStringDefaultTypeInternal _NamedString_default_instance_;
class NamedStringArray;
struct NamedStringArrayDefaultTypeInternal;
extern NamedStringArrayDefaultTypeInternal _NamedStringArray_default_instance_;
class OauthFlow;
struct OauthFlowDefaultTypeInternal;
extern OauthFlowDefaultTypeInternal _OauthFlow_default_instance_;
class OauthFlows;
struct OauthFlowsDefaultTypeInternal;
extern OauthFlowsDefaultTypeInternal _OauthFlows_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class Parameter;
struct ParameterDefaultTypeInternal;
extern ParameterDefaultTypeInternal _Parameter_default_instance_;
class ParameterOrReference;
struct ParameterOrReferenceDefaultTypeInternal;
extern ParameterOrReferenceDefaultTypeInternal _ParameterOrReference_default_instance_;
class ParametersOrReferences;
struct ParametersOrReferencesDefaultTypeInternal;
extern ParametersOrReferencesDefaultTypeInternal _ParametersOrReferences_default_instance_;
class PathItem;
struct PathItemDefaultTypeInternal;
extern PathItemDefaultTypeInternal _PathItem_default_instance_;
class Paths;
struct PathsDefaultTypeInternal;
extern PathsDefaultTypeInternal _Paths_default_instance_;
class Properties;
struct PropertiesDefaultTypeInternal;
extern PropertiesDefaultTypeInternal _Properties_default_instance_;
class Reference;
struct ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class RequestBodiesOrReferences;
struct RequestBodiesOrReferencesDefaultTypeInternal;
extern RequestBodiesOrReferencesDefaultTypeInternal _RequestBodiesOrReferences_default_instance_;
class RequestBody;
struct RequestBodyDefaultTypeInternal;
extern RequestBodyDefaultTypeInternal _RequestBody_default_instance_;
class RequestBodyOrReference;
struct RequestBodyOrReferenceDefaultTypeInternal;
extern RequestBodyOrReferenceDefaultTypeInternal _RequestBodyOrReference_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseOrReference;
struct ResponseOrReferenceDefaultTypeInternal;
extern ResponseOrReferenceDefaultTypeInternal _ResponseOrReference_default_instance_;
class Responses;
struct ResponsesDefaultTypeInternal;
extern ResponsesDefaultTypeInternal _Responses_default_instance_;
class ResponsesOrReferences;
struct ResponsesOrReferencesDefaultTypeInternal;
extern ResponsesOrReferencesDefaultTypeInternal _ResponsesOrReferences_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SchemaOrReference;
struct SchemaOrReferenceDefaultTypeInternal;
extern SchemaOrReferenceDefaultTypeInternal _SchemaOrReference_default_instance_;
class SchemasOrReferences;
struct SchemasOrReferencesDefaultTypeInternal;
extern SchemasOrReferencesDefaultTypeInternal _SchemasOrReferences_default_instance_;
class SecurityRequirement;
struct SecurityRequirementDefaultTypeInternal;
extern SecurityRequirementDefaultTypeInternal _SecurityRequirement_default_instance_;
class SecurityScheme;
struct SecuritySchemeDefaultTypeInternal;
extern SecuritySchemeDefaultTypeInternal _SecurityScheme_default_instance_;
class SecuritySchemeOrReference;
struct SecuritySchemeOrReferenceDefaultTypeInternal;
extern SecuritySchemeOrReferenceDefaultTypeInternal _SecuritySchemeOrReference_default_instance_;
class SecuritySchemesOrReferences;
struct SecuritySchemesOrReferencesDefaultTypeInternal;
extern SecuritySchemesOrReferencesDefaultTypeInternal _SecuritySchemesOrReferences_default_instance_;
class Server;
struct ServerDefaultTypeInternal;
extern ServerDefaultTypeInternal _Server_default_instance_;
class ServerVariable;
struct ServerVariableDefaultTypeInternal;
extern ServerVariableDefaultTypeInternal _ServerVariable_default_instance_;
class ServerVariables;
struct ServerVariablesDefaultTypeInternal;
extern ServerVariablesDefaultTypeInternal _ServerVariables_default_instance_;
class SpecificationExtension;
struct SpecificationExtensionDefaultTypeInternal;
extern SpecificationExtensionDefaultTypeInternal _SpecificationExtension_default_instance_;
class StringArray;
struct StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class Strings;
struct StringsDefaultTypeInternal;
extern StringsDefaultTypeInternal _Strings_default_instance_;
class Tag;
struct TagDefaultTypeInternal;
extern TagDefaultTypeInternal _Tag_default_instance_;
class Xml;
struct XmlDefaultTypeInternal;
extern XmlDefaultTypeInternal _Xml_default_instance_;
}  // namespace v3
}  // namespace openapi
}  // namespace gnostic
PROTOBUF_NAMESPACE_OPEN
template<> ::gnostic::openapi::v3::AdditionalPropertiesItem* Arena::CreateMaybeMessage<::gnostic::openapi::v3::AdditionalPropertiesItem>(Arena*);
template<> ::gnostic::openapi::v3::Any* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Any>(Arena*);
template<> ::gnostic::openapi::v3::AnyOrExpression* Arena::CreateMaybeMessage<::gnostic::openapi::v3::AnyOrExpression>(Arena*);
template<> ::gnostic::openapi::v3::Callback* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Callback>(Arena*);
template<> ::gnostic::openapi::v3::CallbackOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::CallbackOrReference>(Arena*);
template<> ::gnostic::openapi::v3::CallbacksOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::CallbacksOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::Components* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Components>(Arena*);
template<> ::gnostic::openapi::v3::Contact* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Contact>(Arena*);
template<> ::gnostic::openapi::v3::DefaultType* Arena::CreateMaybeMessage<::gnostic::openapi::v3::DefaultType>(Arena*);
template<> ::gnostic::openapi::v3::Discriminator* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Discriminator>(Arena*);
template<> ::gnostic::openapi::v3::Document* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Document>(Arena*);
template<> ::gnostic::openapi::v3::Encoding* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Encoding>(Arena*);
template<> ::gnostic::openapi::v3::Encodings* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Encodings>(Arena*);
template<> ::gnostic::openapi::v3::Example* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Example>(Arena*);
template<> ::gnostic::openapi::v3::ExampleOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ExampleOrReference>(Arena*);
template<> ::gnostic::openapi::v3::ExamplesOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ExamplesOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::Expression* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Expression>(Arena*);
template<> ::gnostic::openapi::v3::ExternalDocs* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ExternalDocs>(Arena*);
template<> ::gnostic::openapi::v3::Header* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Header>(Arena*);
template<> ::gnostic::openapi::v3::HeaderOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::HeaderOrReference>(Arena*);
template<> ::gnostic::openapi::v3::HeadersOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::HeadersOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::Info* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Info>(Arena*);
template<> ::gnostic::openapi::v3::ItemsItem* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ItemsItem>(Arena*);
template<> ::gnostic::openapi::v3::License* Arena::CreateMaybeMessage<::gnostic::openapi::v3::License>(Arena*);
template<> ::gnostic::openapi::v3::Link* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Link>(Arena*);
template<> ::gnostic::openapi::v3::LinkOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::LinkOrReference>(Arena*);
template<> ::gnostic::openapi::v3::LinksOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::LinksOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::MediaType* Arena::CreateMaybeMessage<::gnostic::openapi::v3::MediaType>(Arena*);
template<> ::gnostic::openapi::v3::MediaTypes* Arena::CreateMaybeMessage<::gnostic::openapi::v3::MediaTypes>(Arena*);
template<> ::gnostic::openapi::v3::NamedAny* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedAny>(Arena*);
template<> ::gnostic::openapi::v3::NamedCallbackOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedCallbackOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedEncoding* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedEncoding>(Arena*);
template<> ::gnostic::openapi::v3::NamedExampleOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedExampleOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedHeaderOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedHeaderOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedLinkOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedLinkOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedMediaType* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedMediaType>(Arena*);
template<> ::gnostic::openapi::v3::NamedParameterOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedParameterOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedPathItem* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedPathItem>(Arena*);
template<> ::gnostic::openapi::v3::NamedRequestBodyOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedRequestBodyOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedResponseOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedResponseOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedSchemaOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedSchemaOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedSecuritySchemeOrReference>(Arena*);
template<> ::gnostic::openapi::v3::NamedServerVariable* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedServerVariable>(Arena*);
template<> ::gnostic::openapi::v3::NamedString* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedString>(Arena*);
template<> ::gnostic::openapi::v3::NamedStringArray* Arena::CreateMaybeMessage<::gnostic::openapi::v3::NamedStringArray>(Arena*);
template<> ::gnostic::openapi::v3::OauthFlow* Arena::CreateMaybeMessage<::gnostic::openapi::v3::OauthFlow>(Arena*);
template<> ::gnostic::openapi::v3::OauthFlows* Arena::CreateMaybeMessage<::gnostic::openapi::v3::OauthFlows>(Arena*);
template<> ::gnostic::openapi::v3::Object* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Object>(Arena*);
template<> ::gnostic::openapi::v3::Operation* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Operation>(Arena*);
template<> ::gnostic::openapi::v3::Parameter* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Parameter>(Arena*);
template<> ::gnostic::openapi::v3::ParameterOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ParameterOrReference>(Arena*);
template<> ::gnostic::openapi::v3::ParametersOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ParametersOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::PathItem* Arena::CreateMaybeMessage<::gnostic::openapi::v3::PathItem>(Arena*);
template<> ::gnostic::openapi::v3::Paths* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Paths>(Arena*);
template<> ::gnostic::openapi::v3::Properties* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Properties>(Arena*);
template<> ::gnostic::openapi::v3::Reference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Reference>(Arena*);
template<> ::gnostic::openapi::v3::RequestBodiesOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::RequestBodiesOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::RequestBody* Arena::CreateMaybeMessage<::gnostic::openapi::v3::RequestBody>(Arena*);
template<> ::gnostic::openapi::v3::RequestBodyOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::RequestBodyOrReference>(Arena*);
template<> ::gnostic::openapi::v3::Response* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Response>(Arena*);
template<> ::gnostic::openapi::v3::ResponseOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ResponseOrReference>(Arena*);
template<> ::gnostic::openapi::v3::Responses* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Responses>(Arena*);
template<> ::gnostic::openapi::v3::ResponsesOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ResponsesOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::Schema* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Schema>(Arena*);
template<> ::gnostic::openapi::v3::SchemaOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::SchemaOrReference>(Arena*);
template<> ::gnostic::openapi::v3::SchemasOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::SchemasOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::SecurityRequirement* Arena::CreateMaybeMessage<::gnostic::openapi::v3::SecurityRequirement>(Arena*);
template<> ::gnostic::openapi::v3::SecurityScheme* Arena::CreateMaybeMessage<::gnostic::openapi::v3::SecurityScheme>(Arena*);
template<> ::gnostic::openapi::v3::SecuritySchemeOrReference* Arena::CreateMaybeMessage<::gnostic::openapi::v3::SecuritySchemeOrReference>(Arena*);
template<> ::gnostic::openapi::v3::SecuritySchemesOrReferences* Arena::CreateMaybeMessage<::gnostic::openapi::v3::SecuritySchemesOrReferences>(Arena*);
template<> ::gnostic::openapi::v3::Server* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Server>(Arena*);
template<> ::gnostic::openapi::v3::ServerVariable* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ServerVariable>(Arena*);
template<> ::gnostic::openapi::v3::ServerVariables* Arena::CreateMaybeMessage<::gnostic::openapi::v3::ServerVariables>(Arena*);
template<> ::gnostic::openapi::v3::SpecificationExtension* Arena::CreateMaybeMessage<::gnostic::openapi::v3::SpecificationExtension>(Arena*);
template<> ::gnostic::openapi::v3::StringArray* Arena::CreateMaybeMessage<::gnostic::openapi::v3::StringArray>(Arena*);
template<> ::gnostic::openapi::v3::Strings* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Strings>(Arena*);
template<> ::gnostic::openapi::v3::Tag* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Tag>(Arena*);
template<> ::gnostic::openapi::v3::Xml* Arena::CreateMaybeMessage<::gnostic::openapi::v3::Xml>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gnostic {
namespace openapi {
namespace v3 {

// ===================================================================

class AdditionalPropertiesItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.AdditionalPropertiesItem) */ {
 public:
  inline AdditionalPropertiesItem() : AdditionalPropertiesItem(nullptr) {}
  ~AdditionalPropertiesItem() override;
  explicit PROTOBUF_CONSTEXPR AdditionalPropertiesItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdditionalPropertiesItem(const AdditionalPropertiesItem& from);
  AdditionalPropertiesItem(AdditionalPropertiesItem&& from) noexcept
    : AdditionalPropertiesItem() {
    *this = ::std::move(from);
  }

  inline AdditionalPropertiesItem& operator=(const AdditionalPropertiesItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalPropertiesItem& operator=(AdditionalPropertiesItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdditionalPropertiesItem& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kSchemaOrReference = 1,
    kBoolean = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const AdditionalPropertiesItem* internal_default_instance() {
    return reinterpret_cast<const AdditionalPropertiesItem*>(
               &_AdditionalPropertiesItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AdditionalPropertiesItem& a, AdditionalPropertiesItem& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalPropertiesItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalPropertiesItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdditionalPropertiesItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdditionalPropertiesItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdditionalPropertiesItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdditionalPropertiesItem& from) {
    AdditionalPropertiesItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalPropertiesItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.AdditionalPropertiesItem";
  }
  protected:
  explicit AdditionalPropertiesItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaOrReferenceFieldNumber = 1,
    kBooleanFieldNumber = 2,
  };
  // .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
  bool has_schema_or_reference() const;
  private:
  bool _internal_has_schema_or_reference() const;
  public:
  void clear_schema_or_reference();
  const ::gnostic::openapi::v3::SchemaOrReference& schema_or_reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SchemaOrReference* release_schema_or_reference();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_schema_or_reference();
  void set_allocated_schema_or_reference(::gnostic::openapi::v3::SchemaOrReference* schema_or_reference);
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_schema_or_reference() const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_mutable_schema_or_reference();
  public:
  void unsafe_arena_set_allocated_schema_or_reference(
      ::gnostic::openapi::v3::SchemaOrReference* schema_or_reference);
  ::gnostic::openapi::v3::SchemaOrReference* unsafe_arena_release_schema_or_reference();

  // bool boolean = 2;
  bool has_boolean() const;
  private:
  bool _internal_has_boolean() const;
  public:
  void clear_boolean();
  bool boolean() const;
  void set_boolean(bool value);
  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);
  public:

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.AdditionalPropertiesItem)
 private:
  class _Internal;
  void set_has_schema_or_reference();
  void set_has_boolean();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::SchemaOrReference* schema_or_reference_;
      bool boolean_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Any final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Any) */ {
 public:
  inline Any() : Any(nullptr) {}
  ~Any() override;
  explicit PROTOBUF_CONSTEXPR Any(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Any(const Any& from);
  Any(Any&& from) noexcept
    : Any() {
    *this = ::std::move(from);
  }

  inline Any& operator=(const Any& from) {
    CopyFrom(from);
    return *this;
  }
  inline Any& operator=(Any&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Any& default_instance() {
    return *internal_default_instance();
  }
  static inline const Any* internal_default_instance() {
    return reinterpret_cast<const Any*>(
               &_Any_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Any& a, Any& b) {
    a.Swap(&b);
  }
  inline void Swap(Any* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Any* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Any* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Any>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Any& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Any& from) {
    Any::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Any* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Any";
  }
  protected:
  explicit Any(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYamlFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // string yaml = 2;
  void clear_yaml();
  const std::string& yaml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_yaml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_yaml();
  PROTOBUF_NODISCARD std::string* release_yaml();
  void set_allocated_yaml(std::string* yaml);
  private:
  const std::string& _internal_yaml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_yaml(const std::string& value);
  std::string* _internal_mutable_yaml();
  public:

  // .google.protobuf.Any value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::Any* value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Any)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr yaml_;
    ::PROTOBUF_NAMESPACE_ID::Any* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class AnyOrExpression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.AnyOrExpression) */ {
 public:
  inline AnyOrExpression() : AnyOrExpression(nullptr) {}
  ~AnyOrExpression() override;
  explicit PROTOBUF_CONSTEXPR AnyOrExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnyOrExpression(const AnyOrExpression& from);
  AnyOrExpression(AnyOrExpression&& from) noexcept
    : AnyOrExpression() {
    *this = ::std::move(from);
  }

  inline AnyOrExpression& operator=(const AnyOrExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyOrExpression& operator=(AnyOrExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyOrExpression& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kAny = 1,
    kExpression = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const AnyOrExpression* internal_default_instance() {
    return reinterpret_cast<const AnyOrExpression*>(
               &_AnyOrExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AnyOrExpression& a, AnyOrExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyOrExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyOrExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnyOrExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnyOrExpression>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnyOrExpression& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnyOrExpression& from) {
    AnyOrExpression::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyOrExpression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.AnyOrExpression";
  }
  protected:
  explicit AnyOrExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnyFieldNumber = 1,
    kExpressionFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Any any = 1;
  bool has_any() const;
  private:
  bool _internal_has_any() const;
  public:
  void clear_any();
  const ::gnostic::openapi::v3::Any& any() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Any* release_any();
  ::gnostic::openapi::v3::Any* mutable_any();
  void set_allocated_any(::gnostic::openapi::v3::Any* any);
  private:
  const ::gnostic::openapi::v3::Any& _internal_any() const;
  ::gnostic::openapi::v3::Any* _internal_mutable_any();
  public:
  void unsafe_arena_set_allocated_any(
      ::gnostic::openapi::v3::Any* any);
  ::gnostic::openapi::v3::Any* unsafe_arena_release_any();

  // .gnostic.openapi.v3.Expression expression = 2;
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;
  public:
  void clear_expression();
  const ::gnostic::openapi::v3::Expression& expression() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Expression* release_expression();
  ::gnostic::openapi::v3::Expression* mutable_expression();
  void set_allocated_expression(::gnostic::openapi::v3::Expression* expression);
  private:
  const ::gnostic::openapi::v3::Expression& _internal_expression() const;
  ::gnostic::openapi::v3::Expression* _internal_mutable_expression();
  public:
  void unsafe_arena_set_allocated_expression(
      ::gnostic::openapi::v3::Expression* expression);
  ::gnostic::openapi::v3::Expression* unsafe_arena_release_expression();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.AnyOrExpression)
 private:
  class _Internal;
  void set_has_any();
  void set_has_expression();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Any* any_;
      ::gnostic::openapi::v3::Expression* expression_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Callback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Callback) */ {
 public:
  inline Callback() : Callback(nullptr) {}
  ~Callback() override;
  explicit PROTOBUF_CONSTEXPR Callback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Callback(const Callback& from);
  Callback(Callback&& from) noexcept
    : Callback() {
    *this = ::std::move(from);
  }

  inline Callback& operator=(const Callback& from) {
    CopyFrom(from);
    return *this;
  }
  inline Callback& operator=(Callback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Callback& default_instance() {
    return *internal_default_instance();
  }
  static inline const Callback* internal_default_instance() {
    return reinterpret_cast<const Callback*>(
               &_Callback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Callback& a, Callback& b) {
    a.Swap(&b);
  }
  inline void Swap(Callback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Callback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Callback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Callback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Callback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Callback& from) {
    Callback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Callback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Callback";
  }
  protected:
  explicit Callback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kSpecificationExtensionFieldNumber = 2,
  };
  // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  ::gnostic::openapi::v3::NamedPathItem* mutable_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >*
      mutable_path();
  private:
  const ::gnostic::openapi::v3::NamedPathItem& _internal_path(int index) const;
  ::gnostic::openapi::v3::NamedPathItem* _internal_add_path();
  public:
  const ::gnostic::openapi::v3::NamedPathItem& path(int index) const;
  ::gnostic::openapi::v3::NamedPathItem* add_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >&
      path() const;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Callback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem > path_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class CallbackOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.CallbackOrReference) */ {
 public:
  inline CallbackOrReference() : CallbackOrReference(nullptr) {}
  ~CallbackOrReference() override;
  explicit PROTOBUF_CONSTEXPR CallbackOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbackOrReference(const CallbackOrReference& from);
  CallbackOrReference(CallbackOrReference&& from) noexcept
    : CallbackOrReference() {
    *this = ::std::move(from);
  }

  inline CallbackOrReference& operator=(const CallbackOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbackOrReference& operator=(CallbackOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallbackOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kCallback = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const CallbackOrReference* internal_default_instance() {
    return reinterpret_cast<const CallbackOrReference*>(
               &_CallbackOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CallbackOrReference& a, CallbackOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(CallbackOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbackOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbackOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbackOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallbackOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallbackOrReference& from) {
    CallbackOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallbackOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.CallbackOrReference";
  }
  protected:
  explicit CallbackOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallbackFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Callback callback = 1;
  bool has_callback() const;
  private:
  bool _internal_has_callback() const;
  public:
  void clear_callback();
  const ::gnostic::openapi::v3::Callback& callback() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Callback* release_callback();
  ::gnostic::openapi::v3::Callback* mutable_callback();
  void set_allocated_callback(::gnostic::openapi::v3::Callback* callback);
  private:
  const ::gnostic::openapi::v3::Callback& _internal_callback() const;
  ::gnostic::openapi::v3::Callback* _internal_mutable_callback();
  public:
  void unsafe_arena_set_allocated_callback(
      ::gnostic::openapi::v3::Callback* callback);
  ::gnostic::openapi::v3::Callback* unsafe_arena_release_callback();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.CallbackOrReference)
 private:
  class _Internal;
  void set_has_callback();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Callback* callback_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class CallbacksOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.CallbacksOrReferences) */ {
 public:
  inline CallbacksOrReferences() : CallbacksOrReferences(nullptr) {}
  ~CallbacksOrReferences() override;
  explicit PROTOBUF_CONSTEXPR CallbacksOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbacksOrReferences(const CallbacksOrReferences& from);
  CallbacksOrReferences(CallbacksOrReferences&& from) noexcept
    : CallbacksOrReferences() {
    *this = ::std::move(from);
  }

  inline CallbacksOrReferences& operator=(const CallbacksOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbacksOrReferences& operator=(CallbacksOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallbacksOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallbacksOrReferences* internal_default_instance() {
    return reinterpret_cast<const CallbacksOrReferences*>(
               &_CallbacksOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CallbacksOrReferences& a, CallbacksOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(CallbacksOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbacksOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbacksOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbacksOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallbacksOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallbacksOrReferences& from) {
    CallbacksOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallbacksOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.CallbacksOrReferences";
  }
  protected:
  explicit CallbacksOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedCallbackOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedCallbackOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedCallbackOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedCallbackOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedCallbackOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedCallbackOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedCallbackOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.CallbacksOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedCallbackOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Components final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Components) */ {
 public:
  inline Components() : Components(nullptr) {}
  ~Components() override;
  explicit PROTOBUF_CONSTEXPR Components(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Components(const Components& from);
  Components(Components&& from) noexcept
    : Components() {
    *this = ::std::move(from);
  }

  inline Components& operator=(const Components& from) {
    CopyFrom(from);
    return *this;
  }
  inline Components& operator=(Components&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Components& default_instance() {
    return *internal_default_instance();
  }
  static inline const Components* internal_default_instance() {
    return reinterpret_cast<const Components*>(
               &_Components_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Components& a, Components& b) {
    a.Swap(&b);
  }
  inline void Swap(Components* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Components* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Components* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Components>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Components& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Components& from) {
    Components::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Components* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Components";
  }
  protected:
  explicit Components(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 10,
    kSchemasFieldNumber = 1,
    kResponsesFieldNumber = 2,
    kParametersFieldNumber = 3,
    kExamplesFieldNumber = 4,
    kRequestBodiesFieldNumber = 5,
    kHeadersFieldNumber = 6,
    kSecuritySchemesFieldNumber = 7,
    kLinksFieldNumber = 8,
    kCallbacksFieldNumber = 9,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 10;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // .gnostic.openapi.v3.SchemasOrReferences schemas = 1;
  bool has_schemas() const;
  private:
  bool _internal_has_schemas() const;
  public:
  void clear_schemas();
  const ::gnostic::openapi::v3::SchemasOrReferences& schemas() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SchemasOrReferences* release_schemas();
  ::gnostic::openapi::v3::SchemasOrReferences* mutable_schemas();
  void set_allocated_schemas(::gnostic::openapi::v3::SchemasOrReferences* schemas);
  private:
  const ::gnostic::openapi::v3::SchemasOrReferences& _internal_schemas() const;
  ::gnostic::openapi::v3::SchemasOrReferences* _internal_mutable_schemas();
  public:
  void unsafe_arena_set_allocated_schemas(
      ::gnostic::openapi::v3::SchemasOrReferences* schemas);
  ::gnostic::openapi::v3::SchemasOrReferences* unsafe_arena_release_schemas();

  // .gnostic.openapi.v3.ResponsesOrReferences responses = 2;
  bool has_responses() const;
  private:
  bool _internal_has_responses() const;
  public:
  void clear_responses();
  const ::gnostic::openapi::v3::ResponsesOrReferences& responses() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ResponsesOrReferences* release_responses();
  ::gnostic::openapi::v3::ResponsesOrReferences* mutable_responses();
  void set_allocated_responses(::gnostic::openapi::v3::ResponsesOrReferences* responses);
  private:
  const ::gnostic::openapi::v3::ResponsesOrReferences& _internal_responses() const;
  ::gnostic::openapi::v3::ResponsesOrReferences* _internal_mutable_responses();
  public:
  void unsafe_arena_set_allocated_responses(
      ::gnostic::openapi::v3::ResponsesOrReferences* responses);
  ::gnostic::openapi::v3::ResponsesOrReferences* unsafe_arena_release_responses();

  // .gnostic.openapi.v3.ParametersOrReferences parameters = 3;
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::gnostic::openapi::v3::ParametersOrReferences& parameters() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ParametersOrReferences* release_parameters();
  ::gnostic::openapi::v3::ParametersOrReferences* mutable_parameters();
  void set_allocated_parameters(::gnostic::openapi::v3::ParametersOrReferences* parameters);
  private:
  const ::gnostic::openapi::v3::ParametersOrReferences& _internal_parameters() const;
  ::gnostic::openapi::v3::ParametersOrReferences* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::gnostic::openapi::v3::ParametersOrReferences* parameters);
  ::gnostic::openapi::v3::ParametersOrReferences* unsafe_arena_release_parameters();

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 4;
  bool has_examples() const;
  private:
  bool _internal_has_examples() const;
  public:
  void clear_examples();
  const ::gnostic::openapi::v3::ExamplesOrReferences& examples() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExamplesOrReferences* release_examples();
  ::gnostic::openapi::v3::ExamplesOrReferences* mutable_examples();
  void set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples);
  private:
  const ::gnostic::openapi::v3::ExamplesOrReferences& _internal_examples() const;
  ::gnostic::openapi::v3::ExamplesOrReferences* _internal_mutable_examples();
  public:
  void unsafe_arena_set_allocated_examples(
      ::gnostic::openapi::v3::ExamplesOrReferences* examples);
  ::gnostic::openapi::v3::ExamplesOrReferences* unsafe_arena_release_examples();

  // .gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5;
  bool has_request_bodies() const;
  private:
  bool _internal_has_request_bodies() const;
  public:
  void clear_request_bodies();
  const ::gnostic::openapi::v3::RequestBodiesOrReferences& request_bodies() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::RequestBodiesOrReferences* release_request_bodies();
  ::gnostic::openapi::v3::RequestBodiesOrReferences* mutable_request_bodies();
  void set_allocated_request_bodies(::gnostic::openapi::v3::RequestBodiesOrReferences* request_bodies);
  private:
  const ::gnostic::openapi::v3::RequestBodiesOrReferences& _internal_request_bodies() const;
  ::gnostic::openapi::v3::RequestBodiesOrReferences* _internal_mutable_request_bodies();
  public:
  void unsafe_arena_set_allocated_request_bodies(
      ::gnostic::openapi::v3::RequestBodiesOrReferences* request_bodies);
  ::gnostic::openapi::v3::RequestBodiesOrReferences* unsafe_arena_release_request_bodies();

  // .gnostic.openapi.v3.HeadersOrReferences headers = 6;
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;
  public:
  void clear_headers();
  const ::gnostic::openapi::v3::HeadersOrReferences& headers() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::HeadersOrReferences* release_headers();
  ::gnostic::openapi::v3::HeadersOrReferences* mutable_headers();
  void set_allocated_headers(::gnostic::openapi::v3::HeadersOrReferences* headers);
  private:
  const ::gnostic::openapi::v3::HeadersOrReferences& _internal_headers() const;
  ::gnostic::openapi::v3::HeadersOrReferences* _internal_mutable_headers();
  public:
  void unsafe_arena_set_allocated_headers(
      ::gnostic::openapi::v3::HeadersOrReferences* headers);
  ::gnostic::openapi::v3::HeadersOrReferences* unsafe_arena_release_headers();

  // .gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7;
  bool has_security_schemes() const;
  private:
  bool _internal_has_security_schemes() const;
  public:
  void clear_security_schemes();
  const ::gnostic::openapi::v3::SecuritySchemesOrReferences& security_schemes() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SecuritySchemesOrReferences* release_security_schemes();
  ::gnostic::openapi::v3::SecuritySchemesOrReferences* mutable_security_schemes();
  void set_allocated_security_schemes(::gnostic::openapi::v3::SecuritySchemesOrReferences* security_schemes);
  private:
  const ::gnostic::openapi::v3::SecuritySchemesOrReferences& _internal_security_schemes() const;
  ::gnostic::openapi::v3::SecuritySchemesOrReferences* _internal_mutable_security_schemes();
  public:
  void unsafe_arena_set_allocated_security_schemes(
      ::gnostic::openapi::v3::SecuritySchemesOrReferences* security_schemes);
  ::gnostic::openapi::v3::SecuritySchemesOrReferences* unsafe_arena_release_security_schemes();

  // .gnostic.openapi.v3.LinksOrReferences links = 8;
  bool has_links() const;
  private:
  bool _internal_has_links() const;
  public:
  void clear_links();
  const ::gnostic::openapi::v3::LinksOrReferences& links() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::LinksOrReferences* release_links();
  ::gnostic::openapi::v3::LinksOrReferences* mutable_links();
  void set_allocated_links(::gnostic::openapi::v3::LinksOrReferences* links);
  private:
  const ::gnostic::openapi::v3::LinksOrReferences& _internal_links() const;
  ::gnostic::openapi::v3::LinksOrReferences* _internal_mutable_links();
  public:
  void unsafe_arena_set_allocated_links(
      ::gnostic::openapi::v3::LinksOrReferences* links);
  ::gnostic::openapi::v3::LinksOrReferences* unsafe_arena_release_links();

  // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
  bool has_callbacks() const;
  private:
  bool _internal_has_callbacks() const;
  public:
  void clear_callbacks();
  const ::gnostic::openapi::v3::CallbacksOrReferences& callbacks() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::CallbacksOrReferences* release_callbacks();
  ::gnostic::openapi::v3::CallbacksOrReferences* mutable_callbacks();
  void set_allocated_callbacks(::gnostic::openapi::v3::CallbacksOrReferences* callbacks);
  private:
  const ::gnostic::openapi::v3::CallbacksOrReferences& _internal_callbacks() const;
  ::gnostic::openapi::v3::CallbacksOrReferences* _internal_mutable_callbacks();
  public:
  void unsafe_arena_set_allocated_callbacks(
      ::gnostic::openapi::v3::CallbacksOrReferences* callbacks);
  ::gnostic::openapi::v3::CallbacksOrReferences* unsafe_arena_release_callbacks();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Components)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::gnostic::openapi::v3::SchemasOrReferences* schemas_;
    ::gnostic::openapi::v3::ResponsesOrReferences* responses_;
    ::gnostic::openapi::v3::ParametersOrReferences* parameters_;
    ::gnostic::openapi::v3::ExamplesOrReferences* examples_;
    ::gnostic::openapi::v3::RequestBodiesOrReferences* request_bodies_;
    ::gnostic::openapi::v3::HeadersOrReferences* headers_;
    ::gnostic::openapi::v3::SecuritySchemesOrReferences* security_schemes_;
    ::gnostic::openapi::v3::LinksOrReferences* links_;
    ::gnostic::openapi::v3::CallbacksOrReferences* callbacks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Contact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Contact) */ {
 public:
  inline Contact() : Contact(nullptr) {}
  ~Contact() override;
  explicit PROTOBUF_CONSTEXPR Contact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contact(const Contact& from);
  Contact(Contact&& from) noexcept
    : Contact() {
    *this = ::std::move(from);
  }

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact& operator=(Contact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contact* internal_default_instance() {
    return reinterpret_cast<const Contact*>(
               &_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Contact& a, Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Contact& from) {
    Contact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Contact";
  }
  protected:
  explicit Contact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 4,
    kNameFieldNumber = 1,
    kUrlFieldNumber = 2,
    kEmailFieldNumber = 3,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string email = 3;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Contact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class DefaultType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.DefaultType) */ {
 public:
  inline DefaultType() : DefaultType(nullptr) {}
  ~DefaultType() override;
  explicit PROTOBUF_CONSTEXPR DefaultType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultType(const DefaultType& from);
  DefaultType(DefaultType&& from) noexcept
    : DefaultType() {
    *this = ::std::move(from);
  }

  inline DefaultType& operator=(const DefaultType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultType& operator=(DefaultType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultType& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kNumber = 1,
    kBoolean = 2,
    kString = 3,
    ONEOF_NOT_SET = 0,
  };

  static inline const DefaultType* internal_default_instance() {
    return reinterpret_cast<const DefaultType*>(
               &_DefaultType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DefaultType& a, DefaultType& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultType& from) {
    DefaultType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.DefaultType";
  }
  protected:
  explicit DefaultType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kBooleanFieldNumber = 2,
    kStringFieldNumber = 3,
  };
  // double number = 1;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  double number() const;
  void set_number(double value);
  private:
  double _internal_number() const;
  void _internal_set_number(double value);
  public:

  // bool boolean = 2;
  bool has_boolean() const;
  private:
  bool _internal_has_boolean() const;
  public:
  void clear_boolean();
  bool boolean() const;
  void set_boolean(bool value);
  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);
  public:

  // string string = 3;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const std::string& string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* string);
  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.DefaultType)
 private:
  class _Internal;
  void set_has_number();
  void set_has_boolean();
  void set_has_string();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double number_;
      bool boolean_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Discriminator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Discriminator) */ {
 public:
  inline Discriminator() : Discriminator(nullptr) {}
  ~Discriminator() override;
  explicit PROTOBUF_CONSTEXPR Discriminator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Discriminator(const Discriminator& from);
  Discriminator(Discriminator&& from) noexcept
    : Discriminator() {
    *this = ::std::move(from);
  }

  inline Discriminator& operator=(const Discriminator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Discriminator& operator=(Discriminator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Discriminator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Discriminator* internal_default_instance() {
    return reinterpret_cast<const Discriminator*>(
               &_Discriminator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Discriminator& a, Discriminator& b) {
    a.Swap(&b);
  }
  inline void Swap(Discriminator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Discriminator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Discriminator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Discriminator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Discriminator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Discriminator& from) {
    Discriminator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Discriminator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Discriminator";
  }
  protected:
  explicit Discriminator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 3,
    kPropertyNameFieldNumber = 1,
    kMappingFieldNumber = 2,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string property_name = 1;
  void clear_property_name();
  const std::string& property_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_property_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_property_name();
  PROTOBUF_NODISCARD std::string* release_property_name();
  void set_allocated_property_name(std::string* property_name);
  private:
  const std::string& _internal_property_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_property_name(const std::string& value);
  std::string* _internal_mutable_property_name();
  public:

  // .gnostic.openapi.v3.Strings mapping = 2;
  bool has_mapping() const;
  private:
  bool _internal_has_mapping() const;
  public:
  void clear_mapping();
  const ::gnostic::openapi::v3::Strings& mapping() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Strings* release_mapping();
  ::gnostic::openapi::v3::Strings* mutable_mapping();
  void set_allocated_mapping(::gnostic::openapi::v3::Strings* mapping);
  private:
  const ::gnostic::openapi::v3::Strings& _internal_mapping() const;
  ::gnostic::openapi::v3::Strings* _internal_mutable_mapping();
  public:
  void unsafe_arena_set_allocated_mapping(
      ::gnostic::openapi::v3::Strings* mapping);
  ::gnostic::openapi::v3::Strings* unsafe_arena_release_mapping();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Discriminator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_name_;
    ::gnostic::openapi::v3::Strings* mapping_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Document final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Document) */ {
 public:
  inline Document() : Document(nullptr) {}
  ~Document() override;
  explicit PROTOBUF_CONSTEXPR Document(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Document(const Document& from);
  Document(Document&& from) noexcept
    : Document() {
    *this = ::std::move(from);
  }

  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  inline Document& operator=(Document&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Document& default_instance() {
    return *internal_default_instance();
  }
  static inline const Document* internal_default_instance() {
    return reinterpret_cast<const Document*>(
               &_Document_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Document& a, Document& b) {
    a.Swap(&b);
  }
  inline void Swap(Document* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Document* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Document* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Document>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Document& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Document& from) {
    Document::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Document* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Document";
  }
  protected:
  explicit Document(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 3,
    kSecurityFieldNumber = 6,
    kTagsFieldNumber = 7,
    kSpecificationExtensionFieldNumber = 9,
    kOpenapiFieldNumber = 1,
    kInfoFieldNumber = 2,
    kPathsFieldNumber = 4,
    kComponentsFieldNumber = 5,
    kExternalDocsFieldNumber = 8,
  };
  // repeated .gnostic.openapi.v3.Server servers = 3;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::gnostic::openapi::v3::Server* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >*
      mutable_servers();
  private:
  const ::gnostic::openapi::v3::Server& _internal_servers(int index) const;
  ::gnostic::openapi::v3::Server* _internal_add_servers();
  public:
  const ::gnostic::openapi::v3::Server& servers(int index) const;
  ::gnostic::openapi::v3::Server* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >&
      servers() const;

  // repeated .gnostic.openapi.v3.SecurityRequirement security = 6;
  int security_size() const;
  private:
  int _internal_security_size() const;
  public:
  void clear_security();
  ::gnostic::openapi::v3::SecurityRequirement* mutable_security(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >*
      mutable_security();
  private:
  const ::gnostic::openapi::v3::SecurityRequirement& _internal_security(int index) const;
  ::gnostic::openapi::v3::SecurityRequirement* _internal_add_security();
  public:
  const ::gnostic::openapi::v3::SecurityRequirement& security(int index) const;
  ::gnostic::openapi::v3::SecurityRequirement* add_security();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >&
      security() const;

  // repeated .gnostic.openapi.v3.Tag tags = 7;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::gnostic::openapi::v3::Tag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Tag >*
      mutable_tags();
  private:
  const ::gnostic::openapi::v3::Tag& _internal_tags(int index) const;
  ::gnostic::openapi::v3::Tag* _internal_add_tags();
  public:
  const ::gnostic::openapi::v3::Tag& tags(int index) const;
  ::gnostic::openapi::v3::Tag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Tag >&
      tags() const;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string openapi = 1;
  void clear_openapi();
  const std::string& openapi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_openapi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_openapi();
  PROTOBUF_NODISCARD std::string* release_openapi();
  void set_allocated_openapi(std::string* openapi);
  private:
  const std::string& _internal_openapi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_openapi(const std::string& value);
  std::string* _internal_mutable_openapi();
  public:

  // .gnostic.openapi.v3.Info info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::gnostic::openapi::v3::Info& info() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Info* release_info();
  ::gnostic::openapi::v3::Info* mutable_info();
  void set_allocated_info(::gnostic::openapi::v3::Info* info);
  private:
  const ::gnostic::openapi::v3::Info& _internal_info() const;
  ::gnostic::openapi::v3::Info* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::gnostic::openapi::v3::Info* info);
  ::gnostic::openapi::v3::Info* unsafe_arena_release_info();

  // .gnostic.openapi.v3.Paths paths = 4;
  bool has_paths() const;
  private:
  bool _internal_has_paths() const;
  public:
  void clear_paths();
  const ::gnostic::openapi::v3::Paths& paths() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Paths* release_paths();
  ::gnostic::openapi::v3::Paths* mutable_paths();
  void set_allocated_paths(::gnostic::openapi::v3::Paths* paths);
  private:
  const ::gnostic::openapi::v3::Paths& _internal_paths() const;
  ::gnostic::openapi::v3::Paths* _internal_mutable_paths();
  public:
  void unsafe_arena_set_allocated_paths(
      ::gnostic::openapi::v3::Paths* paths);
  ::gnostic::openapi::v3::Paths* unsafe_arena_release_paths();

  // .gnostic.openapi.v3.Components components = 5;
  bool has_components() const;
  private:
  bool _internal_has_components() const;
  public:
  void clear_components();
  const ::gnostic::openapi::v3::Components& components() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Components* release_components();
  ::gnostic::openapi::v3::Components* mutable_components();
  void set_allocated_components(::gnostic::openapi::v3::Components* components);
  private:
  const ::gnostic::openapi::v3::Components& _internal_components() const;
  ::gnostic::openapi::v3::Components* _internal_mutable_components();
  public:
  void unsafe_arena_set_allocated_components(
      ::gnostic::openapi::v3::Components* components);
  ::gnostic::openapi::v3::Components* unsafe_arena_release_components();

  // .gnostic.openapi.v3.ExternalDocs external_docs = 8;
  bool has_external_docs() const;
  private:
  bool _internal_has_external_docs() const;
  public:
  void clear_external_docs();
  const ::gnostic::openapi::v3::ExternalDocs& external_docs() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExternalDocs* release_external_docs();
  ::gnostic::openapi::v3::ExternalDocs* mutable_external_docs();
  void set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs);
  private:
  const ::gnostic::openapi::v3::ExternalDocs& _internal_external_docs() const;
  ::gnostic::openapi::v3::ExternalDocs* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::gnostic::openapi::v3::ExternalDocs* external_docs);
  ::gnostic::openapi::v3::ExternalDocs* unsafe_arena_release_external_docs();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Document)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server > servers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement > security_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Tag > tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr openapi_;
    ::gnostic::openapi::v3::Info* info_;
    ::gnostic::openapi::v3::Paths* paths_;
    ::gnostic::openapi::v3::Components* components_;
    ::gnostic::openapi::v3::ExternalDocs* external_docs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Encoding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Encoding) */ {
 public:
  inline Encoding() : Encoding(nullptr) {}
  ~Encoding() override;
  explicit PROTOBUF_CONSTEXPR Encoding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Encoding(const Encoding& from);
  Encoding(Encoding&& from) noexcept
    : Encoding() {
    *this = ::std::move(from);
  }

  inline Encoding& operator=(const Encoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Encoding& operator=(Encoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Encoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const Encoding* internal_default_instance() {
    return reinterpret_cast<const Encoding*>(
               &_Encoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Encoding& a, Encoding& b) {
    a.Swap(&b);
  }
  inline void Swap(Encoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Encoding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Encoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Encoding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Encoding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Encoding& from) {
    Encoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Encoding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Encoding";
  }
  protected:
  explicit Encoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 6,
    kContentTypeFieldNumber = 1,
    kStyleFieldNumber = 3,
    kHeadersFieldNumber = 2,
    kExplodeFieldNumber = 4,
    kAllowReservedFieldNumber = 5,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string content_type = 1;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // string style = 3;
  void clear_style();
  const std::string& style() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_style(ArgT0&& arg0, ArgT... args);
  std::string* mutable_style();
  PROTOBUF_NODISCARD std::string* release_style();
  void set_allocated_style(std::string* style);
  private:
  const std::string& _internal_style() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_style(const std::string& value);
  std::string* _internal_mutable_style();
  public:

  // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;
  public:
  void clear_headers();
  const ::gnostic::openapi::v3::HeadersOrReferences& headers() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::HeadersOrReferences* release_headers();
  ::gnostic::openapi::v3::HeadersOrReferences* mutable_headers();
  void set_allocated_headers(::gnostic::openapi::v3::HeadersOrReferences* headers);
  private:
  const ::gnostic::openapi::v3::HeadersOrReferences& _internal_headers() const;
  ::gnostic::openapi::v3::HeadersOrReferences* _internal_mutable_headers();
  public:
  void unsafe_arena_set_allocated_headers(
      ::gnostic::openapi::v3::HeadersOrReferences* headers);
  ::gnostic::openapi::v3::HeadersOrReferences* unsafe_arena_release_headers();

  // bool explode = 4;
  void clear_explode();
  bool explode() const;
  void set_explode(bool value);
  private:
  bool _internal_explode() const;
  void _internal_set_explode(bool value);
  public:

  // bool allow_reserved = 5;
  void clear_allow_reserved();
  bool allow_reserved() const;
  void set_allow_reserved(bool value);
  private:
  bool _internal_allow_reserved() const;
  void _internal_set_allow_reserved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Encoding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr style_;
    ::gnostic::openapi::v3::HeadersOrReferences* headers_;
    bool explode_;
    bool allow_reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Encodings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Encodings) */ {
 public:
  inline Encodings() : Encodings(nullptr) {}
  ~Encodings() override;
  explicit PROTOBUF_CONSTEXPR Encodings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Encodings(const Encodings& from);
  Encodings(Encodings&& from) noexcept
    : Encodings() {
    *this = ::std::move(from);
  }

  inline Encodings& operator=(const Encodings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Encodings& operator=(Encodings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Encodings& default_instance() {
    return *internal_default_instance();
  }
  static inline const Encodings* internal_default_instance() {
    return reinterpret_cast<const Encodings*>(
               &_Encodings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Encodings& a, Encodings& b) {
    a.Swap(&b);
  }
  inline void Swap(Encodings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Encodings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Encodings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Encodings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Encodings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Encodings& from) {
    Encodings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Encodings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Encodings";
  }
  protected:
  explicit Encodings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedEncoding additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedEncoding* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedEncoding >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedEncoding& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedEncoding* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedEncoding& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedEncoding* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedEncoding >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Encodings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedEncoding > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Example final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Example) */ {
 public:
  inline Example() : Example(nullptr) {}
  ~Example() override;
  explicit PROTOBUF_CONSTEXPR Example(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Example(const Example& from);
  Example(Example&& from) noexcept
    : Example() {
    *this = ::std::move(from);
  }

  inline Example& operator=(const Example& from) {
    CopyFrom(from);
    return *this;
  }
  inline Example& operator=(Example&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Example& default_instance() {
    return *internal_default_instance();
  }
  static inline const Example* internal_default_instance() {
    return reinterpret_cast<const Example*>(
               &_Example_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Example& a, Example& b) {
    a.Swap(&b);
  }
  inline void Swap(Example* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Example* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Example* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Example>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Example& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Example& from) {
    Example::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Example* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Example";
  }
  protected:
  explicit Example(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 5,
    kSummaryFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kExternalValueFieldNumber = 4,
    kValueFieldNumber = 3,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string summary = 1;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string external_value = 4;
  void clear_external_value();
  const std::string& external_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_value();
  PROTOBUF_NODISCARD std::string* release_external_value();
  void set_allocated_external_value(std::string* external_value);
  private:
  const std::string& _internal_external_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_value(const std::string& value);
  std::string* _internal_mutable_external_value();
  public:

  // .gnostic.openapi.v3.Any value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::Any& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Any* release_value();
  ::gnostic::openapi::v3::Any* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::Any* value);
  private:
  const ::gnostic::openapi::v3::Any& _internal_value() const;
  ::gnostic::openapi::v3::Any* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::Any* value);
  ::gnostic::openapi::v3::Any* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Example)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_value_;
    ::gnostic::openapi::v3::Any* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ExampleOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ExampleOrReference) */ {
 public:
  inline ExampleOrReference() : ExampleOrReference(nullptr) {}
  ~ExampleOrReference() override;
  explicit PROTOBUF_CONSTEXPR ExampleOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExampleOrReference(const ExampleOrReference& from);
  ExampleOrReference(ExampleOrReference&& from) noexcept
    : ExampleOrReference() {
    *this = ::std::move(from);
  }

  inline ExampleOrReference& operator=(const ExampleOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExampleOrReference& operator=(ExampleOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExampleOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kExample = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const ExampleOrReference* internal_default_instance() {
    return reinterpret_cast<const ExampleOrReference*>(
               &_ExampleOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ExampleOrReference& a, ExampleOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ExampleOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExampleOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExampleOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExampleOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExampleOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExampleOrReference& from) {
    ExampleOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExampleOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ExampleOrReference";
  }
  protected:
  explicit ExampleOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExampleFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Example example = 1;
  bool has_example() const;
  private:
  bool _internal_has_example() const;
  public:
  void clear_example();
  const ::gnostic::openapi::v3::Example& example() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Example* release_example();
  ::gnostic::openapi::v3::Example* mutable_example();
  void set_allocated_example(::gnostic::openapi::v3::Example* example);
  private:
  const ::gnostic::openapi::v3::Example& _internal_example() const;
  ::gnostic::openapi::v3::Example* _internal_mutable_example();
  public:
  void unsafe_arena_set_allocated_example(
      ::gnostic::openapi::v3::Example* example);
  ::gnostic::openapi::v3::Example* unsafe_arena_release_example();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ExampleOrReference)
 private:
  class _Internal;
  void set_has_example();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Example* example_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ExamplesOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ExamplesOrReferences) */ {
 public:
  inline ExamplesOrReferences() : ExamplesOrReferences(nullptr) {}
  ~ExamplesOrReferences() override;
  explicit PROTOBUF_CONSTEXPR ExamplesOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExamplesOrReferences(const ExamplesOrReferences& from);
  ExamplesOrReferences(ExamplesOrReferences&& from) noexcept
    : ExamplesOrReferences() {
    *this = ::std::move(from);
  }

  inline ExamplesOrReferences& operator=(const ExamplesOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExamplesOrReferences& operator=(ExamplesOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExamplesOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExamplesOrReferences* internal_default_instance() {
    return reinterpret_cast<const ExamplesOrReferences*>(
               &_ExamplesOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExamplesOrReferences& a, ExamplesOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(ExamplesOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExamplesOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExamplesOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExamplesOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExamplesOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExamplesOrReferences& from) {
    ExamplesOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExamplesOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ExamplesOrReferences";
  }
  protected:
  explicit ExamplesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedExampleOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedExampleOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedExampleOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedExampleOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedExampleOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedExampleOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedExampleOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ExamplesOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedExampleOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Expression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Expression) */ {
 public:
  inline Expression() : Expression(nullptr) {}
  ~Expression() override;
  explicit PROTOBUF_CONSTEXPR Expression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expression(const Expression& from);
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression& operator=(Expression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }
  inline void Swap(Expression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Expression& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Expression& from) {
    Expression::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Expression";
  }
  protected:
  explicit Expression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedAny* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedAny& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Expression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ExternalDocs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ExternalDocs) */ {
 public:
  inline ExternalDocs() : ExternalDocs(nullptr) {}
  ~ExternalDocs() override;
  explicit PROTOBUF_CONSTEXPR ExternalDocs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalDocs(const ExternalDocs& from);
  ExternalDocs(ExternalDocs&& from) noexcept
    : ExternalDocs() {
    *this = ::std::move(from);
  }

  inline ExternalDocs& operator=(const ExternalDocs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalDocs& operator=(ExternalDocs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalDocs& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalDocs* internal_default_instance() {
    return reinterpret_cast<const ExternalDocs*>(
               &_ExternalDocs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ExternalDocs& a, ExternalDocs& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalDocs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalDocs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalDocs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalDocs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExternalDocs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExternalDocs& from) {
    ExternalDocs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalDocs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ExternalDocs";
  }
  protected:
  explicit ExternalDocs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 3,
    kDescriptionFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ExternalDocs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 12,
    kDescriptionFieldNumber = 1,
    kStyleFieldNumber = 5,
    kSchemaFieldNumber = 8,
    kExampleFieldNumber = 9,
    kExamplesFieldNumber = 10,
    kContentFieldNumber = 11,
    kRequiredFieldNumber = 2,
    kDeprecatedFieldNumber = 3,
    kAllowEmptyValueFieldNumber = 4,
    kExplodeFieldNumber = 6,
    kAllowReservedFieldNumber = 7,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 12;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string style = 5;
  void clear_style();
  const std::string& style() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_style(ArgT0&& arg0, ArgT... args);
  std::string* mutable_style();
  PROTOBUF_NODISCARD std::string* release_style();
  void set_allocated_style(std::string* style);
  private:
  const std::string& _internal_style() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_style(const std::string& value);
  std::string* _internal_mutable_style();
  public:

  // .gnostic.openapi.v3.SchemaOrReference schema = 8;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::gnostic::openapi::v3::SchemaOrReference& schema() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SchemaOrReference* release_schema();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_schema();
  void set_allocated_schema(::gnostic::openapi::v3::SchemaOrReference* schema);
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_schema() const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::gnostic::openapi::v3::SchemaOrReference* schema);
  ::gnostic::openapi::v3::SchemaOrReference* unsafe_arena_release_schema();

  // .gnostic.openapi.v3.Any example = 9;
  bool has_example() const;
  private:
  bool _internal_has_example() const;
  public:
  void clear_example();
  const ::gnostic::openapi::v3::Any& example() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Any* release_example();
  ::gnostic::openapi::v3::Any* mutable_example();
  void set_allocated_example(::gnostic::openapi::v3::Any* example);
  private:
  const ::gnostic::openapi::v3::Any& _internal_example() const;
  ::gnostic::openapi::v3::Any* _internal_mutable_example();
  public:
  void unsafe_arena_set_allocated_example(
      ::gnostic::openapi::v3::Any* example);
  ::gnostic::openapi::v3::Any* unsafe_arena_release_example();

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 10;
  bool has_examples() const;
  private:
  bool _internal_has_examples() const;
  public:
  void clear_examples();
  const ::gnostic::openapi::v3::ExamplesOrReferences& examples() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExamplesOrReferences* release_examples();
  ::gnostic::openapi::v3::ExamplesOrReferences* mutable_examples();
  void set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples);
  private:
  const ::gnostic::openapi::v3::ExamplesOrReferences& _internal_examples() const;
  ::gnostic::openapi::v3::ExamplesOrReferences* _internal_mutable_examples();
  public:
  void unsafe_arena_set_allocated_examples(
      ::gnostic::openapi::v3::ExamplesOrReferences* examples);
  ::gnostic::openapi::v3::ExamplesOrReferences* unsafe_arena_release_examples();

  // .gnostic.openapi.v3.MediaTypes content = 11;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::gnostic::openapi::v3::MediaTypes& content() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::MediaTypes* release_content();
  ::gnostic::openapi::v3::MediaTypes* mutable_content();
  void set_allocated_content(::gnostic::openapi::v3::MediaTypes* content);
  private:
  const ::gnostic::openapi::v3::MediaTypes& _internal_content() const;
  ::gnostic::openapi::v3::MediaTypes* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::gnostic::openapi::v3::MediaTypes* content);
  ::gnostic::openapi::v3::MediaTypes* unsafe_arena_release_content();

  // bool required = 2;
  void clear_required();
  bool required() const;
  void set_required(bool value);
  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);
  public:

  // bool deprecated = 3;
  void clear_deprecated();
  bool deprecated() const;
  void set_deprecated(bool value);
  private:
  bool _internal_deprecated() const;
  void _internal_set_deprecated(bool value);
  public:

  // bool allow_empty_value = 4;
  void clear_allow_empty_value();
  bool allow_empty_value() const;
  void set_allow_empty_value(bool value);
  private:
  bool _internal_allow_empty_value() const;
  void _internal_set_allow_empty_value(bool value);
  public:

  // bool explode = 6;
  void clear_explode();
  bool explode() const;
  void set_explode(bool value);
  private:
  bool _internal_explode() const;
  void _internal_set_explode(bool value);
  public:

  // bool allow_reserved = 7;
  void clear_allow_reserved();
  bool allow_reserved() const;
  void set_allow_reserved(bool value);
  private:
  bool _internal_allow_reserved() const;
  void _internal_set_allow_reserved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr style_;
    ::gnostic::openapi::v3::SchemaOrReference* schema_;
    ::gnostic::openapi::v3::Any* example_;
    ::gnostic::openapi::v3::ExamplesOrReferences* examples_;
    ::gnostic::openapi::v3::MediaTypes* content_;
    bool required_;
    bool deprecated_;
    bool allow_empty_value_;
    bool explode_;
    bool allow_reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class HeaderOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.HeaderOrReference) */ {
 public:
  inline HeaderOrReference() : HeaderOrReference(nullptr) {}
  ~HeaderOrReference() override;
  explicit PROTOBUF_CONSTEXPR HeaderOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeaderOrReference(const HeaderOrReference& from);
  HeaderOrReference(HeaderOrReference&& from) noexcept
    : HeaderOrReference() {
    *this = ::std::move(from);
  }

  inline HeaderOrReference& operator=(const HeaderOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeaderOrReference& operator=(HeaderOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeaderOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kHeader = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const HeaderOrReference* internal_default_instance() {
    return reinterpret_cast<const HeaderOrReference*>(
               &_HeaderOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HeaderOrReference& a, HeaderOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(HeaderOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeaderOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeaderOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeaderOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeaderOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeaderOrReference& from) {
    HeaderOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeaderOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.HeaderOrReference";
  }
  protected:
  explicit HeaderOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::gnostic::openapi::v3::Header& header() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Header* release_header();
  ::gnostic::openapi::v3::Header* mutable_header();
  void set_allocated_header(::gnostic::openapi::v3::Header* header);
  private:
  const ::gnostic::openapi::v3::Header& _internal_header() const;
  ::gnostic::openapi::v3::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::gnostic::openapi::v3::Header* header);
  ::gnostic::openapi::v3::Header* unsafe_arena_release_header();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.HeaderOrReference)
 private:
  class _Internal;
  void set_has_header();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Header* header_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class HeadersOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.HeadersOrReferences) */ {
 public:
  inline HeadersOrReferences() : HeadersOrReferences(nullptr) {}
  ~HeadersOrReferences() override;
  explicit PROTOBUF_CONSTEXPR HeadersOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeadersOrReferences(const HeadersOrReferences& from);
  HeadersOrReferences(HeadersOrReferences&& from) noexcept
    : HeadersOrReferences() {
    *this = ::std::move(from);
  }

  inline HeadersOrReferences& operator=(const HeadersOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadersOrReferences& operator=(HeadersOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadersOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadersOrReferences* internal_default_instance() {
    return reinterpret_cast<const HeadersOrReferences*>(
               &_HeadersOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(HeadersOrReferences& a, HeadersOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadersOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadersOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadersOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeadersOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeadersOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeadersOrReferences& from) {
    HeadersOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadersOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.HeadersOrReferences";
  }
  protected:
  explicit HeadersOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedHeaderOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedHeaderOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedHeaderOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedHeaderOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedHeaderOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedHeaderOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedHeaderOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.HeadersOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedHeaderOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Info) */ {
 public:
  inline Info() : Info(nullptr) {}
  ~Info() override;
  explicit PROTOBUF_CONSTEXPR Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Info(const Info& from);
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Info& operator=(Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Info& from) {
    Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Info";
  }
  protected:
  explicit Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 7,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTermsOfServiceFieldNumber = 3,
    kVersionFieldNumber = 6,
    kSummaryFieldNumber = 8,
    kContactFieldNumber = 4,
    kLicenseFieldNumber = 5,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string terms_of_service = 3;
  void clear_terms_of_service();
  const std::string& terms_of_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_terms_of_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_terms_of_service();
  PROTOBUF_NODISCARD std::string* release_terms_of_service();
  void set_allocated_terms_of_service(std::string* terms_of_service);
  private:
  const std::string& _internal_terms_of_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terms_of_service(const std::string& value);
  std::string* _internal_mutable_terms_of_service();
  public:

  // string version = 6;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string summary = 8;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // .gnostic.openapi.v3.Contact contact = 4;
  bool has_contact() const;
  private:
  bool _internal_has_contact() const;
  public:
  void clear_contact();
  const ::gnostic::openapi::v3::Contact& contact() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Contact* release_contact();
  ::gnostic::openapi::v3::Contact* mutable_contact();
  void set_allocated_contact(::gnostic::openapi::v3::Contact* contact);
  private:
  const ::gnostic::openapi::v3::Contact& _internal_contact() const;
  ::gnostic::openapi::v3::Contact* _internal_mutable_contact();
  public:
  void unsafe_arena_set_allocated_contact(
      ::gnostic::openapi::v3::Contact* contact);
  ::gnostic::openapi::v3::Contact* unsafe_arena_release_contact();

  // .gnostic.openapi.v3.License license = 5;
  bool has_license() const;
  private:
  bool _internal_has_license() const;
  public:
  void clear_license();
  const ::gnostic::openapi::v3::License& license() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::License* release_license();
  ::gnostic::openapi::v3::License* mutable_license();
  void set_allocated_license(::gnostic::openapi::v3::License* license);
  private:
  const ::gnostic::openapi::v3::License& _internal_license() const;
  ::gnostic::openapi::v3::License* _internal_mutable_license();
  public:
  void unsafe_arena_set_allocated_license(
      ::gnostic::openapi::v3::License* license);
  ::gnostic::openapi::v3::License* unsafe_arena_release_license();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr terms_of_service_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::gnostic::openapi::v3::Contact* contact_;
    ::gnostic::openapi::v3::License* license_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ItemsItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ItemsItem) */ {
 public:
  inline ItemsItem() : ItemsItem(nullptr) {}
  ~ItemsItem() override;
  explicit PROTOBUF_CONSTEXPR ItemsItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemsItem(const ItemsItem& from);
  ItemsItem(ItemsItem&& from) noexcept
    : ItemsItem() {
    *this = ::std::move(from);
  }

  inline ItemsItem& operator=(const ItemsItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemsItem& operator=(ItemsItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemsItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemsItem* internal_default_instance() {
    return reinterpret_cast<const ItemsItem*>(
               &_ItemsItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ItemsItem& a, ItemsItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemsItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemsItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemsItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemsItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemsItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemsItem& from) {
    ItemsItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemsItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ItemsItem";
  }
  protected:
  explicit ItemsItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaOrReferenceFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
  int schema_or_reference_size() const;
  private:
  int _internal_schema_or_reference_size() const;
  public:
  void clear_schema_or_reference();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_schema_or_reference(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
      mutable_schema_or_reference();
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_schema_or_reference(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_add_schema_or_reference();
  public:
  const ::gnostic::openapi::v3::SchemaOrReference& schema_or_reference(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* add_schema_or_reference();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
      schema_or_reference() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ItemsItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference > schema_or_reference_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class License final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.License) */ {
 public:
  inline License() : License(nullptr) {}
  ~License() override;
  explicit PROTOBUF_CONSTEXPR License(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  License(const License& from);
  License(License&& from) noexcept
    : License() {
    *this = ::std::move(from);
  }

  inline License& operator=(const License& from) {
    CopyFrom(from);
    return *this;
  }
  inline License& operator=(License&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const License& default_instance() {
    return *internal_default_instance();
  }
  static inline const License* internal_default_instance() {
    return reinterpret_cast<const License*>(
               &_License_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(License& a, License& b) {
    a.Swap(&b);
  }
  inline void Swap(License* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(License* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  License* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<License>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const License& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const License& from) {
    License::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(License* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.License";
  }
  protected:
  explicit License(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 3,
    kNameFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.License)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit PROTOBUF_CONSTEXPR Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 7,
    kOperationRefFieldNumber = 1,
    kOperationIdFieldNumber = 2,
    kDescriptionFieldNumber = 5,
    kParametersFieldNumber = 3,
    kRequestBodyFieldNumber = 4,
    kServerFieldNumber = 6,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string operation_ref = 1;
  void clear_operation_ref();
  const std::string& operation_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation_ref();
  PROTOBUF_NODISCARD std::string* release_operation_ref();
  void set_allocated_operation_ref(std::string* operation_ref);
  private:
  const std::string& _internal_operation_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_ref(const std::string& value);
  std::string* _internal_mutable_operation_ref();
  public:

  // string operation_id = 2;
  void clear_operation_id();
  const std::string& operation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation_id();
  PROTOBUF_NODISCARD std::string* release_operation_id();
  void set_allocated_operation_id(std::string* operation_id);
  private:
  const std::string& _internal_operation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_id(const std::string& value);
  std::string* _internal_mutable_operation_id();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .gnostic.openapi.v3.AnyOrExpression parameters = 3;
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::gnostic::openapi::v3::AnyOrExpression& parameters() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::AnyOrExpression* release_parameters();
  ::gnostic::openapi::v3::AnyOrExpression* mutable_parameters();
  void set_allocated_parameters(::gnostic::openapi::v3::AnyOrExpression* parameters);
  private:
  const ::gnostic::openapi::v3::AnyOrExpression& _internal_parameters() const;
  ::gnostic::openapi::v3::AnyOrExpression* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::gnostic::openapi::v3::AnyOrExpression* parameters);
  ::gnostic::openapi::v3::AnyOrExpression* unsafe_arena_release_parameters();

  // .gnostic.openapi.v3.AnyOrExpression request_body = 4;
  bool has_request_body() const;
  private:
  bool _internal_has_request_body() const;
  public:
  void clear_request_body();
  const ::gnostic::openapi::v3::AnyOrExpression& request_body() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::AnyOrExpression* release_request_body();
  ::gnostic::openapi::v3::AnyOrExpression* mutable_request_body();
  void set_allocated_request_body(::gnostic::openapi::v3::AnyOrExpression* request_body);
  private:
  const ::gnostic::openapi::v3::AnyOrExpression& _internal_request_body() const;
  ::gnostic::openapi::v3::AnyOrExpression* _internal_mutable_request_body();
  public:
  void unsafe_arena_set_allocated_request_body(
      ::gnostic::openapi::v3::AnyOrExpression* request_body);
  ::gnostic::openapi::v3::AnyOrExpression* unsafe_arena_release_request_body();

  // .gnostic.openapi.v3.Server server = 6;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::gnostic::openapi::v3::Server& server() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Server* release_server();
  ::gnostic::openapi::v3::Server* mutable_server();
  void set_allocated_server(::gnostic::openapi::v3::Server* server);
  private:
  const ::gnostic::openapi::v3::Server& _internal_server() const;
  ::gnostic::openapi::v3::Server* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::gnostic::openapi::v3::Server* server);
  ::gnostic::openapi::v3::Server* unsafe_arena_release_server();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::gnostic::openapi::v3::AnyOrExpression* parameters_;
    ::gnostic::openapi::v3::AnyOrExpression* request_body_;
    ::gnostic::openapi::v3::Server* server_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class LinkOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.LinkOrReference) */ {
 public:
  inline LinkOrReference() : LinkOrReference(nullptr) {}
  ~LinkOrReference() override;
  explicit PROTOBUF_CONSTEXPR LinkOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkOrReference(const LinkOrReference& from);
  LinkOrReference(LinkOrReference&& from) noexcept
    : LinkOrReference() {
    *this = ::std::move(from);
  }

  inline LinkOrReference& operator=(const LinkOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkOrReference& operator=(LinkOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinkOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kLink = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const LinkOrReference* internal_default_instance() {
    return reinterpret_cast<const LinkOrReference*>(
               &_LinkOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LinkOrReference& a, LinkOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinkOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinkOrReference& from) {
    LinkOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.LinkOrReference";
  }
  protected:
  explicit LinkOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Link link = 1;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  const ::gnostic::openapi::v3::Link& link() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Link* release_link();
  ::gnostic::openapi::v3::Link* mutable_link();
  void set_allocated_link(::gnostic::openapi::v3::Link* link);
  private:
  const ::gnostic::openapi::v3::Link& _internal_link() const;
  ::gnostic::openapi::v3::Link* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::gnostic::openapi::v3::Link* link);
  ::gnostic::openapi::v3::Link* unsafe_arena_release_link();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.LinkOrReference)
 private:
  class _Internal;
  void set_has_link();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Link* link_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class LinksOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.LinksOrReferences) */ {
 public:
  inline LinksOrReferences() : LinksOrReferences(nullptr) {}
  ~LinksOrReferences() override;
  explicit PROTOBUF_CONSTEXPR LinksOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinksOrReferences(const LinksOrReferences& from);
  LinksOrReferences(LinksOrReferences&& from) noexcept
    : LinksOrReferences() {
    *this = ::std::move(from);
  }

  inline LinksOrReferences& operator=(const LinksOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinksOrReferences& operator=(LinksOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinksOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinksOrReferences* internal_default_instance() {
    return reinterpret_cast<const LinksOrReferences*>(
               &_LinksOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LinksOrReferences& a, LinksOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(LinksOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinksOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinksOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinksOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinksOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinksOrReferences& from) {
    LinksOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinksOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.LinksOrReferences";
  }
  protected:
  explicit LinksOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedLinkOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedLinkOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedLinkOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedLinkOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedLinkOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedLinkOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedLinkOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.LinksOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedLinkOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class MediaType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.MediaType) */ {
 public:
  inline MediaType() : MediaType(nullptr) {}
  ~MediaType() override;
  explicit PROTOBUF_CONSTEXPR MediaType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaType(const MediaType& from);
  MediaType(MediaType&& from) noexcept
    : MediaType() {
    *this = ::std::move(from);
  }

  inline MediaType& operator=(const MediaType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaType& operator=(MediaType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaType& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaType* internal_default_instance() {
    return reinterpret_cast<const MediaType*>(
               &_MediaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MediaType& a, MediaType& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaType& from) {
    MediaType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.MediaType";
  }
  protected:
  explicit MediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 5,
    kSchemaFieldNumber = 1,
    kExampleFieldNumber = 2,
    kExamplesFieldNumber = 3,
    kEncodingFieldNumber = 4,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // .gnostic.openapi.v3.SchemaOrReference schema = 1;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::gnostic::openapi::v3::SchemaOrReference& schema() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SchemaOrReference* release_schema();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_schema();
  void set_allocated_schema(::gnostic::openapi::v3::SchemaOrReference* schema);
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_schema() const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::gnostic::openapi::v3::SchemaOrReference* schema);
  ::gnostic::openapi::v3::SchemaOrReference* unsafe_arena_release_schema();

  // .gnostic.openapi.v3.Any example = 2;
  bool has_example() const;
  private:
  bool _internal_has_example() const;
  public:
  void clear_example();
  const ::gnostic::openapi::v3::Any& example() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Any* release_example();
  ::gnostic::openapi::v3::Any* mutable_example();
  void set_allocated_example(::gnostic::openapi::v3::Any* example);
  private:
  const ::gnostic::openapi::v3::Any& _internal_example() const;
  ::gnostic::openapi::v3::Any* _internal_mutable_example();
  public:
  void unsafe_arena_set_allocated_example(
      ::gnostic::openapi::v3::Any* example);
  ::gnostic::openapi::v3::Any* unsafe_arena_release_example();

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 3;
  bool has_examples() const;
  private:
  bool _internal_has_examples() const;
  public:
  void clear_examples();
  const ::gnostic::openapi::v3::ExamplesOrReferences& examples() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExamplesOrReferences* release_examples();
  ::gnostic::openapi::v3::ExamplesOrReferences* mutable_examples();
  void set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples);
  private:
  const ::gnostic::openapi::v3::ExamplesOrReferences& _internal_examples() const;
  ::gnostic::openapi::v3::ExamplesOrReferences* _internal_mutable_examples();
  public:
  void unsafe_arena_set_allocated_examples(
      ::gnostic::openapi::v3::ExamplesOrReferences* examples);
  ::gnostic::openapi::v3::ExamplesOrReferences* unsafe_arena_release_examples();

  // .gnostic.openapi.v3.Encodings encoding = 4;
  bool has_encoding() const;
  private:
  bool _internal_has_encoding() const;
  public:
  void clear_encoding();
  const ::gnostic::openapi::v3::Encodings& encoding() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Encodings* release_encoding();
  ::gnostic::openapi::v3::Encodings* mutable_encoding();
  void set_allocated_encoding(::gnostic::openapi::v3::Encodings* encoding);
  private:
  const ::gnostic::openapi::v3::Encodings& _internal_encoding() const;
  ::gnostic::openapi::v3::Encodings* _internal_mutable_encoding();
  public:
  void unsafe_arena_set_allocated_encoding(
      ::gnostic::openapi::v3::Encodings* encoding);
  ::gnostic::openapi::v3::Encodings* unsafe_arena_release_encoding();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.MediaType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::gnostic::openapi::v3::SchemaOrReference* schema_;
    ::gnostic::openapi::v3::Any* example_;
    ::gnostic::openapi::v3::ExamplesOrReferences* examples_;
    ::gnostic::openapi::v3::Encodings* encoding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class MediaTypes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.MediaTypes) */ {
 public:
  inline MediaTypes() : MediaTypes(nullptr) {}
  ~MediaTypes() override;
  explicit PROTOBUF_CONSTEXPR MediaTypes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaTypes(const MediaTypes& from);
  MediaTypes(MediaTypes&& from) noexcept
    : MediaTypes() {
    *this = ::std::move(from);
  }

  inline MediaTypes& operator=(const MediaTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaTypes& operator=(MediaTypes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaTypes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaTypes* internal_default_instance() {
    return reinterpret_cast<const MediaTypes*>(
               &_MediaTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(MediaTypes& a, MediaTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaTypes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaTypes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaTypes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaTypes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaTypes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaTypes& from) {
    MediaTypes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaTypes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.MediaTypes";
  }
  protected:
  explicit MediaTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedMediaType additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedMediaType* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedMediaType >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedMediaType& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedMediaType* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedMediaType& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedMediaType* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedMediaType >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.MediaTypes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedMediaType > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedAny final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedAny) */ {
 public:
  inline NamedAny() : NamedAny(nullptr) {}
  ~NamedAny() override;
  explicit PROTOBUF_CONSTEXPR NamedAny(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedAny(const NamedAny& from);
  NamedAny(NamedAny&& from) noexcept
    : NamedAny() {
    *this = ::std::move(from);
  }

  inline NamedAny& operator=(const NamedAny& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedAny& operator=(NamedAny&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedAny& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedAny* internal_default_instance() {
    return reinterpret_cast<const NamedAny*>(
               &_NamedAny_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(NamedAny& a, NamedAny& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedAny* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedAny* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedAny* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedAny>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedAny& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedAny& from) {
    NamedAny::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedAny* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedAny";
  }
  protected:
  explicit NamedAny(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.Any value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::Any& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Any* release_value();
  ::gnostic::openapi::v3::Any* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::Any* value);
  private:
  const ::gnostic::openapi::v3::Any& _internal_value() const;
  ::gnostic::openapi::v3::Any* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::Any* value);
  ::gnostic::openapi::v3::Any* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedAny)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::Any* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedCallbackOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedCallbackOrReference) */ {
 public:
  inline NamedCallbackOrReference() : NamedCallbackOrReference(nullptr) {}
  ~NamedCallbackOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedCallbackOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedCallbackOrReference(const NamedCallbackOrReference& from);
  NamedCallbackOrReference(NamedCallbackOrReference&& from) noexcept
    : NamedCallbackOrReference() {
    *this = ::std::move(from);
  }

  inline NamedCallbackOrReference& operator=(const NamedCallbackOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedCallbackOrReference& operator=(NamedCallbackOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedCallbackOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedCallbackOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedCallbackOrReference*>(
               &_NamedCallbackOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(NamedCallbackOrReference& a, NamedCallbackOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedCallbackOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedCallbackOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedCallbackOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedCallbackOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedCallbackOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedCallbackOrReference& from) {
    NamedCallbackOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedCallbackOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedCallbackOrReference";
  }
  protected:
  explicit NamedCallbackOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.CallbackOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::CallbackOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::CallbackOrReference* release_value();
  ::gnostic::openapi::v3::CallbackOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::CallbackOrReference* value);
  private:
  const ::gnostic::openapi::v3::CallbackOrReference& _internal_value() const;
  ::gnostic::openapi::v3::CallbackOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::CallbackOrReference* value);
  ::gnostic::openapi::v3::CallbackOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedCallbackOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::CallbackOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedEncoding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedEncoding) */ {
 public:
  inline NamedEncoding() : NamedEncoding(nullptr) {}
  ~NamedEncoding() override;
  explicit PROTOBUF_CONSTEXPR NamedEncoding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedEncoding(const NamedEncoding& from);
  NamedEncoding(NamedEncoding&& from) noexcept
    : NamedEncoding() {
    *this = ::std::move(from);
  }

  inline NamedEncoding& operator=(const NamedEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedEncoding& operator=(NamedEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedEncoding* internal_default_instance() {
    return reinterpret_cast<const NamedEncoding*>(
               &_NamedEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(NamedEncoding& a, NamedEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedEncoding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedEncoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedEncoding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedEncoding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedEncoding& from) {
    NamedEncoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedEncoding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedEncoding";
  }
  protected:
  explicit NamedEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.Encoding value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::Encoding& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Encoding* release_value();
  ::gnostic::openapi::v3::Encoding* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::Encoding* value);
  private:
  const ::gnostic::openapi::v3::Encoding& _internal_value() const;
  ::gnostic::openapi::v3::Encoding* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::Encoding* value);
  ::gnostic::openapi::v3::Encoding* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedEncoding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::Encoding* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedExampleOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedExampleOrReference) */ {
 public:
  inline NamedExampleOrReference() : NamedExampleOrReference(nullptr) {}
  ~NamedExampleOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedExampleOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedExampleOrReference(const NamedExampleOrReference& from);
  NamedExampleOrReference(NamedExampleOrReference&& from) noexcept
    : NamedExampleOrReference() {
    *this = ::std::move(from);
  }

  inline NamedExampleOrReference& operator=(const NamedExampleOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedExampleOrReference& operator=(NamedExampleOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedExampleOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedExampleOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedExampleOrReference*>(
               &_NamedExampleOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(NamedExampleOrReference& a, NamedExampleOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedExampleOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedExampleOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedExampleOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedExampleOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedExampleOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedExampleOrReference& from) {
    NamedExampleOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedExampleOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedExampleOrReference";
  }
  protected:
  explicit NamedExampleOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.ExampleOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::ExampleOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExampleOrReference* release_value();
  ::gnostic::openapi::v3::ExampleOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::ExampleOrReference* value);
  private:
  const ::gnostic::openapi::v3::ExampleOrReference& _internal_value() const;
  ::gnostic::openapi::v3::ExampleOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::ExampleOrReference* value);
  ::gnostic::openapi::v3::ExampleOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedExampleOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::ExampleOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedHeaderOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedHeaderOrReference) */ {
 public:
  inline NamedHeaderOrReference() : NamedHeaderOrReference(nullptr) {}
  ~NamedHeaderOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedHeaderOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedHeaderOrReference(const NamedHeaderOrReference& from);
  NamedHeaderOrReference(NamedHeaderOrReference&& from) noexcept
    : NamedHeaderOrReference() {
    *this = ::std::move(from);
  }

  inline NamedHeaderOrReference& operator=(const NamedHeaderOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedHeaderOrReference& operator=(NamedHeaderOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedHeaderOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedHeaderOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedHeaderOrReference*>(
               &_NamedHeaderOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(NamedHeaderOrReference& a, NamedHeaderOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedHeaderOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedHeaderOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedHeaderOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedHeaderOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedHeaderOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedHeaderOrReference& from) {
    NamedHeaderOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedHeaderOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedHeaderOrReference";
  }
  protected:
  explicit NamedHeaderOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.HeaderOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::HeaderOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::HeaderOrReference* release_value();
  ::gnostic::openapi::v3::HeaderOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::HeaderOrReference* value);
  private:
  const ::gnostic::openapi::v3::HeaderOrReference& _internal_value() const;
  ::gnostic::openapi::v3::HeaderOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::HeaderOrReference* value);
  ::gnostic::openapi::v3::HeaderOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedHeaderOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::HeaderOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedLinkOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedLinkOrReference) */ {
 public:
  inline NamedLinkOrReference() : NamedLinkOrReference(nullptr) {}
  ~NamedLinkOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedLinkOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedLinkOrReference(const NamedLinkOrReference& from);
  NamedLinkOrReference(NamedLinkOrReference&& from) noexcept
    : NamedLinkOrReference() {
    *this = ::std::move(from);
  }

  inline NamedLinkOrReference& operator=(const NamedLinkOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedLinkOrReference& operator=(NamedLinkOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedLinkOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedLinkOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedLinkOrReference*>(
               &_NamedLinkOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(NamedLinkOrReference& a, NamedLinkOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedLinkOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedLinkOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedLinkOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedLinkOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedLinkOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedLinkOrReference& from) {
    NamedLinkOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedLinkOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedLinkOrReference";
  }
  protected:
  explicit NamedLinkOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.LinkOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::LinkOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::LinkOrReference* release_value();
  ::gnostic::openapi::v3::LinkOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::LinkOrReference* value);
  private:
  const ::gnostic::openapi::v3::LinkOrReference& _internal_value() const;
  ::gnostic::openapi::v3::LinkOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::LinkOrReference* value);
  ::gnostic::openapi::v3::LinkOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedLinkOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::LinkOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedMediaType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedMediaType) */ {
 public:
  inline NamedMediaType() : NamedMediaType(nullptr) {}
  ~NamedMediaType() override;
  explicit PROTOBUF_CONSTEXPR NamedMediaType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedMediaType(const NamedMediaType& from);
  NamedMediaType(NamedMediaType&& from) noexcept
    : NamedMediaType() {
    *this = ::std::move(from);
  }

  inline NamedMediaType& operator=(const NamedMediaType& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedMediaType& operator=(NamedMediaType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedMediaType& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedMediaType* internal_default_instance() {
    return reinterpret_cast<const NamedMediaType*>(
               &_NamedMediaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(NamedMediaType& a, NamedMediaType& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedMediaType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedMediaType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedMediaType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedMediaType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedMediaType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedMediaType& from) {
    NamedMediaType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedMediaType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedMediaType";
  }
  protected:
  explicit NamedMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.MediaType value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::MediaType& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::MediaType* release_value();
  ::gnostic::openapi::v3::MediaType* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::MediaType* value);
  private:
  const ::gnostic::openapi::v3::MediaType& _internal_value() const;
  ::gnostic::openapi::v3::MediaType* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::MediaType* value);
  ::gnostic::openapi::v3::MediaType* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedMediaType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::MediaType* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedParameterOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedParameterOrReference) */ {
 public:
  inline NamedParameterOrReference() : NamedParameterOrReference(nullptr) {}
  ~NamedParameterOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedParameterOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedParameterOrReference(const NamedParameterOrReference& from);
  NamedParameterOrReference(NamedParameterOrReference&& from) noexcept
    : NamedParameterOrReference() {
    *this = ::std::move(from);
  }

  inline NamedParameterOrReference& operator=(const NamedParameterOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedParameterOrReference& operator=(NamedParameterOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedParameterOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedParameterOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedParameterOrReference*>(
               &_NamedParameterOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(NamedParameterOrReference& a, NamedParameterOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedParameterOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedParameterOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedParameterOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedParameterOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedParameterOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedParameterOrReference& from) {
    NamedParameterOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedParameterOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedParameterOrReference";
  }
  protected:
  explicit NamedParameterOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.ParameterOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::ParameterOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ParameterOrReference* release_value();
  ::gnostic::openapi::v3::ParameterOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::ParameterOrReference* value);
  private:
  const ::gnostic::openapi::v3::ParameterOrReference& _internal_value() const;
  ::gnostic::openapi::v3::ParameterOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::ParameterOrReference* value);
  ::gnostic::openapi::v3::ParameterOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedParameterOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::ParameterOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedPathItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedPathItem) */ {
 public:
  inline NamedPathItem() : NamedPathItem(nullptr) {}
  ~NamedPathItem() override;
  explicit PROTOBUF_CONSTEXPR NamedPathItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedPathItem(const NamedPathItem& from);
  NamedPathItem(NamedPathItem&& from) noexcept
    : NamedPathItem() {
    *this = ::std::move(from);
  }

  inline NamedPathItem& operator=(const NamedPathItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedPathItem& operator=(NamedPathItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedPathItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedPathItem* internal_default_instance() {
    return reinterpret_cast<const NamedPathItem*>(
               &_NamedPathItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(NamedPathItem& a, NamedPathItem& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedPathItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedPathItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedPathItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedPathItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedPathItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedPathItem& from) {
    NamedPathItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedPathItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedPathItem";
  }
  protected:
  explicit NamedPathItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.PathItem value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::PathItem& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::PathItem* release_value();
  ::gnostic::openapi::v3::PathItem* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::PathItem* value);
  private:
  const ::gnostic::openapi::v3::PathItem& _internal_value() const;
  ::gnostic::openapi::v3::PathItem* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::PathItem* value);
  ::gnostic::openapi::v3::PathItem* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedPathItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::PathItem* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedRequestBodyOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedRequestBodyOrReference) */ {
 public:
  inline NamedRequestBodyOrReference() : NamedRequestBodyOrReference(nullptr) {}
  ~NamedRequestBodyOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedRequestBodyOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedRequestBodyOrReference(const NamedRequestBodyOrReference& from);
  NamedRequestBodyOrReference(NamedRequestBodyOrReference&& from) noexcept
    : NamedRequestBodyOrReference() {
    *this = ::std::move(from);
  }

  inline NamedRequestBodyOrReference& operator=(const NamedRequestBodyOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedRequestBodyOrReference& operator=(NamedRequestBodyOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedRequestBodyOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedRequestBodyOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedRequestBodyOrReference*>(
               &_NamedRequestBodyOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(NamedRequestBodyOrReference& a, NamedRequestBodyOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedRequestBodyOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedRequestBodyOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedRequestBodyOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedRequestBodyOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedRequestBodyOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedRequestBodyOrReference& from) {
    NamedRequestBodyOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedRequestBodyOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedRequestBodyOrReference";
  }
  protected:
  explicit NamedRequestBodyOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.RequestBodyOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::RequestBodyOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::RequestBodyOrReference* release_value();
  ::gnostic::openapi::v3::RequestBodyOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::RequestBodyOrReference* value);
  private:
  const ::gnostic::openapi::v3::RequestBodyOrReference& _internal_value() const;
  ::gnostic::openapi::v3::RequestBodyOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::RequestBodyOrReference* value);
  ::gnostic::openapi::v3::RequestBodyOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedRequestBodyOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::RequestBodyOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedResponseOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedResponseOrReference) */ {
 public:
  inline NamedResponseOrReference() : NamedResponseOrReference(nullptr) {}
  ~NamedResponseOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedResponseOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedResponseOrReference(const NamedResponseOrReference& from);
  NamedResponseOrReference(NamedResponseOrReference&& from) noexcept
    : NamedResponseOrReference() {
    *this = ::std::move(from);
  }

  inline NamedResponseOrReference& operator=(const NamedResponseOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedResponseOrReference& operator=(NamedResponseOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedResponseOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedResponseOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedResponseOrReference*>(
               &_NamedResponseOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(NamedResponseOrReference& a, NamedResponseOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedResponseOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedResponseOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedResponseOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedResponseOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedResponseOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedResponseOrReference& from) {
    NamedResponseOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedResponseOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedResponseOrReference";
  }
  protected:
  explicit NamedResponseOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.ResponseOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::ResponseOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ResponseOrReference* release_value();
  ::gnostic::openapi::v3::ResponseOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::ResponseOrReference* value);
  private:
  const ::gnostic::openapi::v3::ResponseOrReference& _internal_value() const;
  ::gnostic::openapi::v3::ResponseOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::ResponseOrReference* value);
  ::gnostic::openapi::v3::ResponseOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedResponseOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::ResponseOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedSchemaOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedSchemaOrReference) */ {
 public:
  inline NamedSchemaOrReference() : NamedSchemaOrReference(nullptr) {}
  ~NamedSchemaOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedSchemaOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedSchemaOrReference(const NamedSchemaOrReference& from);
  NamedSchemaOrReference(NamedSchemaOrReference&& from) noexcept
    : NamedSchemaOrReference() {
    *this = ::std::move(from);
  }

  inline NamedSchemaOrReference& operator=(const NamedSchemaOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedSchemaOrReference& operator=(NamedSchemaOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedSchemaOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedSchemaOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedSchemaOrReference*>(
               &_NamedSchemaOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(NamedSchemaOrReference& a, NamedSchemaOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedSchemaOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedSchemaOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedSchemaOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedSchemaOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedSchemaOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedSchemaOrReference& from) {
    NamedSchemaOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedSchemaOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedSchemaOrReference";
  }
  protected:
  explicit NamedSchemaOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.SchemaOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::SchemaOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SchemaOrReference* release_value();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::SchemaOrReference* value);
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_value() const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::SchemaOrReference* value);
  ::gnostic::openapi::v3::SchemaOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedSchemaOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::SchemaOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedSecuritySchemeOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedSecuritySchemeOrReference) */ {
 public:
  inline NamedSecuritySchemeOrReference() : NamedSecuritySchemeOrReference(nullptr) {}
  ~NamedSecuritySchemeOrReference() override;
  explicit PROTOBUF_CONSTEXPR NamedSecuritySchemeOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedSecuritySchemeOrReference(const NamedSecuritySchemeOrReference& from);
  NamedSecuritySchemeOrReference(NamedSecuritySchemeOrReference&& from) noexcept
    : NamedSecuritySchemeOrReference() {
    *this = ::std::move(from);
  }

  inline NamedSecuritySchemeOrReference& operator=(const NamedSecuritySchemeOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedSecuritySchemeOrReference& operator=(NamedSecuritySchemeOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedSecuritySchemeOrReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedSecuritySchemeOrReference* internal_default_instance() {
    return reinterpret_cast<const NamedSecuritySchemeOrReference*>(
               &_NamedSecuritySchemeOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(NamedSecuritySchemeOrReference& a, NamedSecuritySchemeOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedSecuritySchemeOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedSecuritySchemeOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedSecuritySchemeOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedSecuritySchemeOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedSecuritySchemeOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedSecuritySchemeOrReference& from) {
    NamedSecuritySchemeOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedSecuritySchemeOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedSecuritySchemeOrReference";
  }
  protected:
  explicit NamedSecuritySchemeOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.SecuritySchemeOrReference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::SecuritySchemeOrReference& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SecuritySchemeOrReference* release_value();
  ::gnostic::openapi::v3::SecuritySchemeOrReference* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::SecuritySchemeOrReference* value);
  private:
  const ::gnostic::openapi::v3::SecuritySchemeOrReference& _internal_value() const;
  ::gnostic::openapi::v3::SecuritySchemeOrReference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::SecuritySchemeOrReference* value);
  ::gnostic::openapi::v3::SecuritySchemeOrReference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedSecuritySchemeOrReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::SecuritySchemeOrReference* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedServerVariable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedServerVariable) */ {
 public:
  inline NamedServerVariable() : NamedServerVariable(nullptr) {}
  ~NamedServerVariable() override;
  explicit PROTOBUF_CONSTEXPR NamedServerVariable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedServerVariable(const NamedServerVariable& from);
  NamedServerVariable(NamedServerVariable&& from) noexcept
    : NamedServerVariable() {
    *this = ::std::move(from);
  }

  inline NamedServerVariable& operator=(const NamedServerVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedServerVariable& operator=(NamedServerVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedServerVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedServerVariable* internal_default_instance() {
    return reinterpret_cast<const NamedServerVariable*>(
               &_NamedServerVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(NamedServerVariable& a, NamedServerVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedServerVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedServerVariable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedServerVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedServerVariable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedServerVariable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedServerVariable& from) {
    NamedServerVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedServerVariable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedServerVariable";
  }
  protected:
  explicit NamedServerVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.ServerVariable value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::ServerVariable& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ServerVariable* release_value();
  ::gnostic::openapi::v3::ServerVariable* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::ServerVariable* value);
  private:
  const ::gnostic::openapi::v3::ServerVariable& _internal_value() const;
  ::gnostic::openapi::v3::ServerVariable* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::ServerVariable* value);
  ::gnostic::openapi::v3::ServerVariable* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedServerVariable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::ServerVariable* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedString) */ {
 public:
  inline NamedString() : NamedString(nullptr) {}
  ~NamedString() override;
  explicit PROTOBUF_CONSTEXPR NamedString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedString(const NamedString& from);
  NamedString(NamedString&& from) noexcept
    : NamedString() {
    *this = ::std::move(from);
  }

  inline NamedString& operator=(const NamedString& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedString& operator=(NamedString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedString& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedString* internal_default_instance() {
    return reinterpret_cast<const NamedString*>(
               &_NamedString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(NamedString& a, NamedString& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedString& from) {
    NamedString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedString";
  }
  protected:
  explicit NamedString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class NamedStringArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.NamedStringArray) */ {
 public:
  inline NamedStringArray() : NamedStringArray(nullptr) {}
  ~NamedStringArray() override;
  explicit PROTOBUF_CONSTEXPR NamedStringArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedStringArray(const NamedStringArray& from);
  NamedStringArray(NamedStringArray&& from) noexcept
    : NamedStringArray() {
    *this = ::std::move(from);
  }

  inline NamedStringArray& operator=(const NamedStringArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedStringArray& operator=(NamedStringArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedStringArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedStringArray* internal_default_instance() {
    return reinterpret_cast<const NamedStringArray*>(
               &_NamedStringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(NamedStringArray& a, NamedStringArray& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedStringArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedStringArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedStringArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedStringArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedStringArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedStringArray& from) {
    NamedStringArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedStringArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.NamedStringArray";
  }
  protected:
  explicit NamedStringArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .gnostic.openapi.v3.StringArray value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::gnostic::openapi::v3::StringArray& value() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::StringArray* release_value();
  ::gnostic::openapi::v3::StringArray* mutable_value();
  void set_allocated_value(::gnostic::openapi::v3::StringArray* value);
  private:
  const ::gnostic::openapi::v3::StringArray& _internal_value() const;
  ::gnostic::openapi::v3::StringArray* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::gnostic::openapi::v3::StringArray* value);
  ::gnostic::openapi::v3::StringArray* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.NamedStringArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::gnostic::openapi::v3::StringArray* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class OauthFlow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.OauthFlow) */ {
 public:
  inline OauthFlow() : OauthFlow(nullptr) {}
  ~OauthFlow() override;
  explicit PROTOBUF_CONSTEXPR OauthFlow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OauthFlow(const OauthFlow& from);
  OauthFlow(OauthFlow&& from) noexcept
    : OauthFlow() {
    *this = ::std::move(from);
  }

  inline OauthFlow& operator=(const OauthFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline OauthFlow& operator=(OauthFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OauthFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const OauthFlow* internal_default_instance() {
    return reinterpret_cast<const OauthFlow*>(
               &_OauthFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(OauthFlow& a, OauthFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(OauthFlow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OauthFlow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OauthFlow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OauthFlow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OauthFlow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OauthFlow& from) {
    OauthFlow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OauthFlow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.OauthFlow";
  }
  protected:
  explicit OauthFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 5,
    kAuthorizationUrlFieldNumber = 1,
    kTokenUrlFieldNumber = 2,
    kRefreshUrlFieldNumber = 3,
    kScopesFieldNumber = 4,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string authorization_url = 1;
  void clear_authorization_url();
  const std::string& authorization_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_url();
  PROTOBUF_NODISCARD std::string* release_authorization_url();
  void set_allocated_authorization_url(std::string* authorization_url);
  private:
  const std::string& _internal_authorization_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_url(const std::string& value);
  std::string* _internal_mutable_authorization_url();
  public:

  // string token_url = 2;
  void clear_token_url();
  const std::string& token_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_url();
  PROTOBUF_NODISCARD std::string* release_token_url();
  void set_allocated_token_url(std::string* token_url);
  private:
  const std::string& _internal_token_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_url(const std::string& value);
  std::string* _internal_mutable_token_url();
  public:

  // string refresh_url = 3;
  void clear_refresh_url();
  const std::string& refresh_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_url();
  PROTOBUF_NODISCARD std::string* release_refresh_url();
  void set_allocated_refresh_url(std::string* refresh_url);
  private:
  const std::string& _internal_refresh_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_url(const std::string& value);
  std::string* _internal_mutable_refresh_url();
  public:

  // .gnostic.openapi.v3.Strings scopes = 4;
  bool has_scopes() const;
  private:
  bool _internal_has_scopes() const;
  public:
  void clear_scopes();
  const ::gnostic::openapi::v3::Strings& scopes() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Strings* release_scopes();
  ::gnostic::openapi::v3::Strings* mutable_scopes();
  void set_allocated_scopes(::gnostic::openapi::v3::Strings* scopes);
  private:
  const ::gnostic::openapi::v3::Strings& _internal_scopes() const;
  ::gnostic::openapi::v3::Strings* _internal_mutable_scopes();
  public:
  void unsafe_arena_set_allocated_scopes(
      ::gnostic::openapi::v3::Strings* scopes);
  ::gnostic::openapi::v3::Strings* unsafe_arena_release_scopes();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.OauthFlow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_url_;
    ::gnostic::openapi::v3::Strings* scopes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class OauthFlows final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.OauthFlows) */ {
 public:
  inline OauthFlows() : OauthFlows(nullptr) {}
  ~OauthFlows() override;
  explicit PROTOBUF_CONSTEXPR OauthFlows(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OauthFlows(const OauthFlows& from);
  OauthFlows(OauthFlows&& from) noexcept
    : OauthFlows() {
    *this = ::std::move(from);
  }

  inline OauthFlows& operator=(const OauthFlows& from) {
    CopyFrom(from);
    return *this;
  }
  inline OauthFlows& operator=(OauthFlows&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OauthFlows& default_instance() {
    return *internal_default_instance();
  }
  static inline const OauthFlows* internal_default_instance() {
    return reinterpret_cast<const OauthFlows*>(
               &_OauthFlows_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(OauthFlows& a, OauthFlows& b) {
    a.Swap(&b);
  }
  inline void Swap(OauthFlows* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OauthFlows* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OauthFlows* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OauthFlows>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OauthFlows& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OauthFlows& from) {
    OauthFlows::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OauthFlows* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.OauthFlows";
  }
  protected:
  explicit OauthFlows(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 5,
    kImplicitFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kClientCredentialsFieldNumber = 3,
    kAuthorizationCodeFieldNumber = 4,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // .gnostic.openapi.v3.OauthFlow implicit = 1;
  bool has_implicit() const;
  private:
  bool _internal_has_implicit() const;
  public:
  void clear_implicit();
  const ::gnostic::openapi::v3::OauthFlow& implicit() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::OauthFlow* release_implicit();
  ::gnostic::openapi::v3::OauthFlow* mutable_implicit();
  void set_allocated_implicit(::gnostic::openapi::v3::OauthFlow* implicit);
  private:
  const ::gnostic::openapi::v3::OauthFlow& _internal_implicit() const;
  ::gnostic::openapi::v3::OauthFlow* _internal_mutable_implicit();
  public:
  void unsafe_arena_set_allocated_implicit(
      ::gnostic::openapi::v3::OauthFlow* implicit);
  ::gnostic::openapi::v3::OauthFlow* unsafe_arena_release_implicit();

  // .gnostic.openapi.v3.OauthFlow password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const ::gnostic::openapi::v3::OauthFlow& password() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::OauthFlow* release_password();
  ::gnostic::openapi::v3::OauthFlow* mutable_password();
  void set_allocated_password(::gnostic::openapi::v3::OauthFlow* password);
  private:
  const ::gnostic::openapi::v3::OauthFlow& _internal_password() const;
  ::gnostic::openapi::v3::OauthFlow* _internal_mutable_password();
  public:
  void unsafe_arena_set_allocated_password(
      ::gnostic::openapi::v3::OauthFlow* password);
  ::gnostic::openapi::v3::OauthFlow* unsafe_arena_release_password();

  // .gnostic.openapi.v3.OauthFlow client_credentials = 3;
  bool has_client_credentials() const;
  private:
  bool _internal_has_client_credentials() const;
  public:
  void clear_client_credentials();
  const ::gnostic::openapi::v3::OauthFlow& client_credentials() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::OauthFlow* release_client_credentials();
  ::gnostic::openapi::v3::OauthFlow* mutable_client_credentials();
  void set_allocated_client_credentials(::gnostic::openapi::v3::OauthFlow* client_credentials);
  private:
  const ::gnostic::openapi::v3::OauthFlow& _internal_client_credentials() const;
  ::gnostic::openapi::v3::OauthFlow* _internal_mutable_client_credentials();
  public:
  void unsafe_arena_set_allocated_client_credentials(
      ::gnostic::openapi::v3::OauthFlow* client_credentials);
  ::gnostic::openapi::v3::OauthFlow* unsafe_arena_release_client_credentials();

  // .gnostic.openapi.v3.OauthFlow authorization_code = 4;
  bool has_authorization_code() const;
  private:
  bool _internal_has_authorization_code() const;
  public:
  void clear_authorization_code();
  const ::gnostic::openapi::v3::OauthFlow& authorization_code() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::OauthFlow* release_authorization_code();
  ::gnostic::openapi::v3::OauthFlow* mutable_authorization_code();
  void set_allocated_authorization_code(::gnostic::openapi::v3::OauthFlow* authorization_code);
  private:
  const ::gnostic::openapi::v3::OauthFlow& _internal_authorization_code() const;
  ::gnostic::openapi::v3::OauthFlow* _internal_mutable_authorization_code();
  public:
  void unsafe_arena_set_allocated_authorization_code(
      ::gnostic::openapi::v3::OauthFlow* authorization_code);
  ::gnostic::openapi::v3::OauthFlow* unsafe_arena_release_authorization_code();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.OauthFlows)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::gnostic::openapi::v3::OauthFlow* implicit_;
    ::gnostic::openapi::v3::OauthFlow* password_;
    ::gnostic::openapi::v3::OauthFlow* client_credentials_;
    ::gnostic::openapi::v3::OauthFlow* authorization_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  explicit PROTOBUF_CONSTEXPR Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Object& from) {
    Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedAny* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedAny& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
    kParametersFieldNumber = 6,
    kSecurityFieldNumber = 11,
    kServersFieldNumber = 12,
    kSpecificationExtensionFieldNumber = 13,
    kSummaryFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kOperationIdFieldNumber = 5,
    kExternalDocsFieldNumber = 4,
    kRequestBodyFieldNumber = 7,
    kResponsesFieldNumber = 8,
    kCallbacksFieldNumber = 9,
    kDeprecatedFieldNumber = 10,
  };
  // repeated string tags = 1;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 6;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::gnostic::openapi::v3::ParameterOrReference* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >*
      mutable_parameters();
  private:
  const ::gnostic::openapi::v3::ParameterOrReference& _internal_parameters(int index) const;
  ::gnostic::openapi::v3::ParameterOrReference* _internal_add_parameters();
  public:
  const ::gnostic::openapi::v3::ParameterOrReference& parameters(int index) const;
  ::gnostic::openapi::v3::ParameterOrReference* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >&
      parameters() const;

  // repeated .gnostic.openapi.v3.SecurityRequirement security = 11;
  int security_size() const;
  private:
  int _internal_security_size() const;
  public:
  void clear_security();
  ::gnostic::openapi::v3::SecurityRequirement* mutable_security(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >*
      mutable_security();
  private:
  const ::gnostic::openapi::v3::SecurityRequirement& _internal_security(int index) const;
  ::gnostic::openapi::v3::SecurityRequirement* _internal_add_security();
  public:
  const ::gnostic::openapi::v3::SecurityRequirement& security(int index) const;
  ::gnostic::openapi::v3::SecurityRequirement* add_security();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >&
      security() const;

  // repeated .gnostic.openapi.v3.Server servers = 12;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::gnostic::openapi::v3::Server* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >*
      mutable_servers();
  private:
  const ::gnostic::openapi::v3::Server& _internal_servers(int index) const;
  ::gnostic::openapi::v3::Server* _internal_add_servers();
  public:
  const ::gnostic::openapi::v3::Server& servers(int index) const;
  ::gnostic::openapi::v3::Server* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >&
      servers() const;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 13;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string summary = 2;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string operation_id = 5;
  void clear_operation_id();
  const std::string& operation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation_id();
  PROTOBUF_NODISCARD std::string* release_operation_id();
  void set_allocated_operation_id(std::string* operation_id);
  private:
  const std::string& _internal_operation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_id(const std::string& value);
  std::string* _internal_mutable_operation_id();
  public:

  // .gnostic.openapi.v3.ExternalDocs external_docs = 4;
  bool has_external_docs() const;
  private:
  bool _internal_has_external_docs() const;
  public:
  void clear_external_docs();
  const ::gnostic::openapi::v3::ExternalDocs& external_docs() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExternalDocs* release_external_docs();
  ::gnostic::openapi::v3::ExternalDocs* mutable_external_docs();
  void set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs);
  private:
  const ::gnostic::openapi::v3::ExternalDocs& _internal_external_docs() const;
  ::gnostic::openapi::v3::ExternalDocs* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::gnostic::openapi::v3::ExternalDocs* external_docs);
  ::gnostic::openapi::v3::ExternalDocs* unsafe_arena_release_external_docs();

  // .gnostic.openapi.v3.RequestBodyOrReference request_body = 7;
  bool has_request_body() const;
  private:
  bool _internal_has_request_body() const;
  public:
  void clear_request_body();
  const ::gnostic::openapi::v3::RequestBodyOrReference& request_body() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::RequestBodyOrReference* release_request_body();
  ::gnostic::openapi::v3::RequestBodyOrReference* mutable_request_body();
  void set_allocated_request_body(::gnostic::openapi::v3::RequestBodyOrReference* request_body);
  private:
  const ::gnostic::openapi::v3::RequestBodyOrReference& _internal_request_body() const;
  ::gnostic::openapi::v3::RequestBodyOrReference* _internal_mutable_request_body();
  public:
  void unsafe_arena_set_allocated_request_body(
      ::gnostic::openapi::v3::RequestBodyOrReference* request_body);
  ::gnostic::openapi::v3::RequestBodyOrReference* unsafe_arena_release_request_body();

  // .gnostic.openapi.v3.Responses responses = 8;
  bool has_responses() const;
  private:
  bool _internal_has_responses() const;
  public:
  void clear_responses();
  const ::gnostic::openapi::v3::Responses& responses() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Responses* release_responses();
  ::gnostic::openapi::v3::Responses* mutable_responses();
  void set_allocated_responses(::gnostic::openapi::v3::Responses* responses);
  private:
  const ::gnostic::openapi::v3::Responses& _internal_responses() const;
  ::gnostic::openapi::v3::Responses* _internal_mutable_responses();
  public:
  void unsafe_arena_set_allocated_responses(
      ::gnostic::openapi::v3::Responses* responses);
  ::gnostic::openapi::v3::Responses* unsafe_arena_release_responses();

  // .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
  bool has_callbacks() const;
  private:
  bool _internal_has_callbacks() const;
  public:
  void clear_callbacks();
  const ::gnostic::openapi::v3::CallbacksOrReferences& callbacks() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::CallbacksOrReferences* release_callbacks();
  ::gnostic::openapi::v3::CallbacksOrReferences* mutable_callbacks();
  void set_allocated_callbacks(::gnostic::openapi::v3::CallbacksOrReferences* callbacks);
  private:
  const ::gnostic::openapi::v3::CallbacksOrReferences& _internal_callbacks() const;
  ::gnostic::openapi::v3::CallbacksOrReferences* _internal_mutable_callbacks();
  public:
  void unsafe_arena_set_allocated_callbacks(
      ::gnostic::openapi::v3::CallbacksOrReferences* callbacks);
  ::gnostic::openapi::v3::CallbacksOrReferences* unsafe_arena_release_callbacks();

  // bool deprecated = 10;
  void clear_deprecated();
  bool deprecated() const;
  void set_deprecated(bool value);
  private:
  bool _internal_deprecated() const;
  void _internal_set_deprecated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference > parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement > security_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server > servers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_id_;
    ::gnostic::openapi::v3::ExternalDocs* external_docs_;
    ::gnostic::openapi::v3::RequestBodyOrReference* request_body_;
    ::gnostic::openapi::v3::Responses* responses_;
    ::gnostic::openapi::v3::CallbacksOrReferences* callbacks_;
    bool deprecated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Parameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Parameter) */ {
 public:
  inline Parameter() : Parameter(nullptr) {}
  ~Parameter() override;
  explicit PROTOBUF_CONSTEXPR Parameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Parameter(const Parameter& from);
  Parameter(Parameter&& from) noexcept
    : Parameter() {
    *this = ::std::move(from);
  }

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parameter& operator=(Parameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Parameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Parameter* internal_default_instance() {
    return reinterpret_cast<const Parameter*>(
               &_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(Parameter& a, Parameter& b) {
    a.Swap(&b);
  }
  inline void Swap(Parameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Parameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Parameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Parameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Parameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Parameter& from) {
    Parameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Parameter";
  }
  protected:
  explicit Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 14,
    kNameFieldNumber = 1,
    kInFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kStyleFieldNumber = 7,
    kSchemaFieldNumber = 10,
    kExampleFieldNumber = 11,
    kExamplesFieldNumber = 12,
    kContentFieldNumber = 13,
    kRequiredFieldNumber = 4,
    kDeprecatedFieldNumber = 5,
    kAllowEmptyValueFieldNumber = 6,
    kExplodeFieldNumber = 8,
    kAllowReservedFieldNumber = 9,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string in = 2;
  void clear_in();
  const std::string& in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_in();
  PROTOBUF_NODISCARD std::string* release_in();
  void set_allocated_in(std::string* in);
  private:
  const std::string& _internal_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in(const std::string& value);
  std::string* _internal_mutable_in();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string style = 7;
  void clear_style();
  const std::string& style() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_style(ArgT0&& arg0, ArgT... args);
  std::string* mutable_style();
  PROTOBUF_NODISCARD std::string* release_style();
  void set_allocated_style(std::string* style);
  private:
  const std::string& _internal_style() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_style(const std::string& value);
  std::string* _internal_mutable_style();
  public:

  // .gnostic.openapi.v3.SchemaOrReference schema = 10;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::gnostic::openapi::v3::SchemaOrReference& schema() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SchemaOrReference* release_schema();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_schema();
  void set_allocated_schema(::gnostic::openapi::v3::SchemaOrReference* schema);
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_schema() const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::gnostic::openapi::v3::SchemaOrReference* schema);
  ::gnostic::openapi::v3::SchemaOrReference* unsafe_arena_release_schema();

  // .gnostic.openapi.v3.Any example = 11;
  bool has_example() const;
  private:
  bool _internal_has_example() const;
  public:
  void clear_example();
  const ::gnostic::openapi::v3::Any& example() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Any* release_example();
  ::gnostic::openapi::v3::Any* mutable_example();
  void set_allocated_example(::gnostic::openapi::v3::Any* example);
  private:
  const ::gnostic::openapi::v3::Any& _internal_example() const;
  ::gnostic::openapi::v3::Any* _internal_mutable_example();
  public:
  void unsafe_arena_set_allocated_example(
      ::gnostic::openapi::v3::Any* example);
  ::gnostic::openapi::v3::Any* unsafe_arena_release_example();

  // .gnostic.openapi.v3.ExamplesOrReferences examples = 12;
  bool has_examples() const;
  private:
  bool _internal_has_examples() const;
  public:
  void clear_examples();
  const ::gnostic::openapi::v3::ExamplesOrReferences& examples() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExamplesOrReferences* release_examples();
  ::gnostic::openapi::v3::ExamplesOrReferences* mutable_examples();
  void set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples);
  private:
  const ::gnostic::openapi::v3::ExamplesOrReferences& _internal_examples() const;
  ::gnostic::openapi::v3::ExamplesOrReferences* _internal_mutable_examples();
  public:
  void unsafe_arena_set_allocated_examples(
      ::gnostic::openapi::v3::ExamplesOrReferences* examples);
  ::gnostic::openapi::v3::ExamplesOrReferences* unsafe_arena_release_examples();

  // .gnostic.openapi.v3.MediaTypes content = 13;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::gnostic::openapi::v3::MediaTypes& content() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::MediaTypes* release_content();
  ::gnostic::openapi::v3::MediaTypes* mutable_content();
  void set_allocated_content(::gnostic::openapi::v3::MediaTypes* content);
  private:
  const ::gnostic::openapi::v3::MediaTypes& _internal_content() const;
  ::gnostic::openapi::v3::MediaTypes* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::gnostic::openapi::v3::MediaTypes* content);
  ::gnostic::openapi::v3::MediaTypes* unsafe_arena_release_content();

  // bool required = 4;
  void clear_required();
  bool required() const;
  void set_required(bool value);
  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);
  public:

  // bool deprecated = 5;
  void clear_deprecated();
  bool deprecated() const;
  void set_deprecated(bool value);
  private:
  bool _internal_deprecated() const;
  void _internal_set_deprecated(bool value);
  public:

  // bool allow_empty_value = 6;
  void clear_allow_empty_value();
  bool allow_empty_value() const;
  void set_allow_empty_value(bool value);
  private:
  bool _internal_allow_empty_value() const;
  void _internal_set_allow_empty_value(bool value);
  public:

  // bool explode = 8;
  void clear_explode();
  bool explode() const;
  void set_explode(bool value);
  private:
  bool _internal_explode() const;
  void _internal_set_explode(bool value);
  public:

  // bool allow_reserved = 9;
  void clear_allow_reserved();
  bool allow_reserved() const;
  void set_allow_reserved(bool value);
  private:
  bool _internal_allow_reserved() const;
  void _internal_set_allow_reserved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Parameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr style_;
    ::gnostic::openapi::v3::SchemaOrReference* schema_;
    ::gnostic::openapi::v3::Any* example_;
    ::gnostic::openapi::v3::ExamplesOrReferences* examples_;
    ::gnostic::openapi::v3::MediaTypes* content_;
    bool required_;
    bool deprecated_;
    bool allow_empty_value_;
    bool explode_;
    bool allow_reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ParameterOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ParameterOrReference) */ {
 public:
  inline ParameterOrReference() : ParameterOrReference(nullptr) {}
  ~ParameterOrReference() override;
  explicit PROTOBUF_CONSTEXPR ParameterOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParameterOrReference(const ParameterOrReference& from);
  ParameterOrReference(ParameterOrReference&& from) noexcept
    : ParameterOrReference() {
    *this = ::std::move(from);
  }

  inline ParameterOrReference& operator=(const ParameterOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParameterOrReference& operator=(ParameterOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParameterOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kParameter = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const ParameterOrReference* internal_default_instance() {
    return reinterpret_cast<const ParameterOrReference*>(
               &_ParameterOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(ParameterOrReference& a, ParameterOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ParameterOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParameterOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParameterOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParameterOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParameterOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParameterOrReference& from) {
    ParameterOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ParameterOrReference";
  }
  protected:
  explicit ParameterOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParameterFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Parameter parameter = 1;
  bool has_parameter() const;
  private:
  bool _internal_has_parameter() const;
  public:
  void clear_parameter();
  const ::gnostic::openapi::v3::Parameter& parameter() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Parameter* release_parameter();
  ::gnostic::openapi::v3::Parameter* mutable_parameter();
  void set_allocated_parameter(::gnostic::openapi::v3::Parameter* parameter);
  private:
  const ::gnostic::openapi::v3::Parameter& _internal_parameter() const;
  ::gnostic::openapi::v3::Parameter* _internal_mutable_parameter();
  public:
  void unsafe_arena_set_allocated_parameter(
      ::gnostic::openapi::v3::Parameter* parameter);
  ::gnostic::openapi::v3::Parameter* unsafe_arena_release_parameter();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ParameterOrReference)
 private:
  class _Internal;
  void set_has_parameter();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Parameter* parameter_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ParametersOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ParametersOrReferences) */ {
 public:
  inline ParametersOrReferences() : ParametersOrReferences(nullptr) {}
  ~ParametersOrReferences() override;
  explicit PROTOBUF_CONSTEXPR ParametersOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParametersOrReferences(const ParametersOrReferences& from);
  ParametersOrReferences(ParametersOrReferences&& from) noexcept
    : ParametersOrReferences() {
    *this = ::std::move(from);
  }

  inline ParametersOrReferences& operator=(const ParametersOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParametersOrReferences& operator=(ParametersOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParametersOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParametersOrReferences* internal_default_instance() {
    return reinterpret_cast<const ParametersOrReferences*>(
               &_ParametersOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ParametersOrReferences& a, ParametersOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(ParametersOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParametersOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParametersOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParametersOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParametersOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParametersOrReferences& from) {
    ParametersOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParametersOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ParametersOrReferences";
  }
  protected:
  explicit ParametersOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedParameterOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedParameterOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedParameterOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedParameterOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedParameterOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedParameterOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedParameterOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ParametersOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedParameterOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class PathItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.PathItem) */ {
 public:
  inline PathItem() : PathItem(nullptr) {}
  ~PathItem() override;
  explicit PROTOBUF_CONSTEXPR PathItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathItem(const PathItem& from);
  PathItem(PathItem&& from) noexcept
    : PathItem() {
    *this = ::std::move(from);
  }

  inline PathItem& operator=(const PathItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathItem& operator=(PathItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathItem* internal_default_instance() {
    return reinterpret_cast<const PathItem*>(
               &_PathItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(PathItem& a, PathItem& b) {
    a.Swap(&b);
  }
  inline void Swap(PathItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathItem& from) {
    PathItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.PathItem";
  }
  protected:
  explicit PathItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 12,
    kParametersFieldNumber = 13,
    kSpecificationExtensionFieldNumber = 14,
    kRefFieldNumber = 1,
    kSummaryFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kGetFieldNumber = 4,
    kPutFieldNumber = 5,
    kPostFieldNumber = 6,
    kDeleteFieldNumber = 7,
    kOptionsFieldNumber = 8,
    kHeadFieldNumber = 9,
    kPatchFieldNumber = 10,
    kTraceFieldNumber = 11,
  };
  // repeated .gnostic.openapi.v3.Server servers = 12;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::gnostic::openapi::v3::Server* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >*
      mutable_servers();
  private:
  const ::gnostic::openapi::v3::Server& _internal_servers(int index) const;
  ::gnostic::openapi::v3::Server* _internal_add_servers();
  public:
  const ::gnostic::openapi::v3::Server& servers(int index) const;
  ::gnostic::openapi::v3::Server* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >&
      servers() const;

  // repeated .gnostic.openapi.v3.ParameterOrReference parameters = 13;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::gnostic::openapi::v3::ParameterOrReference* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >*
      mutable_parameters();
  private:
  const ::gnostic::openapi::v3::ParameterOrReference& _internal_parameters(int index) const;
  ::gnostic::openapi::v3::ParameterOrReference* _internal_add_parameters();
  public:
  const ::gnostic::openapi::v3::ParameterOrReference& parameters(int index) const;
  ::gnostic::openapi::v3::ParameterOrReference* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >&
      parameters() const;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string _ref = 1;
  void clear__ref();
  const std::string& _ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable__ref();
  PROTOBUF_NODISCARD std::string* release__ref();
  void set_allocated__ref(std::string* _ref);
  private:
  const std::string& _internal__ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__ref(const std::string& value);
  std::string* _internal_mutable__ref();
  public:

  // string summary = 2;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .gnostic.openapi.v3.Operation get = 4;
  bool has_get() const;
  private:
  bool _internal_has_get() const;
  public:
  void clear_get();
  const ::gnostic::openapi::v3::Operation& get() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_get();
  ::gnostic::openapi::v3::Operation* mutable_get();
  void set_allocated_get(::gnostic::openapi::v3::Operation* get);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_get() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_get();
  public:
  void unsafe_arena_set_allocated_get(
      ::gnostic::openapi::v3::Operation* get);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_get();

  // .gnostic.openapi.v3.Operation put = 5;
  bool has_put() const;
  private:
  bool _internal_has_put() const;
  public:
  void clear_put();
  const ::gnostic::openapi::v3::Operation& put() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_put();
  ::gnostic::openapi::v3::Operation* mutable_put();
  void set_allocated_put(::gnostic::openapi::v3::Operation* put);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_put() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_put();
  public:
  void unsafe_arena_set_allocated_put(
      ::gnostic::openapi::v3::Operation* put);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_put();

  // .gnostic.openapi.v3.Operation post = 6;
  bool has_post() const;
  private:
  bool _internal_has_post() const;
  public:
  void clear_post();
  const ::gnostic::openapi::v3::Operation& post() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_post();
  ::gnostic::openapi::v3::Operation* mutable_post();
  void set_allocated_post(::gnostic::openapi::v3::Operation* post);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_post() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_post();
  public:
  void unsafe_arena_set_allocated_post(
      ::gnostic::openapi::v3::Operation* post);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_post();

  // .gnostic.openapi.v3.Operation delete = 7;
  bool has_delete_() const;
  private:
  bool _internal_has_delete_() const;
  public:
  void clear_delete_();
  const ::gnostic::openapi::v3::Operation& delete_() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_delete_();
  ::gnostic::openapi::v3::Operation* mutable_delete_();
  void set_allocated_delete_(::gnostic::openapi::v3::Operation* delete_);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_delete_() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_delete_();
  public:
  void unsafe_arena_set_allocated_delete_(
      ::gnostic::openapi::v3::Operation* delete_);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_delete_();

  // .gnostic.openapi.v3.Operation options = 8;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::gnostic::openapi::v3::Operation& options() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_options();
  ::gnostic::openapi::v3::Operation* mutable_options();
  void set_allocated_options(::gnostic::openapi::v3::Operation* options);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_options() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::gnostic::openapi::v3::Operation* options);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_options();

  // .gnostic.openapi.v3.Operation head = 9;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::gnostic::openapi::v3::Operation& head() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_head();
  ::gnostic::openapi::v3::Operation* mutable_head();
  void set_allocated_head(::gnostic::openapi::v3::Operation* head);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_head() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::gnostic::openapi::v3::Operation* head);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_head();

  // .gnostic.openapi.v3.Operation patch = 10;
  bool has_patch() const;
  private:
  bool _internal_has_patch() const;
  public:
  void clear_patch();
  const ::gnostic::openapi::v3::Operation& patch() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_patch();
  ::gnostic::openapi::v3::Operation* mutable_patch();
  void set_allocated_patch(::gnostic::openapi::v3::Operation* patch);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_patch() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_patch();
  public:
  void unsafe_arena_set_allocated_patch(
      ::gnostic::openapi::v3::Operation* patch);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_patch();

  // .gnostic.openapi.v3.Operation trace = 11;
  bool has_trace() const;
  private:
  bool _internal_has_trace() const;
  public:
  void clear_trace();
  const ::gnostic::openapi::v3::Operation& trace() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Operation* release_trace();
  ::gnostic::openapi::v3::Operation* mutable_trace();
  void set_allocated_trace(::gnostic::openapi::v3::Operation* trace);
  private:
  const ::gnostic::openapi::v3::Operation& _internal_trace() const;
  ::gnostic::openapi::v3::Operation* _internal_mutable_trace();
  public:
  void unsafe_arena_set_allocated_trace(
      ::gnostic::openapi::v3::Operation* trace);
  ::gnostic::openapi::v3::Operation* unsafe_arena_release_trace();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.PathItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server > servers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference > parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::gnostic::openapi::v3::Operation* get_;
    ::gnostic::openapi::v3::Operation* put_;
    ::gnostic::openapi::v3::Operation* post_;
    ::gnostic::openapi::v3::Operation* delete__;
    ::gnostic::openapi::v3::Operation* options_;
    ::gnostic::openapi::v3::Operation* head_;
    ::gnostic::openapi::v3::Operation* patch_;
    ::gnostic::openapi::v3::Operation* trace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Paths final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Paths) */ {
 public:
  inline Paths() : Paths(nullptr) {}
  ~Paths() override;
  explicit PROTOBUF_CONSTEXPR Paths(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Paths(const Paths& from);
  Paths(Paths&& from) noexcept
    : Paths() {
    *this = ::std::move(from);
  }

  inline Paths& operator=(const Paths& from) {
    CopyFrom(from);
    return *this;
  }
  inline Paths& operator=(Paths&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Paths& default_instance() {
    return *internal_default_instance();
  }
  static inline const Paths* internal_default_instance() {
    return reinterpret_cast<const Paths*>(
               &_Paths_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(Paths& a, Paths& b) {
    a.Swap(&b);
  }
  inline void Swap(Paths* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Paths* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Paths* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Paths>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Paths& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Paths& from) {
    Paths::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Paths* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Paths";
  }
  protected:
  explicit Paths(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kSpecificationExtensionFieldNumber = 2,
  };
  // repeated .gnostic.openapi.v3.NamedPathItem path = 1;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  ::gnostic::openapi::v3::NamedPathItem* mutable_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >*
      mutable_path();
  private:
  const ::gnostic::openapi::v3::NamedPathItem& _internal_path(int index) const;
  ::gnostic::openapi::v3::NamedPathItem* _internal_add_path();
  public:
  const ::gnostic::openapi::v3::NamedPathItem& path(int index) const;
  ::gnostic::openapi::v3::NamedPathItem* add_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >&
      path() const;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Paths)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem > path_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Properties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Properties) */ {
 public:
  inline Properties() : Properties(nullptr) {}
  ~Properties() override;
  explicit PROTOBUF_CONSTEXPR Properties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Properties(const Properties& from);
  Properties(Properties&& from) noexcept
    : Properties() {
    *this = ::std::move(from);
  }

  inline Properties& operator=(const Properties& from) {
    CopyFrom(from);
    return *this;
  }
  inline Properties& operator=(Properties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Properties& default_instance() {
    return *internal_default_instance();
  }
  static inline const Properties* internal_default_instance() {
    return reinterpret_cast<const Properties*>(
               &_Properties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(Properties& a, Properties& b) {
    a.Swap(&b);
  }
  inline void Swap(Properties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Properties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Properties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Properties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Properties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Properties& from) {
    Properties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Properties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Properties";
  }
  protected:
  explicit Properties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedSchemaOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedSchemaOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedSchemaOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedSchemaOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedSchemaOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Properties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Reference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Reference) */ {
 public:
  inline Reference() : Reference(nullptr) {}
  ~Reference() override;
  explicit PROTOBUF_CONSTEXPR Reference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reference(const Reference& from);
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reference& operator=(Reference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }
  inline void Swap(Reference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Reference& from) {
    Reference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Reference";
  }
  protected:
  explicit Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefFieldNumber = 1,
    kSummaryFieldNumber = 2,
    kDescriptionFieldNumber = 3,
  };
  // string _ref = 1;
  void clear__ref();
  const std::string& _ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable__ref();
  PROTOBUF_NODISCARD std::string* release__ref();
  void set_allocated__ref(std::string* _ref);
  private:
  const std::string& _internal__ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__ref(const std::string& value);
  std::string* _internal_mutable__ref();
  public:

  // string summary = 2;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Reference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class RequestBodiesOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.RequestBodiesOrReferences) */ {
 public:
  inline RequestBodiesOrReferences() : RequestBodiesOrReferences(nullptr) {}
  ~RequestBodiesOrReferences() override;
  explicit PROTOBUF_CONSTEXPR RequestBodiesOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBodiesOrReferences(const RequestBodiesOrReferences& from);
  RequestBodiesOrReferences(RequestBodiesOrReferences&& from) noexcept
    : RequestBodiesOrReferences() {
    *this = ::std::move(from);
  }

  inline RequestBodiesOrReferences& operator=(const RequestBodiesOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBodiesOrReferences& operator=(RequestBodiesOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBodiesOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBodiesOrReferences* internal_default_instance() {
    return reinterpret_cast<const RequestBodiesOrReferences*>(
               &_RequestBodiesOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(RequestBodiesOrReferences& a, RequestBodiesOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBodiesOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBodiesOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBodiesOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBodiesOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBodiesOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBodiesOrReferences& from) {
    RequestBodiesOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBodiesOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.RequestBodiesOrReferences";
  }
  protected:
  explicit RequestBodiesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedRequestBodyOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedRequestBodyOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedRequestBodyOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedRequestBodyOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedRequestBodyOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedRequestBodyOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedRequestBodyOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.RequestBodiesOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedRequestBodyOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class RequestBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.RequestBody) */ {
 public:
  inline RequestBody() : RequestBody(nullptr) {}
  ~RequestBody() override;
  explicit PROTOBUF_CONSTEXPR RequestBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBody(const RequestBody& from);
  RequestBody(RequestBody&& from) noexcept
    : RequestBody() {
    *this = ::std::move(from);
  }

  inline RequestBody& operator=(const RequestBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBody& operator=(RequestBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBody* internal_default_instance() {
    return reinterpret_cast<const RequestBody*>(
               &_RequestBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(RequestBody& a, RequestBody& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBody& from) {
    RequestBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.RequestBody";
  }
  protected:
  explicit RequestBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 4,
    kDescriptionFieldNumber = 1,
    kContentFieldNumber = 2,
    kRequiredFieldNumber = 3,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .gnostic.openapi.v3.MediaTypes content = 2;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::gnostic::openapi::v3::MediaTypes& content() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::MediaTypes* release_content();
  ::gnostic::openapi::v3::MediaTypes* mutable_content();
  void set_allocated_content(::gnostic::openapi::v3::MediaTypes* content);
  private:
  const ::gnostic::openapi::v3::MediaTypes& _internal_content() const;
  ::gnostic::openapi::v3::MediaTypes* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::gnostic::openapi::v3::MediaTypes* content);
  ::gnostic::openapi::v3::MediaTypes* unsafe_arena_release_content();

  // bool required = 3;
  void clear_required();
  bool required() const;
  void set_required(bool value);
  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.RequestBody)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::gnostic::openapi::v3::MediaTypes* content_;
    bool required_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class RequestBodyOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.RequestBodyOrReference) */ {
 public:
  inline RequestBodyOrReference() : RequestBodyOrReference(nullptr) {}
  ~RequestBodyOrReference() override;
  explicit PROTOBUF_CONSTEXPR RequestBodyOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBodyOrReference(const RequestBodyOrReference& from);
  RequestBodyOrReference(RequestBodyOrReference&& from) noexcept
    : RequestBodyOrReference() {
    *this = ::std::move(from);
  }

  inline RequestBodyOrReference& operator=(const RequestBodyOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBodyOrReference& operator=(RequestBodyOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBodyOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kRequestBody = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const RequestBodyOrReference* internal_default_instance() {
    return reinterpret_cast<const RequestBodyOrReference*>(
               &_RequestBodyOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(RequestBodyOrReference& a, RequestBodyOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBodyOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBodyOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBodyOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBodyOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBodyOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBodyOrReference& from) {
    RequestBodyOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBodyOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.RequestBodyOrReference";
  }
  protected:
  explicit RequestBodyOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestBodyFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.RequestBody request_body = 1;
  bool has_request_body() const;
  private:
  bool _internal_has_request_body() const;
  public:
  void clear_request_body();
  const ::gnostic::openapi::v3::RequestBody& request_body() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::RequestBody* release_request_body();
  ::gnostic::openapi::v3::RequestBody* mutable_request_body();
  void set_allocated_request_body(::gnostic::openapi::v3::RequestBody* request_body);
  private:
  const ::gnostic::openapi::v3::RequestBody& _internal_request_body() const;
  ::gnostic::openapi::v3::RequestBody* _internal_mutable_request_body();
  public:
  void unsafe_arena_set_allocated_request_body(
      ::gnostic::openapi::v3::RequestBody* request_body);
  ::gnostic::openapi::v3::RequestBody* unsafe_arena_release_request_body();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.RequestBodyOrReference)
 private:
  class _Internal;
  void set_has_request_body();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::RequestBody* request_body_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 5,
    kDescriptionFieldNumber = 1,
    kHeadersFieldNumber = 2,
    kContentFieldNumber = 3,
    kLinksFieldNumber = 4,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .gnostic.openapi.v3.HeadersOrReferences headers = 2;
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;
  public:
  void clear_headers();
  const ::gnostic::openapi::v3::HeadersOrReferences& headers() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::HeadersOrReferences* release_headers();
  ::gnostic::openapi::v3::HeadersOrReferences* mutable_headers();
  void set_allocated_headers(::gnostic::openapi::v3::HeadersOrReferences* headers);
  private:
  const ::gnostic::openapi::v3::HeadersOrReferences& _internal_headers() const;
  ::gnostic::openapi::v3::HeadersOrReferences* _internal_mutable_headers();
  public:
  void unsafe_arena_set_allocated_headers(
      ::gnostic::openapi::v3::HeadersOrReferences* headers);
  ::gnostic::openapi::v3::HeadersOrReferences* unsafe_arena_release_headers();

  // .gnostic.openapi.v3.MediaTypes content = 3;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::gnostic::openapi::v3::MediaTypes& content() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::MediaTypes* release_content();
  ::gnostic::openapi::v3::MediaTypes* mutable_content();
  void set_allocated_content(::gnostic::openapi::v3::MediaTypes* content);
  private:
  const ::gnostic::openapi::v3::MediaTypes& _internal_content() const;
  ::gnostic::openapi::v3::MediaTypes* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::gnostic::openapi::v3::MediaTypes* content);
  ::gnostic::openapi::v3::MediaTypes* unsafe_arena_release_content();

  // .gnostic.openapi.v3.LinksOrReferences links = 4;
  bool has_links() const;
  private:
  bool _internal_has_links() const;
  public:
  void clear_links();
  const ::gnostic::openapi::v3::LinksOrReferences& links() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::LinksOrReferences* release_links();
  ::gnostic::openapi::v3::LinksOrReferences* mutable_links();
  void set_allocated_links(::gnostic::openapi::v3::LinksOrReferences* links);
  private:
  const ::gnostic::openapi::v3::LinksOrReferences& _internal_links() const;
  ::gnostic::openapi::v3::LinksOrReferences* _internal_mutable_links();
  public:
  void unsafe_arena_set_allocated_links(
      ::gnostic::openapi::v3::LinksOrReferences* links);
  ::gnostic::openapi::v3::LinksOrReferences* unsafe_arena_release_links();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::gnostic::openapi::v3::HeadersOrReferences* headers_;
    ::gnostic::openapi::v3::MediaTypes* content_;
    ::gnostic::openapi::v3::LinksOrReferences* links_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ResponseOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ResponseOrReference) */ {
 public:
  inline ResponseOrReference() : ResponseOrReference(nullptr) {}
  ~ResponseOrReference() override;
  explicit PROTOBUF_CONSTEXPR ResponseOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseOrReference(const ResponseOrReference& from);
  ResponseOrReference(ResponseOrReference&& from) noexcept
    : ResponseOrReference() {
    *this = ::std::move(from);
  }

  inline ResponseOrReference& operator=(const ResponseOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseOrReference& operator=(ResponseOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kResponse = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const ResponseOrReference* internal_default_instance() {
    return reinterpret_cast<const ResponseOrReference*>(
               &_ResponseOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ResponseOrReference& a, ResponseOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseOrReference& from) {
    ResponseOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ResponseOrReference";
  }
  protected:
  explicit ResponseOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::gnostic::openapi::v3::Response& response() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Response* release_response();
  ::gnostic::openapi::v3::Response* mutable_response();
  void set_allocated_response(::gnostic::openapi::v3::Response* response);
  private:
  const ::gnostic::openapi::v3::Response& _internal_response() const;
  ::gnostic::openapi::v3::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::gnostic::openapi::v3::Response* response);
  ::gnostic::openapi::v3::Response* unsafe_arena_release_response();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ResponseOrReference)
 private:
  class _Internal;
  void set_has_response();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Response* response_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Responses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Responses) */ {
 public:
  inline Responses() : Responses(nullptr) {}
  ~Responses() override;
  explicit PROTOBUF_CONSTEXPR Responses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Responses(const Responses& from);
  Responses(Responses&& from) noexcept
    : Responses() {
    *this = ::std::move(from);
  }

  inline Responses& operator=(const Responses& from) {
    CopyFrom(from);
    return *this;
  }
  inline Responses& operator=(Responses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Responses& default_instance() {
    return *internal_default_instance();
  }
  static inline const Responses* internal_default_instance() {
    return reinterpret_cast<const Responses*>(
               &_Responses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Responses& a, Responses& b) {
    a.Swap(&b);
  }
  inline void Swap(Responses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Responses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Responses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Responses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Responses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Responses& from) {
    Responses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Responses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Responses";
  }
  protected:
  explicit Responses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseOrReferenceFieldNumber = 2,
    kSpecificationExtensionFieldNumber = 3,
    kDefaultFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2;
  int response_or_reference_size() const;
  private:
  int _internal_response_or_reference_size() const;
  public:
  void clear_response_or_reference();
  ::gnostic::openapi::v3::NamedResponseOrReference* mutable_response_or_reference(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >*
      mutable_response_or_reference();
  private:
  const ::gnostic::openapi::v3::NamedResponseOrReference& _internal_response_or_reference(int index) const;
  ::gnostic::openapi::v3::NamedResponseOrReference* _internal_add_response_or_reference();
  public:
  const ::gnostic::openapi::v3::NamedResponseOrReference& response_or_reference(int index) const;
  ::gnostic::openapi::v3::NamedResponseOrReference* add_response_or_reference();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >&
      response_or_reference() const;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // .gnostic.openapi.v3.ResponseOrReference default = 1;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  const ::gnostic::openapi::v3::ResponseOrReference& default_() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ResponseOrReference* release_default_();
  ::gnostic::openapi::v3::ResponseOrReference* mutable_default_();
  void set_allocated_default_(::gnostic::openapi::v3::ResponseOrReference* default_);
  private:
  const ::gnostic::openapi::v3::ResponseOrReference& _internal_default_() const;
  ::gnostic::openapi::v3::ResponseOrReference* _internal_mutable_default_();
  public:
  void unsafe_arena_set_allocated_default_(
      ::gnostic::openapi::v3::ResponseOrReference* default_);
  ::gnostic::openapi::v3::ResponseOrReference* unsafe_arena_release_default_();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Responses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference > response_or_reference_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::gnostic::openapi::v3::ResponseOrReference* default__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ResponsesOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ResponsesOrReferences) */ {
 public:
  inline ResponsesOrReferences() : ResponsesOrReferences(nullptr) {}
  ~ResponsesOrReferences() override;
  explicit PROTOBUF_CONSTEXPR ResponsesOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponsesOrReferences(const ResponsesOrReferences& from);
  ResponsesOrReferences(ResponsesOrReferences&& from) noexcept
    : ResponsesOrReferences() {
    *this = ::std::move(from);
  }

  inline ResponsesOrReferences& operator=(const ResponsesOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponsesOrReferences& operator=(ResponsesOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponsesOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponsesOrReferences* internal_default_instance() {
    return reinterpret_cast<const ResponsesOrReferences*>(
               &_ResponsesOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(ResponsesOrReferences& a, ResponsesOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponsesOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponsesOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponsesOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponsesOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponsesOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponsesOrReferences& from) {
    ResponsesOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsesOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ResponsesOrReferences";
  }
  protected:
  explicit ResponsesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedResponseOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedResponseOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedResponseOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedResponseOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedResponseOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ResponsesOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  explicit PROTOBUF_CONSTEXPR Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Schema& from) {
    Schema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredFieldNumber = 23,
    kEnumFieldNumber = 24,
    kAllOfFieldNumber = 26,
    kOneOfFieldNumber = 27,
    kAnyOfFieldNumber = 28,
    kSpecificationExtensionFieldNumber = 36,
    kTitleFieldNumber = 9,
    kPatternFieldNumber = 17,
    kTypeFieldNumber = 25,
    kDescriptionFieldNumber = 34,
    kFormatFieldNumber = 35,
    kDiscriminatorFieldNumber = 2,
    kXmlFieldNumber = 5,
    kExternalDocsFieldNumber = 6,
    kExampleFieldNumber = 7,
    kNotFieldNumber = 29,
    kItemsFieldNumber = 30,
    kPropertiesFieldNumber = 31,
    kAdditionalPropertiesFieldNumber = 32,
    kDefaultFieldNumber = 33,
    kNullableFieldNumber = 1,
    kReadOnlyFieldNumber = 3,
    kWriteOnlyFieldNumber = 4,
    kDeprecatedFieldNumber = 8,
    kExclusiveMaximumFieldNumber = 12,
    kExclusiveMinimumFieldNumber = 14,
    kUniqueItemsFieldNumber = 20,
    kMultipleOfFieldNumber = 10,
    kMaximumFieldNumber = 11,
    kMinimumFieldNumber = 13,
    kMaxLengthFieldNumber = 15,
    kMinLengthFieldNumber = 16,
    kMaxItemsFieldNumber = 18,
    kMinItemsFieldNumber = 19,
    kMaxPropertiesFieldNumber = 21,
    kMinPropertiesFieldNumber = 22,
  };
  // repeated string required = 23;
  int required_size() const;
  private:
  int _internal_required_size() const;
  public:
  void clear_required();
  const std::string& required(int index) const;
  std::string* mutable_required(int index);
  void set_required(int index, const std::string& value);
  void set_required(int index, std::string&& value);
  void set_required(int index, const char* value);
  void set_required(int index, const char* value, size_t size);
  std::string* add_required();
  void add_required(const std::string& value);
  void add_required(std::string&& value);
  void add_required(const char* value);
  void add_required(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required();
  private:
  const std::string& _internal_required(int index) const;
  std::string* _internal_add_required();
  public:

  // repeated .gnostic.openapi.v3.Any enum = 24;
  int enum__size() const;
  private:
  int _internal_enum__size() const;
  public:
  void clear_enum_();
  ::gnostic::openapi::v3::Any* mutable_enum_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Any >*
      mutable_enum_();
  private:
  const ::gnostic::openapi::v3::Any& _internal_enum_(int index) const;
  ::gnostic::openapi::v3::Any* _internal_add_enum_();
  public:
  const ::gnostic::openapi::v3::Any& enum_(int index) const;
  ::gnostic::openapi::v3::Any* add_enum_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Any >&
      enum_() const;

  // repeated .gnostic.openapi.v3.SchemaOrReference all_of = 26;
  int all_of_size() const;
  private:
  int _internal_all_of_size() const;
  public:
  void clear_all_of();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_all_of(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
      mutable_all_of();
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_all_of(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_add_all_of();
  public:
  const ::gnostic::openapi::v3::SchemaOrReference& all_of(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* add_all_of();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
      all_of() const;

  // repeated .gnostic.openapi.v3.SchemaOrReference one_of = 27;
  int one_of_size() const;
  private:
  int _internal_one_of_size() const;
  public:
  void clear_one_of();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_one_of(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
      mutable_one_of();
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_one_of(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_add_one_of();
  public:
  const ::gnostic::openapi::v3::SchemaOrReference& one_of(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* add_one_of();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
      one_of() const;

  // repeated .gnostic.openapi.v3.SchemaOrReference any_of = 28;
  int any_of_size() const;
  private:
  int _internal_any_of_size() const;
  public:
  void clear_any_of();
  ::gnostic::openapi::v3::SchemaOrReference* mutable_any_of(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
      mutable_any_of();
  private:
  const ::gnostic::openapi::v3::SchemaOrReference& _internal_any_of(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* _internal_add_any_of();
  public:
  const ::gnostic::openapi::v3::SchemaOrReference& any_of(int index) const;
  ::gnostic::openapi::v3::SchemaOrReference* add_any_of();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
      any_of() const;

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 36;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string title = 9;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string pattern = 17;
  void clear_pattern();
  const std::string& pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* pattern);
  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
  std::string* _internal_mutable_pattern();
  public:

  // string type = 25;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string description = 34;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string format = 35;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // .gnostic.openapi.v3.Discriminator discriminator = 2;
  bool has_discriminator() const;
  private:
  bool _internal_has_discriminator() const;
  public:
  void clear_discriminator();
  const ::gnostic::openapi::v3::Discriminator& discriminator() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Discriminator* release_discriminator();
  ::gnostic::openapi::v3::Discriminator* mutable_discriminator();
  void set_allocated_discriminator(::gnostic::openapi::v3::Discriminator* discriminator);
  private:
  const ::gnostic::openapi::v3::Discriminator& _internal_discriminator() const;
  ::gnostic::openapi::v3::Discriminator* _internal_mutable_discriminator();
  public:
  void unsafe_arena_set_allocated_discriminator(
      ::gnostic::openapi::v3::Discriminator* discriminator);
  ::gnostic::openapi::v3::Discriminator* unsafe_arena_release_discriminator();

  // .gnostic.openapi.v3.Xml xml = 5;
  bool has_xml() const;
  private:
  bool _internal_has_xml() const;
  public:
  void clear_xml();
  const ::gnostic::openapi::v3::Xml& xml() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Xml* release_xml();
  ::gnostic::openapi::v3::Xml* mutable_xml();
  void set_allocated_xml(::gnostic::openapi::v3::Xml* xml);
  private:
  const ::gnostic::openapi::v3::Xml& _internal_xml() const;
  ::gnostic::openapi::v3::Xml* _internal_mutable_xml();
  public:
  void unsafe_arena_set_allocated_xml(
      ::gnostic::openapi::v3::Xml* xml);
  ::gnostic::openapi::v3::Xml* unsafe_arena_release_xml();

  // .gnostic.openapi.v3.ExternalDocs external_docs = 6;
  bool has_external_docs() const;
  private:
  bool _internal_has_external_docs() const;
  public:
  void clear_external_docs();
  const ::gnostic::openapi::v3::ExternalDocs& external_docs() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExternalDocs* release_external_docs();
  ::gnostic::openapi::v3::ExternalDocs* mutable_external_docs();
  void set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs);
  private:
  const ::gnostic::openapi::v3::ExternalDocs& _internal_external_docs() const;
  ::gnostic::openapi::v3::ExternalDocs* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::gnostic::openapi::v3::ExternalDocs* external_docs);
  ::gnostic::openapi::v3::ExternalDocs* unsafe_arena_release_external_docs();

  // .gnostic.openapi.v3.Any example = 7;
  bool has_example() const;
  private:
  bool _internal_has_example() const;
  public:
  void clear_example();
  const ::gnostic::openapi::v3::Any& example() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Any* release_example();
  ::gnostic::openapi::v3::Any* mutable_example();
  void set_allocated_example(::gnostic::openapi::v3::Any* example);
  private:
  const ::gnostic::openapi::v3::Any& _internal_example() const;
  ::gnostic::openapi::v3::Any* _internal_mutable_example();
  public:
  void unsafe_arena_set_allocated_example(
      ::gnostic::openapi::v3::Any* example);
  ::gnostic::openapi::v3::Any* unsafe_arena_release_example();

  // .gnostic.openapi.v3.Schema not = 29;
  bool has_not_() const;
  private:
  bool _internal_has_not_() const;
  public:
  void clear_not_();
  const ::gnostic::openapi::v3::Schema& not_() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Schema* release_not_();
  ::gnostic::openapi::v3::Schema* mutable_not_();
  void set_allocated_not_(::gnostic::openapi::v3::Schema* not_);
  private:
  const ::gnostic::openapi::v3::Schema& _internal_not_() const;
  ::gnostic::openapi::v3::Schema* _internal_mutable_not_();
  public:
  void unsafe_arena_set_allocated_not_(
      ::gnostic::openapi::v3::Schema* not_);
  ::gnostic::openapi::v3::Schema* unsafe_arena_release_not_();

  // .gnostic.openapi.v3.ItemsItem items = 30;
  bool has_items() const;
  private:
  bool _internal_has_items() const;
  public:
  void clear_items();
  const ::gnostic::openapi::v3::ItemsItem& items() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ItemsItem* release_items();
  ::gnostic::openapi::v3::ItemsItem* mutable_items();
  void set_allocated_items(::gnostic::openapi::v3::ItemsItem* items);
  private:
  const ::gnostic::openapi::v3::ItemsItem& _internal_items() const;
  ::gnostic::openapi::v3::ItemsItem* _internal_mutable_items();
  public:
  void unsafe_arena_set_allocated_items(
      ::gnostic::openapi::v3::ItemsItem* items);
  ::gnostic::openapi::v3::ItemsItem* unsafe_arena_release_items();

  // .gnostic.openapi.v3.Properties properties = 31;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::gnostic::openapi::v3::Properties& properties() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Properties* release_properties();
  ::gnostic::openapi::v3::Properties* mutable_properties();
  void set_allocated_properties(::gnostic::openapi::v3::Properties* properties);
  private:
  const ::gnostic::openapi::v3::Properties& _internal_properties() const;
  ::gnostic::openapi::v3::Properties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::gnostic::openapi::v3::Properties* properties);
  ::gnostic::openapi::v3::Properties* unsafe_arena_release_properties();

  // .gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32;
  bool has_additional_properties() const;
  private:
  bool _internal_has_additional_properties() const;
  public:
  void clear_additional_properties();
  const ::gnostic::openapi::v3::AdditionalPropertiesItem& additional_properties() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::AdditionalPropertiesItem* release_additional_properties();
  ::gnostic::openapi::v3::AdditionalPropertiesItem* mutable_additional_properties();
  void set_allocated_additional_properties(::gnostic::openapi::v3::AdditionalPropertiesItem* additional_properties);
  private:
  const ::gnostic::openapi::v3::AdditionalPropertiesItem& _internal_additional_properties() const;
  ::gnostic::openapi::v3::AdditionalPropertiesItem* _internal_mutable_additional_properties();
  public:
  void unsafe_arena_set_allocated_additional_properties(
      ::gnostic::openapi::v3::AdditionalPropertiesItem* additional_properties);
  ::gnostic::openapi::v3::AdditionalPropertiesItem* unsafe_arena_release_additional_properties();

  // .gnostic.openapi.v3.DefaultType default = 33;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  const ::gnostic::openapi::v3::DefaultType& default_() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::DefaultType* release_default_();
  ::gnostic::openapi::v3::DefaultType* mutable_default_();
  void set_allocated_default_(::gnostic::openapi::v3::DefaultType* default_);
  private:
  const ::gnostic::openapi::v3::DefaultType& _internal_default_() const;
  ::gnostic::openapi::v3::DefaultType* _internal_mutable_default_();
  public:
  void unsafe_arena_set_allocated_default_(
      ::gnostic::openapi::v3::DefaultType* default_);
  ::gnostic::openapi::v3::DefaultType* unsafe_arena_release_default_();

  // bool nullable = 1;
  void clear_nullable();
  bool nullable() const;
  void set_nullable(bool value);
  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);
  public:

  // bool read_only = 3;
  void clear_read_only();
  bool read_only() const;
  void set_read_only(bool value);
  private:
  bool _internal_read_only() const;
  void _internal_set_read_only(bool value);
  public:

  // bool write_only = 4;
  void clear_write_only();
  bool write_only() const;
  void set_write_only(bool value);
  private:
  bool _internal_write_only() const;
  void _internal_set_write_only(bool value);
  public:

  // bool deprecated = 8;
  void clear_deprecated();
  bool deprecated() const;
  void set_deprecated(bool value);
  private:
  bool _internal_deprecated() const;
  void _internal_set_deprecated(bool value);
  public:

  // bool exclusive_maximum = 12;
  void clear_exclusive_maximum();
  bool exclusive_maximum() const;
  void set_exclusive_maximum(bool value);
  private:
  bool _internal_exclusive_maximum() const;
  void _internal_set_exclusive_maximum(bool value);
  public:

  // bool exclusive_minimum = 14;
  void clear_exclusive_minimum();
  bool exclusive_minimum() const;
  void set_exclusive_minimum(bool value);
  private:
  bool _internal_exclusive_minimum() const;
  void _internal_set_exclusive_minimum(bool value);
  public:

  // bool unique_items = 20;
  void clear_unique_items();
  bool unique_items() const;
  void set_unique_items(bool value);
  private:
  bool _internal_unique_items() const;
  void _internal_set_unique_items(bool value);
  public:

  // double multiple_of = 10;
  void clear_multiple_of();
  double multiple_of() const;
  void set_multiple_of(double value);
  private:
  double _internal_multiple_of() const;
  void _internal_set_multiple_of(double value);
  public:

  // double maximum = 11;
  void clear_maximum();
  double maximum() const;
  void set_maximum(double value);
  private:
  double _internal_maximum() const;
  void _internal_set_maximum(double value);
  public:

  // double minimum = 13;
  void clear_minimum();
  double minimum() const;
  void set_minimum(double value);
  private:
  double _internal_minimum() const;
  void _internal_set_minimum(double value);
  public:

  // int64 max_length = 15;
  void clear_max_length();
  int64_t max_length() const;
  void set_max_length(int64_t value);
  private:
  int64_t _internal_max_length() const;
  void _internal_set_max_length(int64_t value);
  public:

  // int64 min_length = 16;
  void clear_min_length();
  int64_t min_length() const;
  void set_min_length(int64_t value);
  private:
  int64_t _internal_min_length() const;
  void _internal_set_min_length(int64_t value);
  public:

  // int64 max_items = 18;
  void clear_max_items();
  int64_t max_items() const;
  void set_max_items(int64_t value);
  private:
  int64_t _internal_max_items() const;
  void _internal_set_max_items(int64_t value);
  public:

  // int64 min_items = 19;
  void clear_min_items();
  int64_t min_items() const;
  void set_min_items(int64_t value);
  private:
  int64_t _internal_min_items() const;
  void _internal_set_min_items(int64_t value);
  public:

  // int64 max_properties = 21;
  void clear_max_properties();
  int64_t max_properties() const;
  void set_max_properties(int64_t value);
  private:
  int64_t _internal_max_properties() const;
  void _internal_set_max_properties(int64_t value);
  public:

  // int64 min_properties = 22;
  void clear_min_properties();
  int64_t min_properties() const;
  void set_min_properties(int64_t value);
  private:
  int64_t _internal_min_properties() const;
  void _internal_set_min_properties(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Schema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Any > enum__;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference > all_of_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference > one_of_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference > any_of_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::gnostic::openapi::v3::Discriminator* discriminator_;
    ::gnostic::openapi::v3::Xml* xml_;
    ::gnostic::openapi::v3::ExternalDocs* external_docs_;
    ::gnostic::openapi::v3::Any* example_;
    ::gnostic::openapi::v3::Schema* not__;
    ::gnostic::openapi::v3::ItemsItem* items_;
    ::gnostic::openapi::v3::Properties* properties_;
    ::gnostic::openapi::v3::AdditionalPropertiesItem* additional_properties_;
    ::gnostic::openapi::v3::DefaultType* default__;
    bool nullable_;
    bool read_only_;
    bool write_only_;
    bool deprecated_;
    bool exclusive_maximum_;
    bool exclusive_minimum_;
    bool unique_items_;
    double multiple_of_;
    double maximum_;
    double minimum_;
    int64_t max_length_;
    int64_t min_length_;
    int64_t max_items_;
    int64_t min_items_;
    int64_t max_properties_;
    int64_t min_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class SchemaOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.SchemaOrReference) */ {
 public:
  inline SchemaOrReference() : SchemaOrReference(nullptr) {}
  ~SchemaOrReference() override;
  explicit PROTOBUF_CONSTEXPR SchemaOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaOrReference(const SchemaOrReference& from);
  SchemaOrReference(SchemaOrReference&& from) noexcept
    : SchemaOrReference() {
    *this = ::std::move(from);
  }

  inline SchemaOrReference& operator=(const SchemaOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaOrReference& operator=(SchemaOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kSchema = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const SchemaOrReference* internal_default_instance() {
    return reinterpret_cast<const SchemaOrReference*>(
               &_SchemaOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(SchemaOrReference& a, SchemaOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemaOrReference& from) {
    SchemaOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.SchemaOrReference";
  }
  protected:
  explicit SchemaOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.Schema schema = 1;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::gnostic::openapi::v3::Schema& schema() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Schema* release_schema();
  ::gnostic::openapi::v3::Schema* mutable_schema();
  void set_allocated_schema(::gnostic::openapi::v3::Schema* schema);
  private:
  const ::gnostic::openapi::v3::Schema& _internal_schema() const;
  ::gnostic::openapi::v3::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::gnostic::openapi::v3::Schema* schema);
  ::gnostic::openapi::v3::Schema* unsafe_arena_release_schema();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.SchemaOrReference)
 private:
  class _Internal;
  void set_has_schema();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::Schema* schema_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class SchemasOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.SchemasOrReferences) */ {
 public:
  inline SchemasOrReferences() : SchemasOrReferences(nullptr) {}
  ~SchemasOrReferences() override;
  explicit PROTOBUF_CONSTEXPR SchemasOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemasOrReferences(const SchemasOrReferences& from);
  SchemasOrReferences(SchemasOrReferences&& from) noexcept
    : SchemasOrReferences() {
    *this = ::std::move(from);
  }

  inline SchemasOrReferences& operator=(const SchemasOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemasOrReferences& operator=(SchemasOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemasOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemasOrReferences* internal_default_instance() {
    return reinterpret_cast<const SchemasOrReferences*>(
               &_SchemasOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(SchemasOrReferences& a, SchemasOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemasOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemasOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemasOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemasOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemasOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemasOrReferences& from) {
    SchemasOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemasOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.SchemasOrReferences";
  }
  protected:
  explicit SchemasOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedSchemaOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedSchemaOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedSchemaOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedSchemaOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedSchemaOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.SchemasOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class SecurityRequirement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.SecurityRequirement) */ {
 public:
  inline SecurityRequirement() : SecurityRequirement(nullptr) {}
  ~SecurityRequirement() override;
  explicit PROTOBUF_CONSTEXPR SecurityRequirement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityRequirement(const SecurityRequirement& from);
  SecurityRequirement(SecurityRequirement&& from) noexcept
    : SecurityRequirement() {
    *this = ::std::move(from);
  }

  inline SecurityRequirement& operator=(const SecurityRequirement& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityRequirement& operator=(SecurityRequirement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityRequirement& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityRequirement* internal_default_instance() {
    return reinterpret_cast<const SecurityRequirement*>(
               &_SecurityRequirement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(SecurityRequirement& a, SecurityRequirement& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityRequirement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityRequirement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityRequirement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityRequirement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityRequirement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityRequirement& from) {
    SecurityRequirement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityRequirement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.SecurityRequirement";
  }
  protected:
  explicit SecurityRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedStringArray additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedStringArray* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedStringArray >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedStringArray& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedStringArray* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedStringArray& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedStringArray* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedStringArray >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.SecurityRequirement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedStringArray > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class SecurityScheme final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.SecurityScheme) */ {
 public:
  inline SecurityScheme() : SecurityScheme(nullptr) {}
  ~SecurityScheme() override;
  explicit PROTOBUF_CONSTEXPR SecurityScheme(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityScheme(const SecurityScheme& from);
  SecurityScheme(SecurityScheme&& from) noexcept
    : SecurityScheme() {
    *this = ::std::move(from);
  }

  inline SecurityScheme& operator=(const SecurityScheme& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityScheme& operator=(SecurityScheme&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityScheme& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityScheme* internal_default_instance() {
    return reinterpret_cast<const SecurityScheme*>(
               &_SecurityScheme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(SecurityScheme& a, SecurityScheme& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityScheme* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityScheme* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityScheme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityScheme>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityScheme& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityScheme& from) {
    SecurityScheme::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityScheme* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.SecurityScheme";
  }
  protected:
  explicit SecurityScheme(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 9,
    kTypeFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kNameFieldNumber = 3,
    kInFieldNumber = 4,
    kSchemeFieldNumber = 5,
    kBearerFormatFieldNumber = 6,
    kOpenIdConnectUrlFieldNumber = 8,
    kFlowsFieldNumber = 7,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string in = 4;
  void clear_in();
  const std::string& in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_in();
  PROTOBUF_NODISCARD std::string* release_in();
  void set_allocated_in(std::string* in);
  private:
  const std::string& _internal_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in(const std::string& value);
  std::string* _internal_mutable_in();
  public:

  // string scheme = 5;
  void clear_scheme();
  const std::string& scheme() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scheme(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scheme();
  PROTOBUF_NODISCARD std::string* release_scheme();
  void set_allocated_scheme(std::string* scheme);
  private:
  const std::string& _internal_scheme() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scheme(const std::string& value);
  std::string* _internal_mutable_scheme();
  public:

  // string bearer_format = 6;
  void clear_bearer_format();
  const std::string& bearer_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bearer_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bearer_format();
  PROTOBUF_NODISCARD std::string* release_bearer_format();
  void set_allocated_bearer_format(std::string* bearer_format);
  private:
  const std::string& _internal_bearer_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bearer_format(const std::string& value);
  std::string* _internal_mutable_bearer_format();
  public:

  // string open_id_connect_url = 8;
  void clear_open_id_connect_url();
  const std::string& open_id_connect_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_open_id_connect_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_open_id_connect_url();
  PROTOBUF_NODISCARD std::string* release_open_id_connect_url();
  void set_allocated_open_id_connect_url(std::string* open_id_connect_url);
  private:
  const std::string& _internal_open_id_connect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_open_id_connect_url(const std::string& value);
  std::string* _internal_mutable_open_id_connect_url();
  public:

  // .gnostic.openapi.v3.OauthFlows flows = 7;
  bool has_flows() const;
  private:
  bool _internal_has_flows() const;
  public:
  void clear_flows();
  const ::gnostic::openapi::v3::OauthFlows& flows() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::OauthFlows* release_flows();
  ::gnostic::openapi::v3::OauthFlows* mutable_flows();
  void set_allocated_flows(::gnostic::openapi::v3::OauthFlows* flows);
  private:
  const ::gnostic::openapi::v3::OauthFlows& _internal_flows() const;
  ::gnostic::openapi::v3::OauthFlows* _internal_mutable_flows();
  public:
  void unsafe_arena_set_allocated_flows(
      ::gnostic::openapi::v3::OauthFlows* flows);
  ::gnostic::openapi::v3::OauthFlows* unsafe_arena_release_flows();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.SecurityScheme)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scheme_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bearer_format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr open_id_connect_url_;
    ::gnostic::openapi::v3::OauthFlows* flows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class SecuritySchemeOrReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.SecuritySchemeOrReference) */ {
 public:
  inline SecuritySchemeOrReference() : SecuritySchemeOrReference(nullptr) {}
  ~SecuritySchemeOrReference() override;
  explicit PROTOBUF_CONSTEXPR SecuritySchemeOrReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecuritySchemeOrReference(const SecuritySchemeOrReference& from);
  SecuritySchemeOrReference(SecuritySchemeOrReference&& from) noexcept
    : SecuritySchemeOrReference() {
    *this = ::std::move(from);
  }

  inline SecuritySchemeOrReference& operator=(const SecuritySchemeOrReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecuritySchemeOrReference& operator=(SecuritySchemeOrReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecuritySchemeOrReference& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kSecurityScheme = 1,
    kReference = 2,
    ONEOF_NOT_SET = 0,
  };

  static inline const SecuritySchemeOrReference* internal_default_instance() {
    return reinterpret_cast<const SecuritySchemeOrReference*>(
               &_SecuritySchemeOrReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(SecuritySchemeOrReference& a, SecuritySchemeOrReference& b) {
    a.Swap(&b);
  }
  inline void Swap(SecuritySchemeOrReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecuritySchemeOrReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecuritySchemeOrReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecuritySchemeOrReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecuritySchemeOrReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecuritySchemeOrReference& from) {
    SecuritySchemeOrReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecuritySchemeOrReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.SecuritySchemeOrReference";
  }
  protected:
  explicit SecuritySchemeOrReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecuritySchemeFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // .gnostic.openapi.v3.SecurityScheme security_scheme = 1;
  bool has_security_scheme() const;
  private:
  bool _internal_has_security_scheme() const;
  public:
  void clear_security_scheme();
  const ::gnostic::openapi::v3::SecurityScheme& security_scheme() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::SecurityScheme* release_security_scheme();
  ::gnostic::openapi::v3::SecurityScheme* mutable_security_scheme();
  void set_allocated_security_scheme(::gnostic::openapi::v3::SecurityScheme* security_scheme);
  private:
  const ::gnostic::openapi::v3::SecurityScheme& _internal_security_scheme() const;
  ::gnostic::openapi::v3::SecurityScheme* _internal_mutable_security_scheme();
  public:
  void unsafe_arena_set_allocated_security_scheme(
      ::gnostic::openapi::v3::SecurityScheme* security_scheme);
  ::gnostic::openapi::v3::SecurityScheme* unsafe_arena_release_security_scheme();

  // .gnostic.openapi.v3.Reference reference = 2;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::gnostic::openapi::v3::Reference& reference() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::Reference* release_reference();
  ::gnostic::openapi::v3::Reference* mutable_reference();
  void set_allocated_reference(::gnostic::openapi::v3::Reference* reference);
  private:
  const ::gnostic::openapi::v3::Reference& _internal_reference() const;
  ::gnostic::openapi::v3::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::gnostic::openapi::v3::Reference* reference);
  ::gnostic::openapi::v3::Reference* unsafe_arena_release_reference();

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.SecuritySchemeOrReference)
 private:
  class _Internal;
  void set_has_security_scheme();
  void set_has_reference();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gnostic::openapi::v3::SecurityScheme* security_scheme_;
      ::gnostic::openapi::v3::Reference* reference_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class SecuritySchemesOrReferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.SecuritySchemesOrReferences) */ {
 public:
  inline SecuritySchemesOrReferences() : SecuritySchemesOrReferences(nullptr) {}
  ~SecuritySchemesOrReferences() override;
  explicit PROTOBUF_CONSTEXPR SecuritySchemesOrReferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecuritySchemesOrReferences(const SecuritySchemesOrReferences& from);
  SecuritySchemesOrReferences(SecuritySchemesOrReferences&& from) noexcept
    : SecuritySchemesOrReferences() {
    *this = ::std::move(from);
  }

  inline SecuritySchemesOrReferences& operator=(const SecuritySchemesOrReferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecuritySchemesOrReferences& operator=(SecuritySchemesOrReferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecuritySchemesOrReferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecuritySchemesOrReferences* internal_default_instance() {
    return reinterpret_cast<const SecuritySchemesOrReferences*>(
               &_SecuritySchemesOrReferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(SecuritySchemesOrReferences& a, SecuritySchemesOrReferences& b) {
    a.Swap(&b);
  }
  inline void Swap(SecuritySchemesOrReferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecuritySchemesOrReferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecuritySchemesOrReferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecuritySchemesOrReferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecuritySchemesOrReferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecuritySchemesOrReferences& from) {
    SecuritySchemesOrReferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecuritySchemesOrReferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.SecuritySchemesOrReferences";
  }
  protected:
  explicit SecuritySchemesOrReferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSecuritySchemeOrReference >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedSecuritySchemeOrReference& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedSecuritySchemeOrReference& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSecuritySchemeOrReference >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.SecuritySchemesOrReferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSecuritySchemeOrReference > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Server final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Server) */ {
 public:
  inline Server() : Server(nullptr) {}
  ~Server() override;
  explicit PROTOBUF_CONSTEXPR Server(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server(const Server& from);
  Server(Server&& from) noexcept
    : Server() {
    *this = ::std::move(from);
  }

  inline Server& operator=(const Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server& operator=(Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server* internal_default_instance() {
    return reinterpret_cast<const Server*>(
               &_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(Server& a, Server& b) {
    a.Swap(&b);
  }
  inline void Swap(Server* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Server& from) {
    Server::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Server";
  }
  protected:
  explicit Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 4,
    kUrlFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kVariablesFieldNumber = 3,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .gnostic.openapi.v3.ServerVariables variables = 3;
  bool has_variables() const;
  private:
  bool _internal_has_variables() const;
  public:
  void clear_variables();
  const ::gnostic::openapi::v3::ServerVariables& variables() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ServerVariables* release_variables();
  ::gnostic::openapi::v3::ServerVariables* mutable_variables();
  void set_allocated_variables(::gnostic::openapi::v3::ServerVariables* variables);
  private:
  const ::gnostic::openapi::v3::ServerVariables& _internal_variables() const;
  ::gnostic::openapi::v3::ServerVariables* _internal_mutable_variables();
  public:
  void unsafe_arena_set_allocated_variables(
      ::gnostic::openapi::v3::ServerVariables* variables);
  ::gnostic::openapi::v3::ServerVariables* unsafe_arena_release_variables();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Server)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::gnostic::openapi::v3::ServerVariables* variables_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ServerVariable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ServerVariable) */ {
 public:
  inline ServerVariable() : ServerVariable(nullptr) {}
  ~ServerVariable() override;
  explicit PROTOBUF_CONSTEXPR ServerVariable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerVariable(const ServerVariable& from);
  ServerVariable(ServerVariable&& from) noexcept
    : ServerVariable() {
    *this = ::std::move(from);
  }

  inline ServerVariable& operator=(const ServerVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerVariable& operator=(ServerVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerVariable* internal_default_instance() {
    return reinterpret_cast<const ServerVariable*>(
               &_ServerVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ServerVariable& a, ServerVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerVariable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerVariable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerVariable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerVariable& from) {
    ServerVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerVariable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ServerVariable";
  }
  protected:
  explicit ServerVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumFieldNumber = 1,
    kSpecificationExtensionFieldNumber = 4,
    kDefaultFieldNumber = 2,
    kDescriptionFieldNumber = 3,
  };
  // repeated string enum = 1;
  int enum__size() const;
  private:
  int _internal_enum__size() const;
  public:
  void clear_enum_();
  const std::string& enum_(int index) const;
  std::string* mutable_enum_(int index);
  void set_enum_(int index, const std::string& value);
  void set_enum_(int index, std::string&& value);
  void set_enum_(int index, const char* value);
  void set_enum_(int index, const char* value, size_t size);
  std::string* add_enum_();
  void add_enum_(const std::string& value);
  void add_enum_(std::string&& value);
  void add_enum_(const char* value);
  void add_enum_(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enum_() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enum_();
  private:
  const std::string& _internal_enum_(int index) const;
  std::string* _internal_add_enum_();
  public:

  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string default = 2;
  void clear_default_();
  const std::string& default_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_();
  PROTOBUF_NODISCARD std::string* release_default_();
  void set_allocated_default_(std::string* default_);
  private:
  const std::string& _internal_default_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_(const std::string& value);
  std::string* _internal_mutable_default_();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ServerVariable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enum__;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class ServerVariables final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.ServerVariables) */ {
 public:
  inline ServerVariables() : ServerVariables(nullptr) {}
  ~ServerVariables() override;
  explicit PROTOBUF_CONSTEXPR ServerVariables(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerVariables(const ServerVariables& from);
  ServerVariables(ServerVariables&& from) noexcept
    : ServerVariables() {
    *this = ::std::move(from);
  }

  inline ServerVariables& operator=(const ServerVariables& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerVariables& operator=(ServerVariables&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerVariables& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerVariables* internal_default_instance() {
    return reinterpret_cast<const ServerVariables*>(
               &_ServerVariables_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ServerVariables& a, ServerVariables& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerVariables* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerVariables* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerVariables* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerVariables>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerVariables& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerVariables& from) {
    ServerVariables::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerVariables* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.ServerVariables";
  }
  protected:
  explicit ServerVariables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedServerVariable additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedServerVariable* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedServerVariable >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedServerVariable& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedServerVariable* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedServerVariable& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedServerVariable* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedServerVariable >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.ServerVariables)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedServerVariable > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class SpecificationExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.SpecificationExtension) */ {
 public:
  inline SpecificationExtension() : SpecificationExtension(nullptr) {}
  ~SpecificationExtension() override;
  explicit PROTOBUF_CONSTEXPR SpecificationExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecificationExtension(const SpecificationExtension& from);
  SpecificationExtension(SpecificationExtension&& from) noexcept
    : SpecificationExtension() {
    *this = ::std::move(from);
  }

  inline SpecificationExtension& operator=(const SpecificationExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecificationExtension& operator=(SpecificationExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecificationExtension& default_instance() {
    return *internal_default_instance();
  }
  enum OneofCase {
    kNumber = 1,
    kBoolean = 2,
    kString = 3,
    ONEOF_NOT_SET = 0,
  };

  static inline const SpecificationExtension* internal_default_instance() {
    return reinterpret_cast<const SpecificationExtension*>(
               &_SpecificationExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(SpecificationExtension& a, SpecificationExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecificationExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecificationExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpecificationExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpecificationExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpecificationExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpecificationExtension& from) {
    SpecificationExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecificationExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.SpecificationExtension";
  }
  protected:
  explicit SpecificationExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kBooleanFieldNumber = 2,
    kStringFieldNumber = 3,
  };
  // double number = 1;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  double number() const;
  void set_number(double value);
  private:
  double _internal_number() const;
  void _internal_set_number(double value);
  public:

  // bool boolean = 2;
  bool has_boolean() const;
  private:
  bool _internal_has_boolean() const;
  public:
  void clear_boolean();
  bool boolean() const;
  void set_boolean(bool value);
  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);
  public:

  // string string = 3;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const std::string& string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* string);
  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  void clear_oneof();
  OneofCase oneof_case() const;
  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.SpecificationExtension)
 private:
  class _Internal;
  void set_has_number();
  void set_has_boolean();
  void set_has_string();

  inline bool has_oneof() const;
  inline void clear_has_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OneofUnion {
      constexpr OneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double number_;
      bool boolean_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
    } oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class StringArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.StringArray) */ {
 public:
  inline StringArray() : StringArray(nullptr) {}
  ~StringArray() override;
  explicit PROTOBUF_CONSTEXPR StringArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringArray(const StringArray& from);
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringArray& operator=(StringArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }
  inline void Swap(StringArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringArray& from) {
    StringArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.StringArray";
  }
  protected:
  explicit StringArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.StringArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Strings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Strings) */ {
 public:
  inline Strings() : Strings(nullptr) {}
  ~Strings() override;
  explicit PROTOBUF_CONSTEXPR Strings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Strings(const Strings& from);
  Strings(Strings&& from) noexcept
    : Strings() {
    *this = ::std::move(from);
  }

  inline Strings& operator=(const Strings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Strings& operator=(Strings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Strings& default_instance() {
    return *internal_default_instance();
  }
  static inline const Strings* internal_default_instance() {
    return reinterpret_cast<const Strings*>(
               &_Strings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(Strings& a, Strings& b) {
    a.Swap(&b);
  }
  inline void Swap(Strings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Strings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Strings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Strings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Strings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Strings& from) {
    Strings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Strings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Strings";
  }
  protected:
  explicit Strings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPropertiesFieldNumber = 1,
  };
  // repeated .gnostic.openapi.v3.NamedString additional_properties = 1;
  int additional_properties_size() const;
  private:
  int _internal_additional_properties_size() const;
  public:
  void clear_additional_properties();
  ::gnostic::openapi::v3::NamedString* mutable_additional_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedString >*
      mutable_additional_properties();
  private:
  const ::gnostic::openapi::v3::NamedString& _internal_additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedString* _internal_add_additional_properties();
  public:
  const ::gnostic::openapi::v3::NamedString& additional_properties(int index) const;
  ::gnostic::openapi::v3::NamedString* add_additional_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedString >&
      additional_properties() const;

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Strings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedString > additional_properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Tag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Tag) */ {
 public:
  inline Tag() : Tag(nullptr) {}
  ~Tag() override;
  explicit PROTOBUF_CONSTEXPR Tag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tag(const Tag& from);
  Tag(Tag&& from) noexcept
    : Tag() {
    *this = ::std::move(from);
  }

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tag& operator=(Tag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tag* internal_default_instance() {
    return reinterpret_cast<const Tag*>(
               &_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(Tag& a, Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(Tag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tag& from) {
    Tag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Tag";
  }
  protected:
  explicit Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 4,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kExternalDocsFieldNumber = 3,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .gnostic.openapi.v3.ExternalDocs external_docs = 3;
  bool has_external_docs() const;
  private:
  bool _internal_has_external_docs() const;
  public:
  void clear_external_docs();
  const ::gnostic::openapi::v3::ExternalDocs& external_docs() const;
  PROTOBUF_NODISCARD ::gnostic::openapi::v3::ExternalDocs* release_external_docs();
  ::gnostic::openapi::v3::ExternalDocs* mutable_external_docs();
  void set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs);
  private:
  const ::gnostic::openapi::v3::ExternalDocs& _internal_external_docs() const;
  ::gnostic::openapi::v3::ExternalDocs* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::gnostic::openapi::v3::ExternalDocs* external_docs);
  ::gnostic::openapi::v3::ExternalDocs* unsafe_arena_release_external_docs();

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Tag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::gnostic::openapi::v3::ExternalDocs* external_docs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// -------------------------------------------------------------------

class Xml final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnostic.openapi.v3.Xml) */ {
 public:
  inline Xml() : Xml(nullptr) {}
  ~Xml() override;
  explicit PROTOBUF_CONSTEXPR Xml(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Xml(const Xml& from);
  Xml(Xml&& from) noexcept
    : Xml() {
    *this = ::std::move(from);
  }

  inline Xml& operator=(const Xml& from) {
    CopyFrom(from);
    return *this;
  }
  inline Xml& operator=(Xml&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Xml& default_instance() {
    return *internal_default_instance();
  }
  static inline const Xml* internal_default_instance() {
    return reinterpret_cast<const Xml*>(
               &_Xml_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(Xml& a, Xml& b) {
    a.Swap(&b);
  }
  inline void Swap(Xml* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Xml* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Xml* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Xml>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Xml& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Xml& from) {
    Xml::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Xml* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnostic.openapi.v3.Xml";
  }
  protected:
  explicit Xml(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecificationExtensionFieldNumber = 6,
    kNameFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kPrefixFieldNumber = 3,
    kAttributeFieldNumber = 4,
    kWrappedFieldNumber = 5,
  };
  // repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
  int specification_extension_size() const;
  private:
  int _internal_specification_extension_size() const;
  public:
  void clear_specification_extension();
  ::gnostic::openapi::v3::NamedAny* mutable_specification_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
      mutable_specification_extension();
  private:
  const ::gnostic::openapi::v3::NamedAny& _internal_specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* _internal_add_specification_extension();
  public:
  const ::gnostic::openapi::v3::NamedAny& specification_extension(int index) const;
  ::gnostic::openapi::v3::NamedAny* add_specification_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
      specification_extension() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string namespace = 2;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string prefix = 3;
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // bool attribute = 4;
  void clear_attribute();
  bool attribute() const;
  void set_attribute(bool value);
  private:
  bool _internal_attribute() const;
  void _internal_set_attribute(bool value);
  public:

  // bool wrapped = 5;
  void clear_wrapped();
  bool wrapped() const;
  void set_wrapped(bool value);
  private:
  bool _internal_wrapped() const;
  void _internal_set_wrapped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gnostic.openapi.v3.Xml)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny > specification_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
    bool attribute_;
    bool wrapped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AdditionalPropertiesItem

// .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
inline bool AdditionalPropertiesItem::_internal_has_schema_or_reference() const {
  return oneof_case() == kSchemaOrReference;
}
inline bool AdditionalPropertiesItem::has_schema_or_reference() const {
  return _internal_has_schema_or_reference();
}
inline void AdditionalPropertiesItem::set_has_schema_or_reference() {
  _impl_._oneof_case_[0] = kSchemaOrReference;
}
inline void AdditionalPropertiesItem::clear_schema_or_reference() {
  if (_internal_has_schema_or_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.schema_or_reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::SchemaOrReference* AdditionalPropertiesItem::release_schema_or_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.AdditionalPropertiesItem.schema_or_reference)
  if (_internal_has_schema_or_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.oneof_.schema_or_reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.schema_or_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::SchemaOrReference& AdditionalPropertiesItem::_internal_schema_or_reference() const {
  return _internal_has_schema_or_reference()
      ? *_impl_.oneof_.schema_or_reference_
      : reinterpret_cast< ::gnostic::openapi::v3::SchemaOrReference&>(::gnostic::openapi::v3::_SchemaOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& AdditionalPropertiesItem::schema_or_reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.AdditionalPropertiesItem.schema_or_reference)
  return _internal_schema_or_reference();
}
inline ::gnostic::openapi::v3::SchemaOrReference* AdditionalPropertiesItem::unsafe_arena_release_schema_or_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.AdditionalPropertiesItem.schema_or_reference)
  if (_internal_has_schema_or_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.oneof_.schema_or_reference_;
    _impl_.oneof_.schema_or_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdditionalPropertiesItem::unsafe_arena_set_allocated_schema_or_reference(::gnostic::openapi::v3::SchemaOrReference* schema_or_reference) {
  clear_oneof();
  if (schema_or_reference) {
    set_has_schema_or_reference();
    _impl_.oneof_.schema_or_reference_ = schema_or_reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.AdditionalPropertiesItem.schema_or_reference)
}
inline ::gnostic::openapi::v3::SchemaOrReference* AdditionalPropertiesItem::_internal_mutable_schema_or_reference() {
  if (!_internal_has_schema_or_reference()) {
    clear_oneof();
    set_has_schema_or_reference();
    _impl_.oneof_.schema_or_reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::SchemaOrReference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.schema_or_reference_;
}
inline ::gnostic::openapi::v3::SchemaOrReference* AdditionalPropertiesItem::mutable_schema_or_reference() {
  ::gnostic::openapi::v3::SchemaOrReference* _msg = _internal_mutable_schema_or_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.AdditionalPropertiesItem.schema_or_reference)
  return _msg;
}

// bool boolean = 2;
inline bool AdditionalPropertiesItem::_internal_has_boolean() const {
  return oneof_case() == kBoolean;
}
inline bool AdditionalPropertiesItem::has_boolean() const {
  return _internal_has_boolean();
}
inline void AdditionalPropertiesItem::set_has_boolean() {
  _impl_._oneof_case_[0] = kBoolean;
}
inline void AdditionalPropertiesItem::clear_boolean() {
  if (_internal_has_boolean()) {
    _impl_.oneof_.boolean_ = false;
    clear_has_oneof();
  }
}
inline bool AdditionalPropertiesItem::_internal_boolean() const {
  if (_internal_has_boolean()) {
    return _impl_.oneof_.boolean_;
  }
  return false;
}
inline void AdditionalPropertiesItem::_internal_set_boolean(bool value) {
  if (!_internal_has_boolean()) {
    clear_oneof();
    set_has_boolean();
  }
  _impl_.oneof_.boolean_ = value;
}
inline bool AdditionalPropertiesItem::boolean() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.AdditionalPropertiesItem.boolean)
  return _internal_boolean();
}
inline void AdditionalPropertiesItem::set_boolean(bool value) {
  _internal_set_boolean(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.AdditionalPropertiesItem.boolean)
}

inline bool AdditionalPropertiesItem::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void AdditionalPropertiesItem::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline AdditionalPropertiesItem::OneofCase AdditionalPropertiesItem::oneof_case() const {
  return AdditionalPropertiesItem::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Any

// .google.protobuf.Any value = 1;
inline bool Any::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool Any::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Any::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Any::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Any.value)
  return _internal_value();
}
inline void Any::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::Any* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Any.value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Any::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Any::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Any.value)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Any::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Any::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Any.value)
  return _msg;
}
inline void Any::set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Any.value)
}

// string yaml = 2;
inline void Any::clear_yaml() {
  _impl_.yaml_.ClearToEmpty();
}
inline const std::string& Any::yaml() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Any.yaml)
  return _internal_yaml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Any::set_yaml(ArgT0&& arg0, ArgT... args) {
 
 _impl_.yaml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Any.yaml)
}
inline std::string* Any::mutable_yaml() {
  std::string* _s = _internal_mutable_yaml();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Any.yaml)
  return _s;
}
inline const std::string& Any::_internal_yaml() const {
  return _impl_.yaml_.Get();
}
inline void Any::_internal_set_yaml(const std::string& value) {
  
  _impl_.yaml_.Set(value, GetArenaForAllocation());
}
inline std::string* Any::_internal_mutable_yaml() {
  
  return _impl_.yaml_.Mutable(GetArenaForAllocation());
}
inline std::string* Any::release_yaml() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Any.yaml)
  return _impl_.yaml_.Release();
}
inline void Any::set_allocated_yaml(std::string* yaml) {
  if (yaml != nullptr) {
    
  } else {
    
  }
  _impl_.yaml_.SetAllocated(yaml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.yaml_.IsDefault()) {
    _impl_.yaml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Any.yaml)
}

// -------------------------------------------------------------------

// AnyOrExpression

// .gnostic.openapi.v3.Any any = 1;
inline bool AnyOrExpression::_internal_has_any() const {
  return oneof_case() == kAny;
}
inline bool AnyOrExpression::has_any() const {
  return _internal_has_any();
}
inline void AnyOrExpression::set_has_any() {
  _impl_._oneof_case_[0] = kAny;
}
inline void AnyOrExpression::clear_any() {
  if (_internal_has_any()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.any_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Any* AnyOrExpression::release_any() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.AnyOrExpression.any)
  if (_internal_has_any()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Any* temp = _impl_.oneof_.any_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Any& AnyOrExpression::_internal_any() const {
  return _internal_has_any()
      ? *_impl_.oneof_.any_
      : reinterpret_cast< ::gnostic::openapi::v3::Any&>(::gnostic::openapi::v3::_Any_default_instance_);
}
inline const ::gnostic::openapi::v3::Any& AnyOrExpression::any() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.AnyOrExpression.any)
  return _internal_any();
}
inline ::gnostic::openapi::v3::Any* AnyOrExpression::unsafe_arena_release_any() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.AnyOrExpression.any)
  if (_internal_has_any()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Any* temp = _impl_.oneof_.any_;
    _impl_.oneof_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyOrExpression::unsafe_arena_set_allocated_any(::gnostic::openapi::v3::Any* any) {
  clear_oneof();
  if (any) {
    set_has_any();
    _impl_.oneof_.any_ = any;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.AnyOrExpression.any)
}
inline ::gnostic::openapi::v3::Any* AnyOrExpression::_internal_mutable_any() {
  if (!_internal_has_any()) {
    clear_oneof();
    set_has_any();
    _impl_.oneof_.any_ = CreateMaybeMessage< ::gnostic::openapi::v3::Any >(GetArenaForAllocation());
  }
  return _impl_.oneof_.any_;
}
inline ::gnostic::openapi::v3::Any* AnyOrExpression::mutable_any() {
  ::gnostic::openapi::v3::Any* _msg = _internal_mutable_any();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.AnyOrExpression.any)
  return _msg;
}

// .gnostic.openapi.v3.Expression expression = 2;
inline bool AnyOrExpression::_internal_has_expression() const {
  return oneof_case() == kExpression;
}
inline bool AnyOrExpression::has_expression() const {
  return _internal_has_expression();
}
inline void AnyOrExpression::set_has_expression() {
  _impl_._oneof_case_[0] = kExpression;
}
inline void AnyOrExpression::clear_expression() {
  if (_internal_has_expression()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.expression_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Expression* AnyOrExpression::release_expression() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.AnyOrExpression.expression)
  if (_internal_has_expression()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Expression* temp = _impl_.oneof_.expression_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Expression& AnyOrExpression::_internal_expression() const {
  return _internal_has_expression()
      ? *_impl_.oneof_.expression_
      : reinterpret_cast< ::gnostic::openapi::v3::Expression&>(::gnostic::openapi::v3::_Expression_default_instance_);
}
inline const ::gnostic::openapi::v3::Expression& AnyOrExpression::expression() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.AnyOrExpression.expression)
  return _internal_expression();
}
inline ::gnostic::openapi::v3::Expression* AnyOrExpression::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.AnyOrExpression.expression)
  if (_internal_has_expression()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Expression* temp = _impl_.oneof_.expression_;
    _impl_.oneof_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnyOrExpression::unsafe_arena_set_allocated_expression(::gnostic::openapi::v3::Expression* expression) {
  clear_oneof();
  if (expression) {
    set_has_expression();
    _impl_.oneof_.expression_ = expression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.AnyOrExpression.expression)
}
inline ::gnostic::openapi::v3::Expression* AnyOrExpression::_internal_mutable_expression() {
  if (!_internal_has_expression()) {
    clear_oneof();
    set_has_expression();
    _impl_.oneof_.expression_ = CreateMaybeMessage< ::gnostic::openapi::v3::Expression >(GetArenaForAllocation());
  }
  return _impl_.oneof_.expression_;
}
inline ::gnostic::openapi::v3::Expression* AnyOrExpression::mutable_expression() {
  ::gnostic::openapi::v3::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.AnyOrExpression.expression)
  return _msg;
}

inline bool AnyOrExpression::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void AnyOrExpression::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline AnyOrExpression::OneofCase AnyOrExpression::oneof_case() const {
  return AnyOrExpression::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Callback

// repeated .gnostic.openapi.v3.NamedPathItem path = 1;
inline int Callback::_internal_path_size() const {
  return _impl_.path_.size();
}
inline int Callback::path_size() const {
  return _internal_path_size();
}
inline void Callback::clear_path() {
  _impl_.path_.Clear();
}
inline ::gnostic::openapi::v3::NamedPathItem* Callback::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Callback.path)
  return _impl_.path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >*
Callback::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Callback.path)
  return &_impl_.path_;
}
inline const ::gnostic::openapi::v3::NamedPathItem& Callback::_internal_path(int index) const {
  return _impl_.path_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedPathItem& Callback::path(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Callback.path)
  return _internal_path(index);
}
inline ::gnostic::openapi::v3::NamedPathItem* Callback::_internal_add_path() {
  return _impl_.path_.Add();
}
inline ::gnostic::openapi::v3::NamedPathItem* Callback::add_path() {
  ::gnostic::openapi::v3::NamedPathItem* _add = _internal_add_path();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Callback.path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >&
Callback::path() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Callback.path)
  return _impl_.path_;
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
inline int Callback::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Callback::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Callback::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Callback::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Callback.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Callback::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Callback.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Callback::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Callback::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Callback.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Callback::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Callback::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Callback.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Callback::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Callback.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// CallbackOrReference

// .gnostic.openapi.v3.Callback callback = 1;
inline bool CallbackOrReference::_internal_has_callback() const {
  return oneof_case() == kCallback;
}
inline bool CallbackOrReference::has_callback() const {
  return _internal_has_callback();
}
inline void CallbackOrReference::set_has_callback() {
  _impl_._oneof_case_[0] = kCallback;
}
inline void CallbackOrReference::clear_callback() {
  if (_internal_has_callback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.callback_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Callback* CallbackOrReference::release_callback() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.CallbackOrReference.callback)
  if (_internal_has_callback()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Callback* temp = _impl_.oneof_.callback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Callback& CallbackOrReference::_internal_callback() const {
  return _internal_has_callback()
      ? *_impl_.oneof_.callback_
      : reinterpret_cast< ::gnostic::openapi::v3::Callback&>(::gnostic::openapi::v3::_Callback_default_instance_);
}
inline const ::gnostic::openapi::v3::Callback& CallbackOrReference::callback() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.CallbackOrReference.callback)
  return _internal_callback();
}
inline ::gnostic::openapi::v3::Callback* CallbackOrReference::unsafe_arena_release_callback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.CallbackOrReference.callback)
  if (_internal_has_callback()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Callback* temp = _impl_.oneof_.callback_;
    _impl_.oneof_.callback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackOrReference::unsafe_arena_set_allocated_callback(::gnostic::openapi::v3::Callback* callback) {
  clear_oneof();
  if (callback) {
    set_has_callback();
    _impl_.oneof_.callback_ = callback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.CallbackOrReference.callback)
}
inline ::gnostic::openapi::v3::Callback* CallbackOrReference::_internal_mutable_callback() {
  if (!_internal_has_callback()) {
    clear_oneof();
    set_has_callback();
    _impl_.oneof_.callback_ = CreateMaybeMessage< ::gnostic::openapi::v3::Callback >(GetArenaForAllocation());
  }
  return _impl_.oneof_.callback_;
}
inline ::gnostic::openapi::v3::Callback* CallbackOrReference::mutable_callback() {
  ::gnostic::openapi::v3::Callback* _msg = _internal_mutable_callback();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.CallbackOrReference.callback)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool CallbackOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool CallbackOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void CallbackOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void CallbackOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* CallbackOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.CallbackOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& CallbackOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& CallbackOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.CallbackOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* CallbackOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.CallbackOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.CallbackOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* CallbackOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* CallbackOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.CallbackOrReference.reference)
  return _msg;
}

inline bool CallbackOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void CallbackOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline CallbackOrReference::OneofCase CallbackOrReference::oneof_case() const {
  return CallbackOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallbacksOrReferences

// repeated .gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1;
inline int CallbacksOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int CallbacksOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void CallbacksOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedCallbackOrReference* CallbacksOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.CallbacksOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedCallbackOrReference >*
CallbacksOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.CallbacksOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedCallbackOrReference& CallbacksOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedCallbackOrReference& CallbacksOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.CallbacksOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedCallbackOrReference* CallbacksOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedCallbackOrReference* CallbacksOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedCallbackOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.CallbacksOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedCallbackOrReference >&
CallbacksOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.CallbacksOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Components

// .gnostic.openapi.v3.SchemasOrReferences schemas = 1;
inline bool Components::_internal_has_schemas() const {
  return this != internal_default_instance() && _impl_.schemas_ != nullptr;
}
inline bool Components::has_schemas() const {
  return _internal_has_schemas();
}
inline void Components::clear_schemas() {
  if (GetArenaForAllocation() == nullptr && _impl_.schemas_ != nullptr) {
    delete _impl_.schemas_;
  }
  _impl_.schemas_ = nullptr;
}
inline const ::gnostic::openapi::v3::SchemasOrReferences& Components::_internal_schemas() const {
  const ::gnostic::openapi::v3::SchemasOrReferences* p = _impl_.schemas_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::SchemasOrReferences&>(
      ::gnostic::openapi::v3::_SchemasOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::SchemasOrReferences& Components::schemas() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.schemas)
  return _internal_schemas();
}
inline void Components::unsafe_arena_set_allocated_schemas(
    ::gnostic::openapi::v3::SchemasOrReferences* schemas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schemas_);
  }
  _impl_.schemas_ = schemas;
  if (schemas) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.schemas)
}
inline ::gnostic::openapi::v3::SchemasOrReferences* Components::release_schemas() {
  
  ::gnostic::openapi::v3::SchemasOrReferences* temp = _impl_.schemas_;
  _impl_.schemas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::SchemasOrReferences* Components::unsafe_arena_release_schemas() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.schemas)
  
  ::gnostic::openapi::v3::SchemasOrReferences* temp = _impl_.schemas_;
  _impl_.schemas_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::SchemasOrReferences* Components::_internal_mutable_schemas() {
  
  if (_impl_.schemas_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::SchemasOrReferences>(GetArenaForAllocation());
    _impl_.schemas_ = p;
  }
  return _impl_.schemas_;
}
inline ::gnostic::openapi::v3::SchemasOrReferences* Components::mutable_schemas() {
  ::gnostic::openapi::v3::SchemasOrReferences* _msg = _internal_mutable_schemas();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.schemas)
  return _msg;
}
inline void Components::set_allocated_schemas(::gnostic::openapi::v3::SchemasOrReferences* schemas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schemas_;
  }
  if (schemas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schemas);
    if (message_arena != submessage_arena) {
      schemas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schemas, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schemas_ = schemas;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.schemas)
}

// .gnostic.openapi.v3.ResponsesOrReferences responses = 2;
inline bool Components::_internal_has_responses() const {
  return this != internal_default_instance() && _impl_.responses_ != nullptr;
}
inline bool Components::has_responses() const {
  return _internal_has_responses();
}
inline void Components::clear_responses() {
  if (GetArenaForAllocation() == nullptr && _impl_.responses_ != nullptr) {
    delete _impl_.responses_;
  }
  _impl_.responses_ = nullptr;
}
inline const ::gnostic::openapi::v3::ResponsesOrReferences& Components::_internal_responses() const {
  const ::gnostic::openapi::v3::ResponsesOrReferences* p = _impl_.responses_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ResponsesOrReferences&>(
      ::gnostic::openapi::v3::_ResponsesOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::ResponsesOrReferences& Components::responses() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.responses)
  return _internal_responses();
}
inline void Components::unsafe_arena_set_allocated_responses(
    ::gnostic::openapi::v3::ResponsesOrReferences* responses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.responses_);
  }
  _impl_.responses_ = responses;
  if (responses) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.responses)
}
inline ::gnostic::openapi::v3::ResponsesOrReferences* Components::release_responses() {
  
  ::gnostic::openapi::v3::ResponsesOrReferences* temp = _impl_.responses_;
  _impl_.responses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ResponsesOrReferences* Components::unsafe_arena_release_responses() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.responses)
  
  ::gnostic::openapi::v3::ResponsesOrReferences* temp = _impl_.responses_;
  _impl_.responses_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ResponsesOrReferences* Components::_internal_mutable_responses() {
  
  if (_impl_.responses_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ResponsesOrReferences>(GetArenaForAllocation());
    _impl_.responses_ = p;
  }
  return _impl_.responses_;
}
inline ::gnostic::openapi::v3::ResponsesOrReferences* Components::mutable_responses() {
  ::gnostic::openapi::v3::ResponsesOrReferences* _msg = _internal_mutable_responses();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.responses)
  return _msg;
}
inline void Components::set_allocated_responses(::gnostic::openapi::v3::ResponsesOrReferences* responses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.responses_;
  }
  if (responses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(responses);
    if (message_arena != submessage_arena) {
      responses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responses, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.responses_ = responses;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.responses)
}

// .gnostic.openapi.v3.ParametersOrReferences parameters = 3;
inline bool Components::_internal_has_parameters() const {
  return this != internal_default_instance() && _impl_.parameters_ != nullptr;
}
inline bool Components::has_parameters() const {
  return _internal_has_parameters();
}
inline void Components::clear_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.parameters_ != nullptr) {
    delete _impl_.parameters_;
  }
  _impl_.parameters_ = nullptr;
}
inline const ::gnostic::openapi::v3::ParametersOrReferences& Components::_internal_parameters() const {
  const ::gnostic::openapi::v3::ParametersOrReferences* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ParametersOrReferences&>(
      ::gnostic::openapi::v3::_ParametersOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::ParametersOrReferences& Components::parameters() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.parameters)
  return _internal_parameters();
}
inline void Components::unsafe_arena_set_allocated_parameters(
    ::gnostic::openapi::v3::ParametersOrReferences* parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = parameters;
  if (parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.parameters)
}
inline ::gnostic::openapi::v3::ParametersOrReferences* Components::release_parameters() {
  
  ::gnostic::openapi::v3::ParametersOrReferences* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ParametersOrReferences* Components::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.parameters)
  
  ::gnostic::openapi::v3::ParametersOrReferences* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ParametersOrReferences* Components::_internal_mutable_parameters() {
  
  if (_impl_.parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ParametersOrReferences>(GetArenaForAllocation());
    _impl_.parameters_ = p;
  }
  return _impl_.parameters_;
}
inline ::gnostic::openapi::v3::ParametersOrReferences* Components::mutable_parameters() {
  ::gnostic::openapi::v3::ParametersOrReferences* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.parameters)
  return _msg;
}
inline void Components::set_allocated_parameters(::gnostic::openapi::v3::ParametersOrReferences* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parameters_;
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parameters);
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.parameters)
}

// .gnostic.openapi.v3.ExamplesOrReferences examples = 4;
inline bool Components::_internal_has_examples() const {
  return this != internal_default_instance() && _impl_.examples_ != nullptr;
}
inline bool Components::has_examples() const {
  return _internal_has_examples();
}
inline void Components::clear_examples() {
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& Components::_internal_examples() const {
  const ::gnostic::openapi::v3::ExamplesOrReferences* p = _impl_.examples_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExamplesOrReferences&>(
      ::gnostic::openapi::v3::_ExamplesOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& Components::examples() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.examples)
  return _internal_examples();
}
inline void Components::unsafe_arena_set_allocated_examples(
    ::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.examples_);
  }
  _impl_.examples_ = examples;
  if (examples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.examples)
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Components::release_examples() {
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Components::unsafe_arena_release_examples() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.examples)
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Components::_internal_mutable_examples() {
  
  if (_impl_.examples_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExamplesOrReferences>(GetArenaForAllocation());
    _impl_.examples_ = p;
  }
  return _impl_.examples_;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Components::mutable_examples() {
  ::gnostic::openapi::v3::ExamplesOrReferences* _msg = _internal_mutable_examples();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.examples)
  return _msg;
}
inline void Components::set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.examples_;
  }
  if (examples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(examples);
    if (message_arena != submessage_arena) {
      examples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, examples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.examples_ = examples;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.examples)
}

// .gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5;
inline bool Components::_internal_has_request_bodies() const {
  return this != internal_default_instance() && _impl_.request_bodies_ != nullptr;
}
inline bool Components::has_request_bodies() const {
  return _internal_has_request_bodies();
}
inline void Components::clear_request_bodies() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_bodies_ != nullptr) {
    delete _impl_.request_bodies_;
  }
  _impl_.request_bodies_ = nullptr;
}
inline const ::gnostic::openapi::v3::RequestBodiesOrReferences& Components::_internal_request_bodies() const {
  const ::gnostic::openapi::v3::RequestBodiesOrReferences* p = _impl_.request_bodies_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::RequestBodiesOrReferences&>(
      ::gnostic::openapi::v3::_RequestBodiesOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::RequestBodiesOrReferences& Components::request_bodies() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.request_bodies)
  return _internal_request_bodies();
}
inline void Components::unsafe_arena_set_allocated_request_bodies(
    ::gnostic::openapi::v3::RequestBodiesOrReferences* request_bodies) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_bodies_);
  }
  _impl_.request_bodies_ = request_bodies;
  if (request_bodies) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.request_bodies)
}
inline ::gnostic::openapi::v3::RequestBodiesOrReferences* Components::release_request_bodies() {
  
  ::gnostic::openapi::v3::RequestBodiesOrReferences* temp = _impl_.request_bodies_;
  _impl_.request_bodies_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::RequestBodiesOrReferences* Components::unsafe_arena_release_request_bodies() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.request_bodies)
  
  ::gnostic::openapi::v3::RequestBodiesOrReferences* temp = _impl_.request_bodies_;
  _impl_.request_bodies_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::RequestBodiesOrReferences* Components::_internal_mutable_request_bodies() {
  
  if (_impl_.request_bodies_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::RequestBodiesOrReferences>(GetArenaForAllocation());
    _impl_.request_bodies_ = p;
  }
  return _impl_.request_bodies_;
}
inline ::gnostic::openapi::v3::RequestBodiesOrReferences* Components::mutable_request_bodies() {
  ::gnostic::openapi::v3::RequestBodiesOrReferences* _msg = _internal_mutable_request_bodies();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.request_bodies)
  return _msg;
}
inline void Components::set_allocated_request_bodies(::gnostic::openapi::v3::RequestBodiesOrReferences* request_bodies) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_bodies_;
  }
  if (request_bodies) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_bodies);
    if (message_arena != submessage_arena) {
      request_bodies = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_bodies, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_bodies_ = request_bodies;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.request_bodies)
}

// .gnostic.openapi.v3.HeadersOrReferences headers = 6;
inline bool Components::_internal_has_headers() const {
  return this != internal_default_instance() && _impl_.headers_ != nullptr;
}
inline bool Components::has_headers() const {
  return _internal_has_headers();
}
inline void Components::clear_headers() {
  if (GetArenaForAllocation() == nullptr && _impl_.headers_ != nullptr) {
    delete _impl_.headers_;
  }
  _impl_.headers_ = nullptr;
}
inline const ::gnostic::openapi::v3::HeadersOrReferences& Components::_internal_headers() const {
  const ::gnostic::openapi::v3::HeadersOrReferences* p = _impl_.headers_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::HeadersOrReferences&>(
      ::gnostic::openapi::v3::_HeadersOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::HeadersOrReferences& Components::headers() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.headers)
  return _internal_headers();
}
inline void Components::unsafe_arena_set_allocated_headers(
    ::gnostic::openapi::v3::HeadersOrReferences* headers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.headers_);
  }
  _impl_.headers_ = headers;
  if (headers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.headers)
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Components::release_headers() {
  
  ::gnostic::openapi::v3::HeadersOrReferences* temp = _impl_.headers_;
  _impl_.headers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Components::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.headers)
  
  ::gnostic::openapi::v3::HeadersOrReferences* temp = _impl_.headers_;
  _impl_.headers_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Components::_internal_mutable_headers() {
  
  if (_impl_.headers_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::HeadersOrReferences>(GetArenaForAllocation());
    _impl_.headers_ = p;
  }
  return _impl_.headers_;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Components::mutable_headers() {
  ::gnostic::openapi::v3::HeadersOrReferences* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.headers)
  return _msg;
}
inline void Components::set_allocated_headers(::gnostic::openapi::v3::HeadersOrReferences* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.headers_;
  }
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(headers);
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.headers_ = headers;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.headers)
}

// .gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7;
inline bool Components::_internal_has_security_schemes() const {
  return this != internal_default_instance() && _impl_.security_schemes_ != nullptr;
}
inline bool Components::has_security_schemes() const {
  return _internal_has_security_schemes();
}
inline void Components::clear_security_schemes() {
  if (GetArenaForAllocation() == nullptr && _impl_.security_schemes_ != nullptr) {
    delete _impl_.security_schemes_;
  }
  _impl_.security_schemes_ = nullptr;
}
inline const ::gnostic::openapi::v3::SecuritySchemesOrReferences& Components::_internal_security_schemes() const {
  const ::gnostic::openapi::v3::SecuritySchemesOrReferences* p = _impl_.security_schemes_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::SecuritySchemesOrReferences&>(
      ::gnostic::openapi::v3::_SecuritySchemesOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::SecuritySchemesOrReferences& Components::security_schemes() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.security_schemes)
  return _internal_security_schemes();
}
inline void Components::unsafe_arena_set_allocated_security_schemes(
    ::gnostic::openapi::v3::SecuritySchemesOrReferences* security_schemes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_schemes_);
  }
  _impl_.security_schemes_ = security_schemes;
  if (security_schemes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.security_schemes)
}
inline ::gnostic::openapi::v3::SecuritySchemesOrReferences* Components::release_security_schemes() {
  
  ::gnostic::openapi::v3::SecuritySchemesOrReferences* temp = _impl_.security_schemes_;
  _impl_.security_schemes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::SecuritySchemesOrReferences* Components::unsafe_arena_release_security_schemes() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.security_schemes)
  
  ::gnostic::openapi::v3::SecuritySchemesOrReferences* temp = _impl_.security_schemes_;
  _impl_.security_schemes_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::SecuritySchemesOrReferences* Components::_internal_mutable_security_schemes() {
  
  if (_impl_.security_schemes_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::SecuritySchemesOrReferences>(GetArenaForAllocation());
    _impl_.security_schemes_ = p;
  }
  return _impl_.security_schemes_;
}
inline ::gnostic::openapi::v3::SecuritySchemesOrReferences* Components::mutable_security_schemes() {
  ::gnostic::openapi::v3::SecuritySchemesOrReferences* _msg = _internal_mutable_security_schemes();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.security_schemes)
  return _msg;
}
inline void Components::set_allocated_security_schemes(::gnostic::openapi::v3::SecuritySchemesOrReferences* security_schemes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.security_schemes_;
  }
  if (security_schemes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security_schemes);
    if (message_arena != submessage_arena) {
      security_schemes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security_schemes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.security_schemes_ = security_schemes;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.security_schemes)
}

// .gnostic.openapi.v3.LinksOrReferences links = 8;
inline bool Components::_internal_has_links() const {
  return this != internal_default_instance() && _impl_.links_ != nullptr;
}
inline bool Components::has_links() const {
  return _internal_has_links();
}
inline void Components::clear_links() {
  if (GetArenaForAllocation() == nullptr && _impl_.links_ != nullptr) {
    delete _impl_.links_;
  }
  _impl_.links_ = nullptr;
}
inline const ::gnostic::openapi::v3::LinksOrReferences& Components::_internal_links() const {
  const ::gnostic::openapi::v3::LinksOrReferences* p = _impl_.links_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::LinksOrReferences&>(
      ::gnostic::openapi::v3::_LinksOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::LinksOrReferences& Components::links() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.links)
  return _internal_links();
}
inline void Components::unsafe_arena_set_allocated_links(
    ::gnostic::openapi::v3::LinksOrReferences* links) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.links_);
  }
  _impl_.links_ = links;
  if (links) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.links)
}
inline ::gnostic::openapi::v3::LinksOrReferences* Components::release_links() {
  
  ::gnostic::openapi::v3::LinksOrReferences* temp = _impl_.links_;
  _impl_.links_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::LinksOrReferences* Components::unsafe_arena_release_links() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.links)
  
  ::gnostic::openapi::v3::LinksOrReferences* temp = _impl_.links_;
  _impl_.links_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::LinksOrReferences* Components::_internal_mutable_links() {
  
  if (_impl_.links_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::LinksOrReferences>(GetArenaForAllocation());
    _impl_.links_ = p;
  }
  return _impl_.links_;
}
inline ::gnostic::openapi::v3::LinksOrReferences* Components::mutable_links() {
  ::gnostic::openapi::v3::LinksOrReferences* _msg = _internal_mutable_links();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.links)
  return _msg;
}
inline void Components::set_allocated_links(::gnostic::openapi::v3::LinksOrReferences* links) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.links_;
  }
  if (links) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(links);
    if (message_arena != submessage_arena) {
      links = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, links, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.links_ = links;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.links)
}

// .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
inline bool Components::_internal_has_callbacks() const {
  return this != internal_default_instance() && _impl_.callbacks_ != nullptr;
}
inline bool Components::has_callbacks() const {
  return _internal_has_callbacks();
}
inline void Components::clear_callbacks() {
  if (GetArenaForAllocation() == nullptr && _impl_.callbacks_ != nullptr) {
    delete _impl_.callbacks_;
  }
  _impl_.callbacks_ = nullptr;
}
inline const ::gnostic::openapi::v3::CallbacksOrReferences& Components::_internal_callbacks() const {
  const ::gnostic::openapi::v3::CallbacksOrReferences* p = _impl_.callbacks_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::CallbacksOrReferences&>(
      ::gnostic::openapi::v3::_CallbacksOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::CallbacksOrReferences& Components::callbacks() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.callbacks)
  return _internal_callbacks();
}
inline void Components::unsafe_arena_set_allocated_callbacks(
    ::gnostic::openapi::v3::CallbacksOrReferences* callbacks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.callbacks_);
  }
  _impl_.callbacks_ = callbacks;
  if (callbacks) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Components.callbacks)
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Components::release_callbacks() {
  
  ::gnostic::openapi::v3::CallbacksOrReferences* temp = _impl_.callbacks_;
  _impl_.callbacks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Components::unsafe_arena_release_callbacks() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Components.callbacks)
  
  ::gnostic::openapi::v3::CallbacksOrReferences* temp = _impl_.callbacks_;
  _impl_.callbacks_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Components::_internal_mutable_callbacks() {
  
  if (_impl_.callbacks_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::CallbacksOrReferences>(GetArenaForAllocation());
    _impl_.callbacks_ = p;
  }
  return _impl_.callbacks_;
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Components::mutable_callbacks() {
  ::gnostic::openapi::v3::CallbacksOrReferences* _msg = _internal_mutable_callbacks();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.callbacks)
  return _msg;
}
inline void Components::set_allocated_callbacks(::gnostic::openapi::v3::CallbacksOrReferences* callbacks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.callbacks_;
  }
  if (callbacks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(callbacks);
    if (message_arena != submessage_arena) {
      callbacks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callbacks, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.callbacks_ = callbacks;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Components.callbacks)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 10;
inline int Components::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Components::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Components::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Components::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Components.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Components::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Components.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Components::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Components::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Components.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Components::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Components::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Components.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Components::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Components.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Contact

// string name = 1;
inline void Contact::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Contact::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Contact.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contact::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Contact.name)
}
inline std::string* Contact::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Contact.name)
  return _s;
}
inline const std::string& Contact::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Contact::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Contact::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Contact.name)
  return _impl_.name_.Release();
}
inline void Contact::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Contact.name)
}

// string url = 2;
inline void Contact::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Contact::url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Contact.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contact::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Contact.url)
}
inline std::string* Contact::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Contact.url)
  return _s;
}
inline const std::string& Contact::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Contact::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Contact::release_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Contact.url)
  return _impl_.url_.Release();
}
inline void Contact::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Contact.url)
}

// string email = 3;
inline void Contact::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& Contact::email() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Contact.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contact::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Contact.email)
}
inline std::string* Contact::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Contact.email)
  return _s;
}
inline const std::string& Contact::_internal_email() const {
  return _impl_.email_.Get();
}
inline void Contact::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* Contact::release_email() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Contact.email)
  return _impl_.email_.Release();
}
inline void Contact::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Contact.email)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
inline int Contact::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Contact::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Contact::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Contact::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Contact.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Contact::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Contact.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Contact::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Contact::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Contact.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Contact::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Contact::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Contact.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Contact::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Contact.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// DefaultType

// double number = 1;
inline bool DefaultType::_internal_has_number() const {
  return oneof_case() == kNumber;
}
inline bool DefaultType::has_number() const {
  return _internal_has_number();
}
inline void DefaultType::set_has_number() {
  _impl_._oneof_case_[0] = kNumber;
}
inline void DefaultType::clear_number() {
  if (_internal_has_number()) {
    _impl_.oneof_.number_ = 0;
    clear_has_oneof();
  }
}
inline double DefaultType::_internal_number() const {
  if (_internal_has_number()) {
    return _impl_.oneof_.number_;
  }
  return 0;
}
inline void DefaultType::_internal_set_number(double value) {
  if (!_internal_has_number()) {
    clear_oneof();
    set_has_number();
  }
  _impl_.oneof_.number_ = value;
}
inline double DefaultType::number() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.DefaultType.number)
  return _internal_number();
}
inline void DefaultType::set_number(double value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.DefaultType.number)
}

// bool boolean = 2;
inline bool DefaultType::_internal_has_boolean() const {
  return oneof_case() == kBoolean;
}
inline bool DefaultType::has_boolean() const {
  return _internal_has_boolean();
}
inline void DefaultType::set_has_boolean() {
  _impl_._oneof_case_[0] = kBoolean;
}
inline void DefaultType::clear_boolean() {
  if (_internal_has_boolean()) {
    _impl_.oneof_.boolean_ = false;
    clear_has_oneof();
  }
}
inline bool DefaultType::_internal_boolean() const {
  if (_internal_has_boolean()) {
    return _impl_.oneof_.boolean_;
  }
  return false;
}
inline void DefaultType::_internal_set_boolean(bool value) {
  if (!_internal_has_boolean()) {
    clear_oneof();
    set_has_boolean();
  }
  _impl_.oneof_.boolean_ = value;
}
inline bool DefaultType::boolean() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.DefaultType.boolean)
  return _internal_boolean();
}
inline void DefaultType::set_boolean(bool value) {
  _internal_set_boolean(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.DefaultType.boolean)
}

// string string = 3;
inline bool DefaultType::_internal_has_string() const {
  return oneof_case() == kString;
}
inline bool DefaultType::has_string() const {
  return _internal_has_string();
}
inline void DefaultType::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void DefaultType::clear_string() {
  if (_internal_has_string()) {
    _impl_.oneof_.string_.Destroy();
    clear_has_oneof();
  }
}
inline const std::string& DefaultType::string() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.DefaultType.string)
  return _internal_string();
}
template <typename ArgT0, typename... ArgT>
inline void DefaultType::set_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string()) {
    clear_oneof();
    set_has_string();
    _impl_.oneof_.string_.InitDefault();
  }
  _impl_.oneof_.string_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.DefaultType.string)
}
inline std::string* DefaultType::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.DefaultType.string)
  return _s;
}
inline const std::string& DefaultType::_internal_string() const {
  if (_internal_has_string()) {
    return _impl_.oneof_.string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DefaultType::_internal_set_string(const std::string& value) {
  if (!_internal_has_string()) {
    clear_oneof();
    set_has_string();
    _impl_.oneof_.string_.InitDefault();
  }
  _impl_.oneof_.string_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultType::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_oneof();
    set_has_string();
    _impl_.oneof_.string_.InitDefault();
  }
  return _impl_.oneof_.string_.Mutable(      GetArenaForAllocation());
}
inline std::string* DefaultType::release_string() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.DefaultType.string)
  if (_internal_has_string()) {
    clear_has_oneof();
    return _impl_.oneof_.string_.Release();
  } else {
    return nullptr;
  }
}
inline void DefaultType::set_allocated_string(std::string* string) {
  if (has_oneof()) {
    clear_oneof();
  }
  if (string != nullptr) {
    set_has_string();
    _impl_.oneof_.string_.InitAllocated(string, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.DefaultType.string)
}

inline bool DefaultType::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void DefaultType::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline DefaultType::OneofCase DefaultType::oneof_case() const {
  return DefaultType::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Discriminator

// string property_name = 1;
inline void Discriminator::clear_property_name() {
  _impl_.property_name_.ClearToEmpty();
}
inline const std::string& Discriminator::property_name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Discriminator.property_name)
  return _internal_property_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Discriminator::set_property_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.property_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Discriminator.property_name)
}
inline std::string* Discriminator::mutable_property_name() {
  std::string* _s = _internal_mutable_property_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Discriminator.property_name)
  return _s;
}
inline const std::string& Discriminator::_internal_property_name() const {
  return _impl_.property_name_.Get();
}
inline void Discriminator::_internal_set_property_name(const std::string& value) {
  
  _impl_.property_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Discriminator::_internal_mutable_property_name() {
  
  return _impl_.property_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Discriminator::release_property_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Discriminator.property_name)
  return _impl_.property_name_.Release();
}
inline void Discriminator::set_allocated_property_name(std::string* property_name) {
  if (property_name != nullptr) {
    
  } else {
    
  }
  _impl_.property_name_.SetAllocated(property_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.property_name_.IsDefault()) {
    _impl_.property_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Discriminator.property_name)
}

// .gnostic.openapi.v3.Strings mapping = 2;
inline bool Discriminator::_internal_has_mapping() const {
  return this != internal_default_instance() && _impl_.mapping_ != nullptr;
}
inline bool Discriminator::has_mapping() const {
  return _internal_has_mapping();
}
inline void Discriminator::clear_mapping() {
  if (GetArenaForAllocation() == nullptr && _impl_.mapping_ != nullptr) {
    delete _impl_.mapping_;
  }
  _impl_.mapping_ = nullptr;
}
inline const ::gnostic::openapi::v3::Strings& Discriminator::_internal_mapping() const {
  const ::gnostic::openapi::v3::Strings* p = _impl_.mapping_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Strings&>(
      ::gnostic::openapi::v3::_Strings_default_instance_);
}
inline const ::gnostic::openapi::v3::Strings& Discriminator::mapping() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Discriminator.mapping)
  return _internal_mapping();
}
inline void Discriminator::unsafe_arena_set_allocated_mapping(
    ::gnostic::openapi::v3::Strings* mapping) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mapping_);
  }
  _impl_.mapping_ = mapping;
  if (mapping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Discriminator.mapping)
}
inline ::gnostic::openapi::v3::Strings* Discriminator::release_mapping() {
  
  ::gnostic::openapi::v3::Strings* temp = _impl_.mapping_;
  _impl_.mapping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Strings* Discriminator::unsafe_arena_release_mapping() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Discriminator.mapping)
  
  ::gnostic::openapi::v3::Strings* temp = _impl_.mapping_;
  _impl_.mapping_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Strings* Discriminator::_internal_mutable_mapping() {
  
  if (_impl_.mapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Strings>(GetArenaForAllocation());
    _impl_.mapping_ = p;
  }
  return _impl_.mapping_;
}
inline ::gnostic::openapi::v3::Strings* Discriminator::mutable_mapping() {
  ::gnostic::openapi::v3::Strings* _msg = _internal_mutable_mapping();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Discriminator.mapping)
  return _msg;
}
inline void Discriminator::set_allocated_mapping(::gnostic::openapi::v3::Strings* mapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mapping_;
  }
  if (mapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mapping);
    if (message_arena != submessage_arena) {
      mapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapping, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mapping_ = mapping;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Discriminator.mapping)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
inline int Discriminator::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Discriminator::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Discriminator::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Discriminator::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Discriminator.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Discriminator::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Discriminator.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Discriminator::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Discriminator::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Discriminator.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Discriminator::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Discriminator::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Discriminator.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Discriminator::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Discriminator.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Document

// string openapi = 1;
inline void Document::clear_openapi() {
  _impl_.openapi_.ClearToEmpty();
}
inline const std::string& Document::openapi() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.openapi)
  return _internal_openapi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_openapi(ArgT0&& arg0, ArgT... args) {
 
 _impl_.openapi_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Document.openapi)
}
inline std::string* Document::mutable_openapi() {
  std::string* _s = _internal_mutable_openapi();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.openapi)
  return _s;
}
inline const std::string& Document::_internal_openapi() const {
  return _impl_.openapi_.Get();
}
inline void Document::_internal_set_openapi(const std::string& value) {
  
  _impl_.openapi_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_openapi() {
  
  return _impl_.openapi_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_openapi() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Document.openapi)
  return _impl_.openapi_.Release();
}
inline void Document::set_allocated_openapi(std::string* openapi) {
  if (openapi != nullptr) {
    
  } else {
    
  }
  _impl_.openapi_.SetAllocated(openapi, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.openapi_.IsDefault()) {
    _impl_.openapi_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Document.openapi)
}

// .gnostic.openapi.v3.Info info = 2;
inline bool Document::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool Document::has_info() const {
  return _internal_has_info();
}
inline void Document::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::gnostic::openapi::v3::Info& Document::_internal_info() const {
  const ::gnostic::openapi::v3::Info* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Info&>(
      ::gnostic::openapi::v3::_Info_default_instance_);
}
inline const ::gnostic::openapi::v3::Info& Document::info() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.info)
  return _internal_info();
}
inline void Document::unsafe_arena_set_allocated_info(
    ::gnostic::openapi::v3::Info* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Document.info)
}
inline ::gnostic::openapi::v3::Info* Document::release_info() {
  
  ::gnostic::openapi::v3::Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Info* Document::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Document.info)
  
  ::gnostic::openapi::v3::Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Info* Document::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Info>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::gnostic::openapi::v3::Info* Document::mutable_info() {
  ::gnostic::openapi::v3::Info* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.info)
  return _msg;
}
inline void Document::set_allocated_info(::gnostic::openapi::v3::Info* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Document.info)
}

// repeated .gnostic.openapi.v3.Server servers = 3;
inline int Document::_internal_servers_size() const {
  return _impl_.servers_.size();
}
inline int Document::servers_size() const {
  return _internal_servers_size();
}
inline void Document::clear_servers() {
  _impl_.servers_.Clear();
}
inline ::gnostic::openapi::v3::Server* Document::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.servers)
  return _impl_.servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >*
Document::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Document.servers)
  return &_impl_.servers_;
}
inline const ::gnostic::openapi::v3::Server& Document::_internal_servers(int index) const {
  return _impl_.servers_.Get(index);
}
inline const ::gnostic::openapi::v3::Server& Document::servers(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.servers)
  return _internal_servers(index);
}
inline ::gnostic::openapi::v3::Server* Document::_internal_add_servers() {
  return _impl_.servers_.Add();
}
inline ::gnostic::openapi::v3::Server* Document::add_servers() {
  ::gnostic::openapi::v3::Server* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Document.servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >&
Document::servers() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Document.servers)
  return _impl_.servers_;
}

// .gnostic.openapi.v3.Paths paths = 4;
inline bool Document::_internal_has_paths() const {
  return this != internal_default_instance() && _impl_.paths_ != nullptr;
}
inline bool Document::has_paths() const {
  return _internal_has_paths();
}
inline void Document::clear_paths() {
  if (GetArenaForAllocation() == nullptr && _impl_.paths_ != nullptr) {
    delete _impl_.paths_;
  }
  _impl_.paths_ = nullptr;
}
inline const ::gnostic::openapi::v3::Paths& Document::_internal_paths() const {
  const ::gnostic::openapi::v3::Paths* p = _impl_.paths_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Paths&>(
      ::gnostic::openapi::v3::_Paths_default_instance_);
}
inline const ::gnostic::openapi::v3::Paths& Document::paths() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.paths)
  return _internal_paths();
}
inline void Document::unsafe_arena_set_allocated_paths(
    ::gnostic::openapi::v3::Paths* paths) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paths_);
  }
  _impl_.paths_ = paths;
  if (paths) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Document.paths)
}
inline ::gnostic::openapi::v3::Paths* Document::release_paths() {
  
  ::gnostic::openapi::v3::Paths* temp = _impl_.paths_;
  _impl_.paths_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Paths* Document::unsafe_arena_release_paths() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Document.paths)
  
  ::gnostic::openapi::v3::Paths* temp = _impl_.paths_;
  _impl_.paths_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Paths* Document::_internal_mutable_paths() {
  
  if (_impl_.paths_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Paths>(GetArenaForAllocation());
    _impl_.paths_ = p;
  }
  return _impl_.paths_;
}
inline ::gnostic::openapi::v3::Paths* Document::mutable_paths() {
  ::gnostic::openapi::v3::Paths* _msg = _internal_mutable_paths();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.paths)
  return _msg;
}
inline void Document::set_allocated_paths(::gnostic::openapi::v3::Paths* paths) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paths_;
  }
  if (paths) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paths);
    if (message_arena != submessage_arena) {
      paths = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paths, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.paths_ = paths;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Document.paths)
}

// .gnostic.openapi.v3.Components components = 5;
inline bool Document::_internal_has_components() const {
  return this != internal_default_instance() && _impl_.components_ != nullptr;
}
inline bool Document::has_components() const {
  return _internal_has_components();
}
inline void Document::clear_components() {
  if (GetArenaForAllocation() == nullptr && _impl_.components_ != nullptr) {
    delete _impl_.components_;
  }
  _impl_.components_ = nullptr;
}
inline const ::gnostic::openapi::v3::Components& Document::_internal_components() const {
  const ::gnostic::openapi::v3::Components* p = _impl_.components_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Components&>(
      ::gnostic::openapi::v3::_Components_default_instance_);
}
inline const ::gnostic::openapi::v3::Components& Document::components() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.components)
  return _internal_components();
}
inline void Document::unsafe_arena_set_allocated_components(
    ::gnostic::openapi::v3::Components* components) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.components_);
  }
  _impl_.components_ = components;
  if (components) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Document.components)
}
inline ::gnostic::openapi::v3::Components* Document::release_components() {
  
  ::gnostic::openapi::v3::Components* temp = _impl_.components_;
  _impl_.components_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Components* Document::unsafe_arena_release_components() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Document.components)
  
  ::gnostic::openapi::v3::Components* temp = _impl_.components_;
  _impl_.components_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Components* Document::_internal_mutable_components() {
  
  if (_impl_.components_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Components>(GetArenaForAllocation());
    _impl_.components_ = p;
  }
  return _impl_.components_;
}
inline ::gnostic::openapi::v3::Components* Document::mutable_components() {
  ::gnostic::openapi::v3::Components* _msg = _internal_mutable_components();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.components)
  return _msg;
}
inline void Document::set_allocated_components(::gnostic::openapi::v3::Components* components) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.components_;
  }
  if (components) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(components);
    if (message_arena != submessage_arena) {
      components = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, components, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.components_ = components;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Document.components)
}

// repeated .gnostic.openapi.v3.SecurityRequirement security = 6;
inline int Document::_internal_security_size() const {
  return _impl_.security_.size();
}
inline int Document::security_size() const {
  return _internal_security_size();
}
inline void Document::clear_security() {
  _impl_.security_.Clear();
}
inline ::gnostic::openapi::v3::SecurityRequirement* Document::mutable_security(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.security)
  return _impl_.security_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >*
Document::mutable_security() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Document.security)
  return &_impl_.security_;
}
inline const ::gnostic::openapi::v3::SecurityRequirement& Document::_internal_security(int index) const {
  return _impl_.security_.Get(index);
}
inline const ::gnostic::openapi::v3::SecurityRequirement& Document::security(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.security)
  return _internal_security(index);
}
inline ::gnostic::openapi::v3::SecurityRequirement* Document::_internal_add_security() {
  return _impl_.security_.Add();
}
inline ::gnostic::openapi::v3::SecurityRequirement* Document::add_security() {
  ::gnostic::openapi::v3::SecurityRequirement* _add = _internal_add_security();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Document.security)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >&
Document::security() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Document.security)
  return _impl_.security_;
}

// repeated .gnostic.openapi.v3.Tag tags = 7;
inline int Document::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int Document::tags_size() const {
  return _internal_tags_size();
}
inline void Document::clear_tags() {
  _impl_.tags_.Clear();
}
inline ::gnostic::openapi::v3::Tag* Document::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.tags)
  return _impl_.tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Tag >*
Document::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Document.tags)
  return &_impl_.tags_;
}
inline const ::gnostic::openapi::v3::Tag& Document::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const ::gnostic::openapi::v3::Tag& Document::tags(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.tags)
  return _internal_tags(index);
}
inline ::gnostic::openapi::v3::Tag* Document::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline ::gnostic::openapi::v3::Tag* Document::add_tags() {
  ::gnostic::openapi::v3::Tag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Document.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Tag >&
Document::tags() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Document.tags)
  return _impl_.tags_;
}

// .gnostic.openapi.v3.ExternalDocs external_docs = 8;
inline bool Document::_internal_has_external_docs() const {
  return this != internal_default_instance() && _impl_.external_docs_ != nullptr;
}
inline bool Document::has_external_docs() const {
  return _internal_has_external_docs();
}
inline void Document::clear_external_docs() {
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExternalDocs& Document::_internal_external_docs() const {
  const ::gnostic::openapi::v3::ExternalDocs* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExternalDocs&>(
      ::gnostic::openapi::v3::_ExternalDocs_default_instance_);
}
inline const ::gnostic::openapi::v3::ExternalDocs& Document::external_docs() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.external_docs)
  return _internal_external_docs();
}
inline void Document::unsafe_arena_set_allocated_external_docs(
    ::gnostic::openapi::v3::ExternalDocs* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Document.external_docs)
}
inline ::gnostic::openapi::v3::ExternalDocs* Document::release_external_docs() {
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Document::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Document.external_docs)
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Document::_internal_mutable_external_docs() {
  
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExternalDocs>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::gnostic::openapi::v3::ExternalDocs* Document::mutable_external_docs() {
  ::gnostic::openapi::v3::ExternalDocs* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.external_docs)
  return _msg;
}
inline void Document::set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Document.external_docs)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
inline int Document::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Document::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Document::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Document::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Document.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Document::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Document.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Document::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Document::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Document.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Document::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Document::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Document.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Document::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Document.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Encoding

// string content_type = 1;
inline void Encoding::clear_content_type() {
  _impl_.content_type_.ClearToEmpty();
}
inline const std::string& Encoding::content_type() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Encoding.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Encoding::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Encoding.content_type)
}
inline std::string* Encoding::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Encoding.content_type)
  return _s;
}
inline const std::string& Encoding::_internal_content_type() const {
  return _impl_.content_type_.Get();
}
inline void Encoding::_internal_set_content_type(const std::string& value) {
  
  _impl_.content_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Encoding::_internal_mutable_content_type() {
  
  return _impl_.content_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Encoding::release_content_type() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Encoding.content_type)
  return _impl_.content_type_.Release();
}
inline void Encoding::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  _impl_.content_type_.SetAllocated(content_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_type_.IsDefault()) {
    _impl_.content_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Encoding.content_type)
}

// .gnostic.openapi.v3.HeadersOrReferences headers = 2;
inline bool Encoding::_internal_has_headers() const {
  return this != internal_default_instance() && _impl_.headers_ != nullptr;
}
inline bool Encoding::has_headers() const {
  return _internal_has_headers();
}
inline void Encoding::clear_headers() {
  if (GetArenaForAllocation() == nullptr && _impl_.headers_ != nullptr) {
    delete _impl_.headers_;
  }
  _impl_.headers_ = nullptr;
}
inline const ::gnostic::openapi::v3::HeadersOrReferences& Encoding::_internal_headers() const {
  const ::gnostic::openapi::v3::HeadersOrReferences* p = _impl_.headers_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::HeadersOrReferences&>(
      ::gnostic::openapi::v3::_HeadersOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::HeadersOrReferences& Encoding::headers() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Encoding.headers)
  return _internal_headers();
}
inline void Encoding::unsafe_arena_set_allocated_headers(
    ::gnostic::openapi::v3::HeadersOrReferences* headers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.headers_);
  }
  _impl_.headers_ = headers;
  if (headers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Encoding.headers)
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Encoding::release_headers() {
  
  ::gnostic::openapi::v3::HeadersOrReferences* temp = _impl_.headers_;
  _impl_.headers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Encoding::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Encoding.headers)
  
  ::gnostic::openapi::v3::HeadersOrReferences* temp = _impl_.headers_;
  _impl_.headers_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Encoding::_internal_mutable_headers() {
  
  if (_impl_.headers_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::HeadersOrReferences>(GetArenaForAllocation());
    _impl_.headers_ = p;
  }
  return _impl_.headers_;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Encoding::mutable_headers() {
  ::gnostic::openapi::v3::HeadersOrReferences* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Encoding.headers)
  return _msg;
}
inline void Encoding::set_allocated_headers(::gnostic::openapi::v3::HeadersOrReferences* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.headers_;
  }
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(headers);
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.headers_ = headers;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Encoding.headers)
}

// string style = 3;
inline void Encoding::clear_style() {
  _impl_.style_.ClearToEmpty();
}
inline const std::string& Encoding::style() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Encoding.style)
  return _internal_style();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Encoding::set_style(ArgT0&& arg0, ArgT... args) {
 
 _impl_.style_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Encoding.style)
}
inline std::string* Encoding::mutable_style() {
  std::string* _s = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Encoding.style)
  return _s;
}
inline const std::string& Encoding::_internal_style() const {
  return _impl_.style_.Get();
}
inline void Encoding::_internal_set_style(const std::string& value) {
  
  _impl_.style_.Set(value, GetArenaForAllocation());
}
inline std::string* Encoding::_internal_mutable_style() {
  
  return _impl_.style_.Mutable(GetArenaForAllocation());
}
inline std::string* Encoding::release_style() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Encoding.style)
  return _impl_.style_.Release();
}
inline void Encoding::set_allocated_style(std::string* style) {
  if (style != nullptr) {
    
  } else {
    
  }
  _impl_.style_.SetAllocated(style, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.style_.IsDefault()) {
    _impl_.style_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Encoding.style)
}

// bool explode = 4;
inline void Encoding::clear_explode() {
  _impl_.explode_ = false;
}
inline bool Encoding::_internal_explode() const {
  return _impl_.explode_;
}
inline bool Encoding::explode() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Encoding.explode)
  return _internal_explode();
}
inline void Encoding::_internal_set_explode(bool value) {
  
  _impl_.explode_ = value;
}
inline void Encoding::set_explode(bool value) {
  _internal_set_explode(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Encoding.explode)
}

// bool allow_reserved = 5;
inline void Encoding::clear_allow_reserved() {
  _impl_.allow_reserved_ = false;
}
inline bool Encoding::_internal_allow_reserved() const {
  return _impl_.allow_reserved_;
}
inline bool Encoding::allow_reserved() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Encoding.allow_reserved)
  return _internal_allow_reserved();
}
inline void Encoding::_internal_set_allow_reserved(bool value) {
  
  _impl_.allow_reserved_ = value;
}
inline void Encoding::set_allow_reserved(bool value) {
  _internal_set_allow_reserved(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Encoding.allow_reserved)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
inline int Encoding::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Encoding::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Encoding::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Encoding::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Encoding.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Encoding::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Encoding.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Encoding::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Encoding::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Encoding.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Encoding::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Encoding::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Encoding.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Encoding::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Encoding.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Encodings

// repeated .gnostic.openapi.v3.NamedEncoding additional_properties = 1;
inline int Encodings::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int Encodings::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void Encodings::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedEncoding* Encodings::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Encodings.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedEncoding >*
Encodings::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Encodings.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedEncoding& Encodings::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedEncoding& Encodings::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Encodings.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedEncoding* Encodings::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedEncoding* Encodings::add_additional_properties() {
  ::gnostic::openapi::v3::NamedEncoding* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Encodings.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedEncoding >&
Encodings::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Encodings.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Example

// string summary = 1;
inline void Example::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& Example::summary() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Example.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Example::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Example.summary)
}
inline std::string* Example::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Example.summary)
  return _s;
}
inline const std::string& Example::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void Example::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* Example::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* Example::release_summary() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Example.summary)
  return _impl_.summary_.Release();
}
inline void Example::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Example.summary)
}

// string description = 2;
inline void Example::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Example::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Example.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Example::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Example.description)
}
inline std::string* Example::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Example.description)
  return _s;
}
inline const std::string& Example::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Example::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Example::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Example::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Example.description)
  return _impl_.description_.Release();
}
inline void Example::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Example.description)
}

// .gnostic.openapi.v3.Any value = 3;
inline bool Example::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool Example::has_value() const {
  return _internal_has_value();
}
inline void Example::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::Any& Example::_internal_value() const {
  const ::gnostic::openapi::v3::Any* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Any&>(
      ::gnostic::openapi::v3::_Any_default_instance_);
}
inline const ::gnostic::openapi::v3::Any& Example::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Example.value)
  return _internal_value();
}
inline void Example::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::Any* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Example.value)
}
inline ::gnostic::openapi::v3::Any* Example::release_value() {
  
  ::gnostic::openapi::v3::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Any* Example::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Example.value)
  
  ::gnostic::openapi::v3::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Any* Example::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Any>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::Any* Example::mutable_value() {
  ::gnostic::openapi::v3::Any* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Example.value)
  return _msg;
}
inline void Example::set_allocated_value(::gnostic::openapi::v3::Any* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Example.value)
}

// string external_value = 4;
inline void Example::clear_external_value() {
  _impl_.external_value_.ClearToEmpty();
}
inline const std::string& Example::external_value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Example.external_value)
  return _internal_external_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Example::set_external_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.external_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Example.external_value)
}
inline std::string* Example::mutable_external_value() {
  std::string* _s = _internal_mutable_external_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Example.external_value)
  return _s;
}
inline const std::string& Example::_internal_external_value() const {
  return _impl_.external_value_.Get();
}
inline void Example::_internal_set_external_value(const std::string& value) {
  
  _impl_.external_value_.Set(value, GetArenaForAllocation());
}
inline std::string* Example::_internal_mutable_external_value() {
  
  return _impl_.external_value_.Mutable(GetArenaForAllocation());
}
inline std::string* Example::release_external_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Example.external_value)
  return _impl_.external_value_.Release();
}
inline void Example::set_allocated_external_value(std::string* external_value) {
  if (external_value != nullptr) {
    
  } else {
    
  }
  _impl_.external_value_.SetAllocated(external_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_value_.IsDefault()) {
    _impl_.external_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Example.external_value)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
inline int Example::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Example::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Example::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Example::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Example.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Example::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Example.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Example::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Example::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Example.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Example::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Example::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Example.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Example::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Example.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// ExampleOrReference

// .gnostic.openapi.v3.Example example = 1;
inline bool ExampleOrReference::_internal_has_example() const {
  return oneof_case() == kExample;
}
inline bool ExampleOrReference::has_example() const {
  return _internal_has_example();
}
inline void ExampleOrReference::set_has_example() {
  _impl_._oneof_case_[0] = kExample;
}
inline void ExampleOrReference::clear_example() {
  if (_internal_has_example()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.example_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Example* ExampleOrReference::release_example() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ExampleOrReference.example)
  if (_internal_has_example()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Example* temp = _impl_.oneof_.example_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.example_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Example& ExampleOrReference::_internal_example() const {
  return _internal_has_example()
      ? *_impl_.oneof_.example_
      : reinterpret_cast< ::gnostic::openapi::v3::Example&>(::gnostic::openapi::v3::_Example_default_instance_);
}
inline const ::gnostic::openapi::v3::Example& ExampleOrReference::example() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ExampleOrReference.example)
  return _internal_example();
}
inline ::gnostic::openapi::v3::Example* ExampleOrReference::unsafe_arena_release_example() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.ExampleOrReference.example)
  if (_internal_has_example()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Example* temp = _impl_.oneof_.example_;
    _impl_.oneof_.example_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExampleOrReference::unsafe_arena_set_allocated_example(::gnostic::openapi::v3::Example* example) {
  clear_oneof();
  if (example) {
    set_has_example();
    _impl_.oneof_.example_ = example;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.ExampleOrReference.example)
}
inline ::gnostic::openapi::v3::Example* ExampleOrReference::_internal_mutable_example() {
  if (!_internal_has_example()) {
    clear_oneof();
    set_has_example();
    _impl_.oneof_.example_ = CreateMaybeMessage< ::gnostic::openapi::v3::Example >(GetArenaForAllocation());
  }
  return _impl_.oneof_.example_;
}
inline ::gnostic::openapi::v3::Example* ExampleOrReference::mutable_example() {
  ::gnostic::openapi::v3::Example* _msg = _internal_mutable_example();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ExampleOrReference.example)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool ExampleOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool ExampleOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void ExampleOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void ExampleOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* ExampleOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ExampleOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& ExampleOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& ExampleOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ExampleOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* ExampleOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.ExampleOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExampleOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.ExampleOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* ExampleOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* ExampleOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ExampleOrReference.reference)
  return _msg;
}

inline bool ExampleOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void ExampleOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline ExampleOrReference::OneofCase ExampleOrReference::oneof_case() const {
  return ExampleOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExamplesOrReferences

// repeated .gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1;
inline int ExamplesOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int ExamplesOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void ExamplesOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedExampleOrReference* ExamplesOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ExamplesOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedExampleOrReference >*
ExamplesOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ExamplesOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedExampleOrReference& ExamplesOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedExampleOrReference& ExamplesOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ExamplesOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedExampleOrReference* ExamplesOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedExampleOrReference* ExamplesOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedExampleOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ExamplesOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedExampleOrReference >&
ExamplesOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ExamplesOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Expression

// repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
inline int Expression::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int Expression::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void Expression::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Expression::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Expression.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Expression::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Expression.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedAny& Expression::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Expression::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Expression.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedAny* Expression::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Expression::add_additional_properties() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Expression.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Expression::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Expression.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// ExternalDocs

// string description = 1;
inline void ExternalDocs::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ExternalDocs::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ExternalDocs.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalDocs::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.ExternalDocs.description)
}
inline std::string* ExternalDocs::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ExternalDocs.description)
  return _s;
}
inline const std::string& ExternalDocs::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ExternalDocs::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalDocs::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalDocs::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ExternalDocs.description)
  return _impl_.description_.Release();
}
inline void ExternalDocs::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ExternalDocs.description)
}

// string url = 2;
inline void ExternalDocs::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& ExternalDocs::url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ExternalDocs.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalDocs::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.ExternalDocs.url)
}
inline std::string* ExternalDocs::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ExternalDocs.url)
  return _s;
}
inline const std::string& ExternalDocs::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ExternalDocs::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalDocs::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalDocs::release_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ExternalDocs.url)
  return _impl_.url_.Release();
}
inline void ExternalDocs::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ExternalDocs.url)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
inline int ExternalDocs::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int ExternalDocs::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void ExternalDocs::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* ExternalDocs::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ExternalDocs.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
ExternalDocs::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ExternalDocs.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& ExternalDocs::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& ExternalDocs::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ExternalDocs.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* ExternalDocs::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* ExternalDocs::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ExternalDocs.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
ExternalDocs::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ExternalDocs.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Header

// string description = 1;
inline void Header::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Header::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Header.description)
}
inline std::string* Header::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Header.description)
  return _s;
}
inline const std::string& Header::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Header::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Header.description)
  return _impl_.description_.Release();
}
inline void Header::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Header.description)
}

// bool required = 2;
inline void Header::clear_required() {
  _impl_.required_ = false;
}
inline bool Header::_internal_required() const {
  return _impl_.required_;
}
inline bool Header::required() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.required)
  return _internal_required();
}
inline void Header::_internal_set_required(bool value) {
  
  _impl_.required_ = value;
}
inline void Header::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Header.required)
}

// bool deprecated = 3;
inline void Header::clear_deprecated() {
  _impl_.deprecated_ = false;
}
inline bool Header::_internal_deprecated() const {
  return _impl_.deprecated_;
}
inline bool Header::deprecated() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.deprecated)
  return _internal_deprecated();
}
inline void Header::_internal_set_deprecated(bool value) {
  
  _impl_.deprecated_ = value;
}
inline void Header::set_deprecated(bool value) {
  _internal_set_deprecated(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Header.deprecated)
}

// bool allow_empty_value = 4;
inline void Header::clear_allow_empty_value() {
  _impl_.allow_empty_value_ = false;
}
inline bool Header::_internal_allow_empty_value() const {
  return _impl_.allow_empty_value_;
}
inline bool Header::allow_empty_value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.allow_empty_value)
  return _internal_allow_empty_value();
}
inline void Header::_internal_set_allow_empty_value(bool value) {
  
  _impl_.allow_empty_value_ = value;
}
inline void Header::set_allow_empty_value(bool value) {
  _internal_set_allow_empty_value(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Header.allow_empty_value)
}

// string style = 5;
inline void Header::clear_style() {
  _impl_.style_.ClearToEmpty();
}
inline const std::string& Header::style() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.style)
  return _internal_style();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_style(ArgT0&& arg0, ArgT... args) {
 
 _impl_.style_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Header.style)
}
inline std::string* Header::mutable_style() {
  std::string* _s = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Header.style)
  return _s;
}
inline const std::string& Header::_internal_style() const {
  return _impl_.style_.Get();
}
inline void Header::_internal_set_style(const std::string& value) {
  
  _impl_.style_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_style() {
  
  return _impl_.style_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_style() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Header.style)
  return _impl_.style_.Release();
}
inline void Header::set_allocated_style(std::string* style) {
  if (style != nullptr) {
    
  } else {
    
  }
  _impl_.style_.SetAllocated(style, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.style_.IsDefault()) {
    _impl_.style_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Header.style)
}

// bool explode = 6;
inline void Header::clear_explode() {
  _impl_.explode_ = false;
}
inline bool Header::_internal_explode() const {
  return _impl_.explode_;
}
inline bool Header::explode() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.explode)
  return _internal_explode();
}
inline void Header::_internal_set_explode(bool value) {
  
  _impl_.explode_ = value;
}
inline void Header::set_explode(bool value) {
  _internal_set_explode(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Header.explode)
}

// bool allow_reserved = 7;
inline void Header::clear_allow_reserved() {
  _impl_.allow_reserved_ = false;
}
inline bool Header::_internal_allow_reserved() const {
  return _impl_.allow_reserved_;
}
inline bool Header::allow_reserved() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.allow_reserved)
  return _internal_allow_reserved();
}
inline void Header::_internal_set_allow_reserved(bool value) {
  
  _impl_.allow_reserved_ = value;
}
inline void Header::set_allow_reserved(bool value) {
  _internal_set_allow_reserved(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Header.allow_reserved)
}

// .gnostic.openapi.v3.SchemaOrReference schema = 8;
inline bool Header::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool Header::has_schema() const {
  return _internal_has_schema();
}
inline void Header::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Header::_internal_schema() const {
  const ::gnostic::openapi::v3::SchemaOrReference* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::SchemaOrReference&>(
      ::gnostic::openapi::v3::_SchemaOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Header::schema() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.schema)
  return _internal_schema();
}
inline void Header::unsafe_arena_set_allocated_schema(
    ::gnostic::openapi::v3::SchemaOrReference* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Header.schema)
}
inline ::gnostic::openapi::v3::SchemaOrReference* Header::release_schema() {
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* Header::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Header.schema)
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* Header::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::SchemaOrReference>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::gnostic::openapi::v3::SchemaOrReference* Header::mutable_schema() {
  ::gnostic::openapi::v3::SchemaOrReference* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Header.schema)
  return _msg;
}
inline void Header::set_allocated_schema(::gnostic::openapi::v3::SchemaOrReference* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Header.schema)
}

// .gnostic.openapi.v3.Any example = 9;
inline bool Header::_internal_has_example() const {
  return this != internal_default_instance() && _impl_.example_ != nullptr;
}
inline bool Header::has_example() const {
  return _internal_has_example();
}
inline void Header::clear_example() {
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
}
inline const ::gnostic::openapi::v3::Any& Header::_internal_example() const {
  const ::gnostic::openapi::v3::Any* p = _impl_.example_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Any&>(
      ::gnostic::openapi::v3::_Any_default_instance_);
}
inline const ::gnostic::openapi::v3::Any& Header::example() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.example)
  return _internal_example();
}
inline void Header::unsafe_arena_set_allocated_example(
    ::gnostic::openapi::v3::Any* example) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.example_);
  }
  _impl_.example_ = example;
  if (example) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Header.example)
}
inline ::gnostic::openapi::v3::Any* Header::release_example() {
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Any* Header::unsafe_arena_release_example() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Header.example)
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Any* Header::_internal_mutable_example() {
  
  if (_impl_.example_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Any>(GetArenaForAllocation());
    _impl_.example_ = p;
  }
  return _impl_.example_;
}
inline ::gnostic::openapi::v3::Any* Header::mutable_example() {
  ::gnostic::openapi::v3::Any* _msg = _internal_mutable_example();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Header.example)
  return _msg;
}
inline void Header::set_allocated_example(::gnostic::openapi::v3::Any* example) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.example_;
  }
  if (example) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(example);
    if (message_arena != submessage_arena) {
      example = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.example_ = example;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Header.example)
}

// .gnostic.openapi.v3.ExamplesOrReferences examples = 10;
inline bool Header::_internal_has_examples() const {
  return this != internal_default_instance() && _impl_.examples_ != nullptr;
}
inline bool Header::has_examples() const {
  return _internal_has_examples();
}
inline void Header::clear_examples() {
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& Header::_internal_examples() const {
  const ::gnostic::openapi::v3::ExamplesOrReferences* p = _impl_.examples_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExamplesOrReferences&>(
      ::gnostic::openapi::v3::_ExamplesOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& Header::examples() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.examples)
  return _internal_examples();
}
inline void Header::unsafe_arena_set_allocated_examples(
    ::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.examples_);
  }
  _impl_.examples_ = examples;
  if (examples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Header.examples)
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Header::release_examples() {
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Header::unsafe_arena_release_examples() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Header.examples)
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Header::_internal_mutable_examples() {
  
  if (_impl_.examples_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExamplesOrReferences>(GetArenaForAllocation());
    _impl_.examples_ = p;
  }
  return _impl_.examples_;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Header::mutable_examples() {
  ::gnostic::openapi::v3::ExamplesOrReferences* _msg = _internal_mutable_examples();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Header.examples)
  return _msg;
}
inline void Header::set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.examples_;
  }
  if (examples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(examples);
    if (message_arena != submessage_arena) {
      examples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, examples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.examples_ = examples;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Header.examples)
}

// .gnostic.openapi.v3.MediaTypes content = 11;
inline bool Header::_internal_has_content() const {
  return this != internal_default_instance() && _impl_.content_ != nullptr;
}
inline bool Header::has_content() const {
  return _internal_has_content();
}
inline void Header::clear_content() {
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
}
inline const ::gnostic::openapi::v3::MediaTypes& Header::_internal_content() const {
  const ::gnostic::openapi::v3::MediaTypes* p = _impl_.content_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::MediaTypes&>(
      ::gnostic::openapi::v3::_MediaTypes_default_instance_);
}
inline const ::gnostic::openapi::v3::MediaTypes& Header::content() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.content)
  return _internal_content();
}
inline void Header::unsafe_arena_set_allocated_content(
    ::gnostic::openapi::v3::MediaTypes* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
  }
  _impl_.content_ = content;
  if (content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Header.content)
}
inline ::gnostic::openapi::v3::MediaTypes* Header::release_content() {
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* Header::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Header.content)
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* Header::_internal_mutable_content() {
  
  if (_impl_.content_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::MediaTypes>(GetArenaForAllocation());
    _impl_.content_ = p;
  }
  return _impl_.content_;
}
inline ::gnostic::openapi::v3::MediaTypes* Header::mutable_content() {
  ::gnostic::openapi::v3::MediaTypes* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Header.content)
  return _msg;
}
inline void Header::set_allocated_content(::gnostic::openapi::v3::MediaTypes* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.content_ = content;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Header.content)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 12;
inline int Header::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Header::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Header::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Header::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Header.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Header::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Header.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Header::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Header::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Header.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Header::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Header::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Header.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Header::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Header.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// HeaderOrReference

// .gnostic.openapi.v3.Header header = 1;
inline bool HeaderOrReference::_internal_has_header() const {
  return oneof_case() == kHeader;
}
inline bool HeaderOrReference::has_header() const {
  return _internal_has_header();
}
inline void HeaderOrReference::set_has_header() {
  _impl_._oneof_case_[0] = kHeader;
}
inline void HeaderOrReference::clear_header() {
  if (_internal_has_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.header_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Header* HeaderOrReference::release_header() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.HeaderOrReference.header)
  if (_internal_has_header()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Header* temp = _impl_.oneof_.header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Header& HeaderOrReference::_internal_header() const {
  return _internal_has_header()
      ? *_impl_.oneof_.header_
      : reinterpret_cast< ::gnostic::openapi::v3::Header&>(::gnostic::openapi::v3::_Header_default_instance_);
}
inline const ::gnostic::openapi::v3::Header& HeaderOrReference::header() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.HeaderOrReference.header)
  return _internal_header();
}
inline ::gnostic::openapi::v3::Header* HeaderOrReference::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.HeaderOrReference.header)
  if (_internal_has_header()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Header* temp = _impl_.oneof_.header_;
    _impl_.oneof_.header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HeaderOrReference::unsafe_arena_set_allocated_header(::gnostic::openapi::v3::Header* header) {
  clear_oneof();
  if (header) {
    set_has_header();
    _impl_.oneof_.header_ = header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.HeaderOrReference.header)
}
inline ::gnostic::openapi::v3::Header* HeaderOrReference::_internal_mutable_header() {
  if (!_internal_has_header()) {
    clear_oneof();
    set_has_header();
    _impl_.oneof_.header_ = CreateMaybeMessage< ::gnostic::openapi::v3::Header >(GetArenaForAllocation());
  }
  return _impl_.oneof_.header_;
}
inline ::gnostic::openapi::v3::Header* HeaderOrReference::mutable_header() {
  ::gnostic::openapi::v3::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.HeaderOrReference.header)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool HeaderOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool HeaderOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void HeaderOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void HeaderOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* HeaderOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.HeaderOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& HeaderOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& HeaderOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.HeaderOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* HeaderOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.HeaderOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HeaderOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.HeaderOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* HeaderOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* HeaderOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.HeaderOrReference.reference)
  return _msg;
}

inline bool HeaderOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void HeaderOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline HeaderOrReference::OneofCase HeaderOrReference::oneof_case() const {
  return HeaderOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HeadersOrReferences

// repeated .gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1;
inline int HeadersOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int HeadersOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void HeadersOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedHeaderOrReference* HeadersOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.HeadersOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedHeaderOrReference >*
HeadersOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.HeadersOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedHeaderOrReference& HeadersOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedHeaderOrReference& HeadersOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.HeadersOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedHeaderOrReference* HeadersOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedHeaderOrReference* HeadersOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedHeaderOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.HeadersOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedHeaderOrReference >&
HeadersOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.HeadersOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Info

// string title = 1;
inline void Info::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Info::title() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Info.title)
}
inline std::string* Info::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.title)
  return _s;
}
inline const std::string& Info::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Info::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_title() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Info.title)
  return _impl_.title_.Release();
}
inline void Info::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Info.title)
}

// string description = 2;
inline void Info::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Info::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Info.description)
}
inline std::string* Info::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.description)
  return _s;
}
inline const std::string& Info::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Info::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Info.description)
  return _impl_.description_.Release();
}
inline void Info::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Info.description)
}

// string terms_of_service = 3;
inline void Info::clear_terms_of_service() {
  _impl_.terms_of_service_.ClearToEmpty();
}
inline const std::string& Info::terms_of_service() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.terms_of_service)
  return _internal_terms_of_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_terms_of_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.terms_of_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Info.terms_of_service)
}
inline std::string* Info::mutable_terms_of_service() {
  std::string* _s = _internal_mutable_terms_of_service();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.terms_of_service)
  return _s;
}
inline const std::string& Info::_internal_terms_of_service() const {
  return _impl_.terms_of_service_.Get();
}
inline void Info::_internal_set_terms_of_service(const std::string& value) {
  
  _impl_.terms_of_service_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_terms_of_service() {
  
  return _impl_.terms_of_service_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_terms_of_service() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Info.terms_of_service)
  return _impl_.terms_of_service_.Release();
}
inline void Info::set_allocated_terms_of_service(std::string* terms_of_service) {
  if (terms_of_service != nullptr) {
    
  } else {
    
  }
  _impl_.terms_of_service_.SetAllocated(terms_of_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.terms_of_service_.IsDefault()) {
    _impl_.terms_of_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Info.terms_of_service)
}

// .gnostic.openapi.v3.Contact contact = 4;
inline bool Info::_internal_has_contact() const {
  return this != internal_default_instance() && _impl_.contact_ != nullptr;
}
inline bool Info::has_contact() const {
  return _internal_has_contact();
}
inline void Info::clear_contact() {
  if (GetArenaForAllocation() == nullptr && _impl_.contact_ != nullptr) {
    delete _impl_.contact_;
  }
  _impl_.contact_ = nullptr;
}
inline const ::gnostic::openapi::v3::Contact& Info::_internal_contact() const {
  const ::gnostic::openapi::v3::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Contact&>(
      ::gnostic::openapi::v3::_Contact_default_instance_);
}
inline const ::gnostic::openapi::v3::Contact& Info::contact() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.contact)
  return _internal_contact();
}
inline void Info::unsafe_arena_set_allocated_contact(
    ::gnostic::openapi::v3::Contact* contact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = contact;
  if (contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Info.contact)
}
inline ::gnostic::openapi::v3::Contact* Info::release_contact() {
  
  ::gnostic::openapi::v3::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Contact* Info::unsafe_arena_release_contact() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Info.contact)
  
  ::gnostic::openapi::v3::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Contact* Info::_internal_mutable_contact() {
  
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Contact>(GetArenaForAllocation());
    _impl_.contact_ = p;
  }
  return _impl_.contact_;
}
inline ::gnostic::openapi::v3::Contact* Info::mutable_contact() {
  ::gnostic::openapi::v3::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.contact)
  return _msg;
}
inline void Info::set_allocated_contact(::gnostic::openapi::v3::Contact* contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contact_;
  }
  if (contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contact);
    if (message_arena != submessage_arena) {
      contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Info.contact)
}

// .gnostic.openapi.v3.License license = 5;
inline bool Info::_internal_has_license() const {
  return this != internal_default_instance() && _impl_.license_ != nullptr;
}
inline bool Info::has_license() const {
  return _internal_has_license();
}
inline void Info::clear_license() {
  if (GetArenaForAllocation() == nullptr && _impl_.license_ != nullptr) {
    delete _impl_.license_;
  }
  _impl_.license_ = nullptr;
}
inline const ::gnostic::openapi::v3::License& Info::_internal_license() const {
  const ::gnostic::openapi::v3::License* p = _impl_.license_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::License&>(
      ::gnostic::openapi::v3::_License_default_instance_);
}
inline const ::gnostic::openapi::v3::License& Info::license() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.license)
  return _internal_license();
}
inline void Info::unsafe_arena_set_allocated_license(
    ::gnostic::openapi::v3::License* license) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.license_);
  }
  _impl_.license_ = license;
  if (license) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Info.license)
}
inline ::gnostic::openapi::v3::License* Info::release_license() {
  
  ::gnostic::openapi::v3::License* temp = _impl_.license_;
  _impl_.license_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::License* Info::unsafe_arena_release_license() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Info.license)
  
  ::gnostic::openapi::v3::License* temp = _impl_.license_;
  _impl_.license_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::License* Info::_internal_mutable_license() {
  
  if (_impl_.license_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::License>(GetArenaForAllocation());
    _impl_.license_ = p;
  }
  return _impl_.license_;
}
inline ::gnostic::openapi::v3::License* Info::mutable_license() {
  ::gnostic::openapi::v3::License* _msg = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.license)
  return _msg;
}
inline void Info::set_allocated_license(::gnostic::openapi::v3::License* license) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.license_;
  }
  if (license) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(license);
    if (message_arena != submessage_arena) {
      license = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.license_ = license;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Info.license)
}

// string version = 6;
inline void Info::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Info::version() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Info.version)
}
inline std::string* Info::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.version)
  return _s;
}
inline const std::string& Info::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Info::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_version() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Info.version)
  return _impl_.version_.Release();
}
inline void Info::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Info.version)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
inline int Info::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Info::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Info::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Info::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Info::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Info.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Info::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Info::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Info::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Info::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Info.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Info::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Info.specification_extension)
  return _impl_.specification_extension_;
}

// string summary = 8;
inline void Info::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& Info::summary() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Info.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Info.summary)
}
inline std::string* Info::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Info.summary)
  return _s;
}
inline const std::string& Info::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void Info::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_summary() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Info.summary)
  return _impl_.summary_.Release();
}
inline void Info::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Info.summary)
}

// -------------------------------------------------------------------

// ItemsItem

// repeated .gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
inline int ItemsItem::_internal_schema_or_reference_size() const {
  return _impl_.schema_or_reference_.size();
}
inline int ItemsItem::schema_or_reference_size() const {
  return _internal_schema_or_reference_size();
}
inline void ItemsItem::clear_schema_or_reference() {
  _impl_.schema_or_reference_.Clear();
}
inline ::gnostic::openapi::v3::SchemaOrReference* ItemsItem::mutable_schema_or_reference(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ItemsItem.schema_or_reference)
  return _impl_.schema_or_reference_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
ItemsItem::mutable_schema_or_reference() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ItemsItem.schema_or_reference)
  return &_impl_.schema_or_reference_;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& ItemsItem::_internal_schema_or_reference(int index) const {
  return _impl_.schema_or_reference_.Get(index);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& ItemsItem::schema_or_reference(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ItemsItem.schema_or_reference)
  return _internal_schema_or_reference(index);
}
inline ::gnostic::openapi::v3::SchemaOrReference* ItemsItem::_internal_add_schema_or_reference() {
  return _impl_.schema_or_reference_.Add();
}
inline ::gnostic::openapi::v3::SchemaOrReference* ItemsItem::add_schema_or_reference() {
  ::gnostic::openapi::v3::SchemaOrReference* _add = _internal_add_schema_or_reference();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ItemsItem.schema_or_reference)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
ItemsItem::schema_or_reference() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ItemsItem.schema_or_reference)
  return _impl_.schema_or_reference_;
}

// -------------------------------------------------------------------

// License

// string name = 1;
inline void License::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& License::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.License.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void License::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.License.name)
}
inline std::string* License::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.License.name)
  return _s;
}
inline const std::string& License::_internal_name() const {
  return _impl_.name_.Get();
}
inline void License::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* License::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* License::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.License.name)
  return _impl_.name_.Release();
}
inline void License::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.License.name)
}

// string url = 2;
inline void License::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& License::url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.License.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void License::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.License.url)
}
inline std::string* License::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.License.url)
  return _s;
}
inline const std::string& License::_internal_url() const {
  return _impl_.url_.Get();
}
inline void License::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* License::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* License::release_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.License.url)
  return _impl_.url_.Release();
}
inline void License::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.License.url)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
inline int License::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int License::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void License::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* License::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.License.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
License::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.License.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& License::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& License::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.License.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* License::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* License::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.License.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
License::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.License.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Link

// string operation_ref = 1;
inline void Link::clear_operation_ref() {
  _impl_.operation_ref_.ClearToEmpty();
}
inline const std::string& Link::operation_ref() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Link.operation_ref)
  return _internal_operation_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_operation_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operation_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Link.operation_ref)
}
inline std::string* Link::mutable_operation_ref() {
  std::string* _s = _internal_mutable_operation_ref();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Link.operation_ref)
  return _s;
}
inline const std::string& Link::_internal_operation_ref() const {
  return _impl_.operation_ref_.Get();
}
inline void Link::_internal_set_operation_ref(const std::string& value) {
  
  _impl_.operation_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_operation_ref() {
  
  return _impl_.operation_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_operation_ref() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Link.operation_ref)
  return _impl_.operation_ref_.Release();
}
inline void Link::set_allocated_operation_ref(std::string* operation_ref) {
  if (operation_ref != nullptr) {
    
  } else {
    
  }
  _impl_.operation_ref_.SetAllocated(operation_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_ref_.IsDefault()) {
    _impl_.operation_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Link.operation_ref)
}

// string operation_id = 2;
inline void Link::clear_operation_id() {
  _impl_.operation_id_.ClearToEmpty();
}
inline const std::string& Link::operation_id() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Link.operation_id)
  return _internal_operation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_operation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Link.operation_id)
}
inline std::string* Link::mutable_operation_id() {
  std::string* _s = _internal_mutable_operation_id();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Link.operation_id)
  return _s;
}
inline const std::string& Link::_internal_operation_id() const {
  return _impl_.operation_id_.Get();
}
inline void Link::_internal_set_operation_id(const std::string& value) {
  
  _impl_.operation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_operation_id() {
  
  return _impl_.operation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_operation_id() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Link.operation_id)
  return _impl_.operation_id_.Release();
}
inline void Link::set_allocated_operation_id(std::string* operation_id) {
  if (operation_id != nullptr) {
    
  } else {
    
  }
  _impl_.operation_id_.SetAllocated(operation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_id_.IsDefault()) {
    _impl_.operation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Link.operation_id)
}

// .gnostic.openapi.v3.AnyOrExpression parameters = 3;
inline bool Link::_internal_has_parameters() const {
  return this != internal_default_instance() && _impl_.parameters_ != nullptr;
}
inline bool Link::has_parameters() const {
  return _internal_has_parameters();
}
inline void Link::clear_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.parameters_ != nullptr) {
    delete _impl_.parameters_;
  }
  _impl_.parameters_ = nullptr;
}
inline const ::gnostic::openapi::v3::AnyOrExpression& Link::_internal_parameters() const {
  const ::gnostic::openapi::v3::AnyOrExpression* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::AnyOrExpression&>(
      ::gnostic::openapi::v3::_AnyOrExpression_default_instance_);
}
inline const ::gnostic::openapi::v3::AnyOrExpression& Link::parameters() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Link.parameters)
  return _internal_parameters();
}
inline void Link::unsafe_arena_set_allocated_parameters(
    ::gnostic::openapi::v3::AnyOrExpression* parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = parameters;
  if (parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Link.parameters)
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::release_parameters() {
  
  ::gnostic::openapi::v3::AnyOrExpression* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Link.parameters)
  
  ::gnostic::openapi::v3::AnyOrExpression* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::_internal_mutable_parameters() {
  
  if (_impl_.parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::AnyOrExpression>(GetArenaForAllocation());
    _impl_.parameters_ = p;
  }
  return _impl_.parameters_;
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::mutable_parameters() {
  ::gnostic::openapi::v3::AnyOrExpression* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Link.parameters)
  return _msg;
}
inline void Link::set_allocated_parameters(::gnostic::openapi::v3::AnyOrExpression* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parameters_;
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parameters);
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Link.parameters)
}

// .gnostic.openapi.v3.AnyOrExpression request_body = 4;
inline bool Link::_internal_has_request_body() const {
  return this != internal_default_instance() && _impl_.request_body_ != nullptr;
}
inline bool Link::has_request_body() const {
  return _internal_has_request_body();
}
inline void Link::clear_request_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_body_ != nullptr) {
    delete _impl_.request_body_;
  }
  _impl_.request_body_ = nullptr;
}
inline const ::gnostic::openapi::v3::AnyOrExpression& Link::_internal_request_body() const {
  const ::gnostic::openapi::v3::AnyOrExpression* p = _impl_.request_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::AnyOrExpression&>(
      ::gnostic::openapi::v3::_AnyOrExpression_default_instance_);
}
inline const ::gnostic::openapi::v3::AnyOrExpression& Link::request_body() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Link.request_body)
  return _internal_request_body();
}
inline void Link::unsafe_arena_set_allocated_request_body(
    ::gnostic::openapi::v3::AnyOrExpression* request_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_body_);
  }
  _impl_.request_body_ = request_body;
  if (request_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Link.request_body)
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::release_request_body() {
  
  ::gnostic::openapi::v3::AnyOrExpression* temp = _impl_.request_body_;
  _impl_.request_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::unsafe_arena_release_request_body() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Link.request_body)
  
  ::gnostic::openapi::v3::AnyOrExpression* temp = _impl_.request_body_;
  _impl_.request_body_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::_internal_mutable_request_body() {
  
  if (_impl_.request_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::AnyOrExpression>(GetArenaForAllocation());
    _impl_.request_body_ = p;
  }
  return _impl_.request_body_;
}
inline ::gnostic::openapi::v3::AnyOrExpression* Link::mutable_request_body() {
  ::gnostic::openapi::v3::AnyOrExpression* _msg = _internal_mutable_request_body();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Link.request_body)
  return _msg;
}
inline void Link::set_allocated_request_body(::gnostic::openapi::v3::AnyOrExpression* request_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_body_;
  }
  if (request_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_body);
    if (message_arena != submessage_arena) {
      request_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_body_ = request_body;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Link.request_body)
}

// string description = 5;
inline void Link::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Link::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Link.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Link.description)
}
inline std::string* Link::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Link.description)
  return _s;
}
inline const std::string& Link::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Link::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Link.description)
  return _impl_.description_.Release();
}
inline void Link::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Link.description)
}

// .gnostic.openapi.v3.Server server = 6;
inline bool Link::_internal_has_server() const {
  return this != internal_default_instance() && _impl_.server_ != nullptr;
}
inline bool Link::has_server() const {
  return _internal_has_server();
}
inline void Link::clear_server() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_ != nullptr) {
    delete _impl_.server_;
  }
  _impl_.server_ = nullptr;
}
inline const ::gnostic::openapi::v3::Server& Link::_internal_server() const {
  const ::gnostic::openapi::v3::Server* p = _impl_.server_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Server&>(
      ::gnostic::openapi::v3::_Server_default_instance_);
}
inline const ::gnostic::openapi::v3::Server& Link::server() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Link.server)
  return _internal_server();
}
inline void Link::unsafe_arena_set_allocated_server(
    ::gnostic::openapi::v3::Server* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_);
  }
  _impl_.server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Link.server)
}
inline ::gnostic::openapi::v3::Server* Link::release_server() {
  
  ::gnostic::openapi::v3::Server* temp = _impl_.server_;
  _impl_.server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Server* Link::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Link.server)
  
  ::gnostic::openapi::v3::Server* temp = _impl_.server_;
  _impl_.server_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Server* Link::_internal_mutable_server() {
  
  if (_impl_.server_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Server>(GetArenaForAllocation());
    _impl_.server_ = p;
  }
  return _impl_.server_;
}
inline ::gnostic::openapi::v3::Server* Link::mutable_server() {
  ::gnostic::openapi::v3::Server* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Link.server)
  return _msg;
}
inline void Link::set_allocated_server(::gnostic::openapi::v3::Server* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_ = server;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Link.server)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 7;
inline int Link::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Link::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Link::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Link::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Link.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Link::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Link.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Link::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Link::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Link.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Link::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Link::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Link.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Link::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Link.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// LinkOrReference

// .gnostic.openapi.v3.Link link = 1;
inline bool LinkOrReference::_internal_has_link() const {
  return oneof_case() == kLink;
}
inline bool LinkOrReference::has_link() const {
  return _internal_has_link();
}
inline void LinkOrReference::set_has_link() {
  _impl_._oneof_case_[0] = kLink;
}
inline void LinkOrReference::clear_link() {
  if (_internal_has_link()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.link_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Link* LinkOrReference::release_link() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.LinkOrReference.link)
  if (_internal_has_link()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Link* temp = _impl_.oneof_.link_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Link& LinkOrReference::_internal_link() const {
  return _internal_has_link()
      ? *_impl_.oneof_.link_
      : reinterpret_cast< ::gnostic::openapi::v3::Link&>(::gnostic::openapi::v3::_Link_default_instance_);
}
inline const ::gnostic::openapi::v3::Link& LinkOrReference::link() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.LinkOrReference.link)
  return _internal_link();
}
inline ::gnostic::openapi::v3::Link* LinkOrReference::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.LinkOrReference.link)
  if (_internal_has_link()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Link* temp = _impl_.oneof_.link_;
    _impl_.oneof_.link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LinkOrReference::unsafe_arena_set_allocated_link(::gnostic::openapi::v3::Link* link) {
  clear_oneof();
  if (link) {
    set_has_link();
    _impl_.oneof_.link_ = link;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.LinkOrReference.link)
}
inline ::gnostic::openapi::v3::Link* LinkOrReference::_internal_mutable_link() {
  if (!_internal_has_link()) {
    clear_oneof();
    set_has_link();
    _impl_.oneof_.link_ = CreateMaybeMessage< ::gnostic::openapi::v3::Link >(GetArenaForAllocation());
  }
  return _impl_.oneof_.link_;
}
inline ::gnostic::openapi::v3::Link* LinkOrReference::mutable_link() {
  ::gnostic::openapi::v3::Link* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.LinkOrReference.link)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool LinkOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool LinkOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void LinkOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void LinkOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* LinkOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.LinkOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& LinkOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& LinkOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.LinkOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* LinkOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.LinkOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LinkOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.LinkOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* LinkOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* LinkOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.LinkOrReference.reference)
  return _msg;
}

inline bool LinkOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void LinkOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline LinkOrReference::OneofCase LinkOrReference::oneof_case() const {
  return LinkOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinksOrReferences

// repeated .gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1;
inline int LinksOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int LinksOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void LinksOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedLinkOrReference* LinksOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.LinksOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedLinkOrReference >*
LinksOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.LinksOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedLinkOrReference& LinksOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedLinkOrReference& LinksOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.LinksOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedLinkOrReference* LinksOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedLinkOrReference* LinksOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedLinkOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.LinksOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedLinkOrReference >&
LinksOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.LinksOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// MediaType

// .gnostic.openapi.v3.SchemaOrReference schema = 1;
inline bool MediaType::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool MediaType::has_schema() const {
  return _internal_has_schema();
}
inline void MediaType::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& MediaType::_internal_schema() const {
  const ::gnostic::openapi::v3::SchemaOrReference* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::SchemaOrReference&>(
      ::gnostic::openapi::v3::_SchemaOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& MediaType::schema() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.MediaType.schema)
  return _internal_schema();
}
inline void MediaType::unsafe_arena_set_allocated_schema(
    ::gnostic::openapi::v3::SchemaOrReference* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.MediaType.schema)
}
inline ::gnostic::openapi::v3::SchemaOrReference* MediaType::release_schema() {
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* MediaType::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.MediaType.schema)
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* MediaType::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::SchemaOrReference>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::gnostic::openapi::v3::SchemaOrReference* MediaType::mutable_schema() {
  ::gnostic::openapi::v3::SchemaOrReference* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.MediaType.schema)
  return _msg;
}
inline void MediaType::set_allocated_schema(::gnostic::openapi::v3::SchemaOrReference* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.MediaType.schema)
}

// .gnostic.openapi.v3.Any example = 2;
inline bool MediaType::_internal_has_example() const {
  return this != internal_default_instance() && _impl_.example_ != nullptr;
}
inline bool MediaType::has_example() const {
  return _internal_has_example();
}
inline void MediaType::clear_example() {
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
}
inline const ::gnostic::openapi::v3::Any& MediaType::_internal_example() const {
  const ::gnostic::openapi::v3::Any* p = _impl_.example_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Any&>(
      ::gnostic::openapi::v3::_Any_default_instance_);
}
inline const ::gnostic::openapi::v3::Any& MediaType::example() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.MediaType.example)
  return _internal_example();
}
inline void MediaType::unsafe_arena_set_allocated_example(
    ::gnostic::openapi::v3::Any* example) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.example_);
  }
  _impl_.example_ = example;
  if (example) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.MediaType.example)
}
inline ::gnostic::openapi::v3::Any* MediaType::release_example() {
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Any* MediaType::unsafe_arena_release_example() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.MediaType.example)
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Any* MediaType::_internal_mutable_example() {
  
  if (_impl_.example_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Any>(GetArenaForAllocation());
    _impl_.example_ = p;
  }
  return _impl_.example_;
}
inline ::gnostic::openapi::v3::Any* MediaType::mutable_example() {
  ::gnostic::openapi::v3::Any* _msg = _internal_mutable_example();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.MediaType.example)
  return _msg;
}
inline void MediaType::set_allocated_example(::gnostic::openapi::v3::Any* example) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.example_;
  }
  if (example) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(example);
    if (message_arena != submessage_arena) {
      example = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.example_ = example;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.MediaType.example)
}

// .gnostic.openapi.v3.ExamplesOrReferences examples = 3;
inline bool MediaType::_internal_has_examples() const {
  return this != internal_default_instance() && _impl_.examples_ != nullptr;
}
inline bool MediaType::has_examples() const {
  return _internal_has_examples();
}
inline void MediaType::clear_examples() {
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& MediaType::_internal_examples() const {
  const ::gnostic::openapi::v3::ExamplesOrReferences* p = _impl_.examples_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExamplesOrReferences&>(
      ::gnostic::openapi::v3::_ExamplesOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& MediaType::examples() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.MediaType.examples)
  return _internal_examples();
}
inline void MediaType::unsafe_arena_set_allocated_examples(
    ::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.examples_);
  }
  _impl_.examples_ = examples;
  if (examples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.MediaType.examples)
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* MediaType::release_examples() {
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* MediaType::unsafe_arena_release_examples() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.MediaType.examples)
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* MediaType::_internal_mutable_examples() {
  
  if (_impl_.examples_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExamplesOrReferences>(GetArenaForAllocation());
    _impl_.examples_ = p;
  }
  return _impl_.examples_;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* MediaType::mutable_examples() {
  ::gnostic::openapi::v3::ExamplesOrReferences* _msg = _internal_mutable_examples();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.MediaType.examples)
  return _msg;
}
inline void MediaType::set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.examples_;
  }
  if (examples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(examples);
    if (message_arena != submessage_arena) {
      examples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, examples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.examples_ = examples;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.MediaType.examples)
}

// .gnostic.openapi.v3.Encodings encoding = 4;
inline bool MediaType::_internal_has_encoding() const {
  return this != internal_default_instance() && _impl_.encoding_ != nullptr;
}
inline bool MediaType::has_encoding() const {
  return _internal_has_encoding();
}
inline void MediaType::clear_encoding() {
  if (GetArenaForAllocation() == nullptr && _impl_.encoding_ != nullptr) {
    delete _impl_.encoding_;
  }
  _impl_.encoding_ = nullptr;
}
inline const ::gnostic::openapi::v3::Encodings& MediaType::_internal_encoding() const {
  const ::gnostic::openapi::v3::Encodings* p = _impl_.encoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Encodings&>(
      ::gnostic::openapi::v3::_Encodings_default_instance_);
}
inline const ::gnostic::openapi::v3::Encodings& MediaType::encoding() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.MediaType.encoding)
  return _internal_encoding();
}
inline void MediaType::unsafe_arena_set_allocated_encoding(
    ::gnostic::openapi::v3::Encodings* encoding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encoding_);
  }
  _impl_.encoding_ = encoding;
  if (encoding) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.MediaType.encoding)
}
inline ::gnostic::openapi::v3::Encodings* MediaType::release_encoding() {
  
  ::gnostic::openapi::v3::Encodings* temp = _impl_.encoding_;
  _impl_.encoding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Encodings* MediaType::unsafe_arena_release_encoding() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.MediaType.encoding)
  
  ::gnostic::openapi::v3::Encodings* temp = _impl_.encoding_;
  _impl_.encoding_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Encodings* MediaType::_internal_mutable_encoding() {
  
  if (_impl_.encoding_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Encodings>(GetArenaForAllocation());
    _impl_.encoding_ = p;
  }
  return _impl_.encoding_;
}
inline ::gnostic::openapi::v3::Encodings* MediaType::mutable_encoding() {
  ::gnostic::openapi::v3::Encodings* _msg = _internal_mutable_encoding();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.MediaType.encoding)
  return _msg;
}
inline void MediaType::set_allocated_encoding(::gnostic::openapi::v3::Encodings* encoding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.encoding_;
  }
  if (encoding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encoding);
    if (message_arena != submessage_arena) {
      encoding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encoding, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.encoding_ = encoding;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.MediaType.encoding)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
inline int MediaType::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int MediaType::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void MediaType::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* MediaType::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.MediaType.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
MediaType::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.MediaType.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& MediaType::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& MediaType::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.MediaType.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* MediaType::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* MediaType::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.MediaType.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
MediaType::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.MediaType.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// MediaTypes

// repeated .gnostic.openapi.v3.NamedMediaType additional_properties = 1;
inline int MediaTypes::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int MediaTypes::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void MediaTypes::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedMediaType* MediaTypes::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.MediaTypes.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedMediaType >*
MediaTypes::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.MediaTypes.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedMediaType& MediaTypes::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedMediaType& MediaTypes::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.MediaTypes.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedMediaType* MediaTypes::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedMediaType* MediaTypes::add_additional_properties() {
  ::gnostic::openapi::v3::NamedMediaType* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.MediaTypes.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedMediaType >&
MediaTypes::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.MediaTypes.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// NamedAny

// string name = 1;
inline void NamedAny::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedAny::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedAny.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedAny::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedAny.name)
}
inline std::string* NamedAny::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedAny.name)
  return _s;
}
inline const std::string& NamedAny::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedAny::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedAny::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedAny::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedAny.name)
  return _impl_.name_.Release();
}
inline void NamedAny::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedAny.name)
}

// .gnostic.openapi.v3.Any value = 2;
inline bool NamedAny::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedAny::has_value() const {
  return _internal_has_value();
}
inline void NamedAny::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::Any& NamedAny::_internal_value() const {
  const ::gnostic::openapi::v3::Any* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Any&>(
      ::gnostic::openapi::v3::_Any_default_instance_);
}
inline const ::gnostic::openapi::v3::Any& NamedAny::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedAny.value)
  return _internal_value();
}
inline void NamedAny::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::Any* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedAny.value)
}
inline ::gnostic::openapi::v3::Any* NamedAny::release_value() {
  
  ::gnostic::openapi::v3::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Any* NamedAny::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedAny.value)
  
  ::gnostic::openapi::v3::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Any* NamedAny::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Any>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::Any* NamedAny::mutable_value() {
  ::gnostic::openapi::v3::Any* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedAny.value)
  return _msg;
}
inline void NamedAny::set_allocated_value(::gnostic::openapi::v3::Any* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedAny.value)
}

// -------------------------------------------------------------------

// NamedCallbackOrReference

// string name = 1;
inline void NamedCallbackOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedCallbackOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedCallbackOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedCallbackOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedCallbackOrReference.name)
}
inline std::string* NamedCallbackOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedCallbackOrReference.name)
  return _s;
}
inline const std::string& NamedCallbackOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedCallbackOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedCallbackOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedCallbackOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedCallbackOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedCallbackOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedCallbackOrReference.name)
}

// .gnostic.openapi.v3.CallbackOrReference value = 2;
inline bool NamedCallbackOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedCallbackOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedCallbackOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::CallbackOrReference& NamedCallbackOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::CallbackOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::CallbackOrReference&>(
      ::gnostic::openapi::v3::_CallbackOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::CallbackOrReference& NamedCallbackOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedCallbackOrReference.value)
  return _internal_value();
}
inline void NamedCallbackOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::CallbackOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedCallbackOrReference.value)
}
inline ::gnostic::openapi::v3::CallbackOrReference* NamedCallbackOrReference::release_value() {
  
  ::gnostic::openapi::v3::CallbackOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::CallbackOrReference* NamedCallbackOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedCallbackOrReference.value)
  
  ::gnostic::openapi::v3::CallbackOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::CallbackOrReference* NamedCallbackOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::CallbackOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::CallbackOrReference* NamedCallbackOrReference::mutable_value() {
  ::gnostic::openapi::v3::CallbackOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedCallbackOrReference.value)
  return _msg;
}
inline void NamedCallbackOrReference::set_allocated_value(::gnostic::openapi::v3::CallbackOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedCallbackOrReference.value)
}

// -------------------------------------------------------------------

// NamedEncoding

// string name = 1;
inline void NamedEncoding::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedEncoding::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedEncoding.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedEncoding::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedEncoding.name)
}
inline std::string* NamedEncoding::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedEncoding.name)
  return _s;
}
inline const std::string& NamedEncoding::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedEncoding::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedEncoding::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedEncoding::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedEncoding.name)
  return _impl_.name_.Release();
}
inline void NamedEncoding::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedEncoding.name)
}

// .gnostic.openapi.v3.Encoding value = 2;
inline bool NamedEncoding::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedEncoding::has_value() const {
  return _internal_has_value();
}
inline void NamedEncoding::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::Encoding& NamedEncoding::_internal_value() const {
  const ::gnostic::openapi::v3::Encoding* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Encoding&>(
      ::gnostic::openapi::v3::_Encoding_default_instance_);
}
inline const ::gnostic::openapi::v3::Encoding& NamedEncoding::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedEncoding.value)
  return _internal_value();
}
inline void NamedEncoding::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::Encoding* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedEncoding.value)
}
inline ::gnostic::openapi::v3::Encoding* NamedEncoding::release_value() {
  
  ::gnostic::openapi::v3::Encoding* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Encoding* NamedEncoding::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedEncoding.value)
  
  ::gnostic::openapi::v3::Encoding* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Encoding* NamedEncoding::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Encoding>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::Encoding* NamedEncoding::mutable_value() {
  ::gnostic::openapi::v3::Encoding* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedEncoding.value)
  return _msg;
}
inline void NamedEncoding::set_allocated_value(::gnostic::openapi::v3::Encoding* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedEncoding.value)
}

// -------------------------------------------------------------------

// NamedExampleOrReference

// string name = 1;
inline void NamedExampleOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedExampleOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedExampleOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedExampleOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedExampleOrReference.name)
}
inline std::string* NamedExampleOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedExampleOrReference.name)
  return _s;
}
inline const std::string& NamedExampleOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedExampleOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedExampleOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedExampleOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedExampleOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedExampleOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedExampleOrReference.name)
}

// .gnostic.openapi.v3.ExampleOrReference value = 2;
inline bool NamedExampleOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedExampleOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedExampleOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExampleOrReference& NamedExampleOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::ExampleOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExampleOrReference&>(
      ::gnostic::openapi::v3::_ExampleOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::ExampleOrReference& NamedExampleOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedExampleOrReference.value)
  return _internal_value();
}
inline void NamedExampleOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::ExampleOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedExampleOrReference.value)
}
inline ::gnostic::openapi::v3::ExampleOrReference* NamedExampleOrReference::release_value() {
  
  ::gnostic::openapi::v3::ExampleOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExampleOrReference* NamedExampleOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedExampleOrReference.value)
  
  ::gnostic::openapi::v3::ExampleOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExampleOrReference* NamedExampleOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExampleOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::ExampleOrReference* NamedExampleOrReference::mutable_value() {
  ::gnostic::openapi::v3::ExampleOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedExampleOrReference.value)
  return _msg;
}
inline void NamedExampleOrReference::set_allocated_value(::gnostic::openapi::v3::ExampleOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedExampleOrReference.value)
}

// -------------------------------------------------------------------

// NamedHeaderOrReference

// string name = 1;
inline void NamedHeaderOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedHeaderOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedHeaderOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedHeaderOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedHeaderOrReference.name)
}
inline std::string* NamedHeaderOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedHeaderOrReference.name)
  return _s;
}
inline const std::string& NamedHeaderOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedHeaderOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedHeaderOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedHeaderOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedHeaderOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedHeaderOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedHeaderOrReference.name)
}

// .gnostic.openapi.v3.HeaderOrReference value = 2;
inline bool NamedHeaderOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedHeaderOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedHeaderOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::HeaderOrReference& NamedHeaderOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::HeaderOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::HeaderOrReference&>(
      ::gnostic::openapi::v3::_HeaderOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::HeaderOrReference& NamedHeaderOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedHeaderOrReference.value)
  return _internal_value();
}
inline void NamedHeaderOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::HeaderOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedHeaderOrReference.value)
}
inline ::gnostic::openapi::v3::HeaderOrReference* NamedHeaderOrReference::release_value() {
  
  ::gnostic::openapi::v3::HeaderOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::HeaderOrReference* NamedHeaderOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedHeaderOrReference.value)
  
  ::gnostic::openapi::v3::HeaderOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::HeaderOrReference* NamedHeaderOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::HeaderOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::HeaderOrReference* NamedHeaderOrReference::mutable_value() {
  ::gnostic::openapi::v3::HeaderOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedHeaderOrReference.value)
  return _msg;
}
inline void NamedHeaderOrReference::set_allocated_value(::gnostic::openapi::v3::HeaderOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedHeaderOrReference.value)
}

// -------------------------------------------------------------------

// NamedLinkOrReference

// string name = 1;
inline void NamedLinkOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedLinkOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedLinkOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedLinkOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedLinkOrReference.name)
}
inline std::string* NamedLinkOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedLinkOrReference.name)
  return _s;
}
inline const std::string& NamedLinkOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedLinkOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedLinkOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedLinkOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedLinkOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedLinkOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedLinkOrReference.name)
}

// .gnostic.openapi.v3.LinkOrReference value = 2;
inline bool NamedLinkOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedLinkOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedLinkOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::LinkOrReference& NamedLinkOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::LinkOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::LinkOrReference&>(
      ::gnostic::openapi::v3::_LinkOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::LinkOrReference& NamedLinkOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedLinkOrReference.value)
  return _internal_value();
}
inline void NamedLinkOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::LinkOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedLinkOrReference.value)
}
inline ::gnostic::openapi::v3::LinkOrReference* NamedLinkOrReference::release_value() {
  
  ::gnostic::openapi::v3::LinkOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::LinkOrReference* NamedLinkOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedLinkOrReference.value)
  
  ::gnostic::openapi::v3::LinkOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::LinkOrReference* NamedLinkOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::LinkOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::LinkOrReference* NamedLinkOrReference::mutable_value() {
  ::gnostic::openapi::v3::LinkOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedLinkOrReference.value)
  return _msg;
}
inline void NamedLinkOrReference::set_allocated_value(::gnostic::openapi::v3::LinkOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedLinkOrReference.value)
}

// -------------------------------------------------------------------

// NamedMediaType

// string name = 1;
inline void NamedMediaType::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedMediaType::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedMediaType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedMediaType::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedMediaType.name)
}
inline std::string* NamedMediaType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedMediaType.name)
  return _s;
}
inline const std::string& NamedMediaType::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedMediaType::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedMediaType::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedMediaType::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedMediaType.name)
  return _impl_.name_.Release();
}
inline void NamedMediaType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedMediaType.name)
}

// .gnostic.openapi.v3.MediaType value = 2;
inline bool NamedMediaType::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedMediaType::has_value() const {
  return _internal_has_value();
}
inline void NamedMediaType::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::MediaType& NamedMediaType::_internal_value() const {
  const ::gnostic::openapi::v3::MediaType* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::MediaType&>(
      ::gnostic::openapi::v3::_MediaType_default_instance_);
}
inline const ::gnostic::openapi::v3::MediaType& NamedMediaType::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedMediaType.value)
  return _internal_value();
}
inline void NamedMediaType::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::MediaType* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedMediaType.value)
}
inline ::gnostic::openapi::v3::MediaType* NamedMediaType::release_value() {
  
  ::gnostic::openapi::v3::MediaType* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::MediaType* NamedMediaType::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedMediaType.value)
  
  ::gnostic::openapi::v3::MediaType* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::MediaType* NamedMediaType::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::MediaType>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::MediaType* NamedMediaType::mutable_value() {
  ::gnostic::openapi::v3::MediaType* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedMediaType.value)
  return _msg;
}
inline void NamedMediaType::set_allocated_value(::gnostic::openapi::v3::MediaType* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedMediaType.value)
}

// -------------------------------------------------------------------

// NamedParameterOrReference

// string name = 1;
inline void NamedParameterOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedParameterOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedParameterOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedParameterOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedParameterOrReference.name)
}
inline std::string* NamedParameterOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedParameterOrReference.name)
  return _s;
}
inline const std::string& NamedParameterOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedParameterOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedParameterOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedParameterOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedParameterOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedParameterOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedParameterOrReference.name)
}

// .gnostic.openapi.v3.ParameterOrReference value = 2;
inline bool NamedParameterOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedParameterOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedParameterOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::ParameterOrReference& NamedParameterOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::ParameterOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ParameterOrReference&>(
      ::gnostic::openapi::v3::_ParameterOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::ParameterOrReference& NamedParameterOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedParameterOrReference.value)
  return _internal_value();
}
inline void NamedParameterOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::ParameterOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedParameterOrReference.value)
}
inline ::gnostic::openapi::v3::ParameterOrReference* NamedParameterOrReference::release_value() {
  
  ::gnostic::openapi::v3::ParameterOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ParameterOrReference* NamedParameterOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedParameterOrReference.value)
  
  ::gnostic::openapi::v3::ParameterOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ParameterOrReference* NamedParameterOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ParameterOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::ParameterOrReference* NamedParameterOrReference::mutable_value() {
  ::gnostic::openapi::v3::ParameterOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedParameterOrReference.value)
  return _msg;
}
inline void NamedParameterOrReference::set_allocated_value(::gnostic::openapi::v3::ParameterOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedParameterOrReference.value)
}

// -------------------------------------------------------------------

// NamedPathItem

// string name = 1;
inline void NamedPathItem::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedPathItem::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedPathItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedPathItem::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedPathItem.name)
}
inline std::string* NamedPathItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedPathItem.name)
  return _s;
}
inline const std::string& NamedPathItem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedPathItem::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedPathItem::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedPathItem::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedPathItem.name)
  return _impl_.name_.Release();
}
inline void NamedPathItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedPathItem.name)
}

// .gnostic.openapi.v3.PathItem value = 2;
inline bool NamedPathItem::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedPathItem::has_value() const {
  return _internal_has_value();
}
inline void NamedPathItem::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::PathItem& NamedPathItem::_internal_value() const {
  const ::gnostic::openapi::v3::PathItem* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::PathItem&>(
      ::gnostic::openapi::v3::_PathItem_default_instance_);
}
inline const ::gnostic::openapi::v3::PathItem& NamedPathItem::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedPathItem.value)
  return _internal_value();
}
inline void NamedPathItem::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::PathItem* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedPathItem.value)
}
inline ::gnostic::openapi::v3::PathItem* NamedPathItem::release_value() {
  
  ::gnostic::openapi::v3::PathItem* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::PathItem* NamedPathItem::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedPathItem.value)
  
  ::gnostic::openapi::v3::PathItem* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::PathItem* NamedPathItem::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::PathItem>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::PathItem* NamedPathItem::mutable_value() {
  ::gnostic::openapi::v3::PathItem* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedPathItem.value)
  return _msg;
}
inline void NamedPathItem::set_allocated_value(::gnostic::openapi::v3::PathItem* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedPathItem.value)
}

// -------------------------------------------------------------------

// NamedRequestBodyOrReference

// string name = 1;
inline void NamedRequestBodyOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedRequestBodyOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedRequestBodyOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedRequestBodyOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedRequestBodyOrReference.name)
}
inline std::string* NamedRequestBodyOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedRequestBodyOrReference.name)
  return _s;
}
inline const std::string& NamedRequestBodyOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedRequestBodyOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedRequestBodyOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedRequestBodyOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedRequestBodyOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedRequestBodyOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedRequestBodyOrReference.name)
}

// .gnostic.openapi.v3.RequestBodyOrReference value = 2;
inline bool NamedRequestBodyOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedRequestBodyOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedRequestBodyOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::RequestBodyOrReference& NamedRequestBodyOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::RequestBodyOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::RequestBodyOrReference&>(
      ::gnostic::openapi::v3::_RequestBodyOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::RequestBodyOrReference& NamedRequestBodyOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedRequestBodyOrReference.value)
  return _internal_value();
}
inline void NamedRequestBodyOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::RequestBodyOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedRequestBodyOrReference.value)
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* NamedRequestBodyOrReference::release_value() {
  
  ::gnostic::openapi::v3::RequestBodyOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* NamedRequestBodyOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedRequestBodyOrReference.value)
  
  ::gnostic::openapi::v3::RequestBodyOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* NamedRequestBodyOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::RequestBodyOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* NamedRequestBodyOrReference::mutable_value() {
  ::gnostic::openapi::v3::RequestBodyOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedRequestBodyOrReference.value)
  return _msg;
}
inline void NamedRequestBodyOrReference::set_allocated_value(::gnostic::openapi::v3::RequestBodyOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedRequestBodyOrReference.value)
}

// -------------------------------------------------------------------

// NamedResponseOrReference

// string name = 1;
inline void NamedResponseOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedResponseOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedResponseOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedResponseOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedResponseOrReference.name)
}
inline std::string* NamedResponseOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedResponseOrReference.name)
  return _s;
}
inline const std::string& NamedResponseOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedResponseOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedResponseOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedResponseOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedResponseOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedResponseOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedResponseOrReference.name)
}

// .gnostic.openapi.v3.ResponseOrReference value = 2;
inline bool NamedResponseOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedResponseOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedResponseOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::ResponseOrReference& NamedResponseOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::ResponseOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ResponseOrReference&>(
      ::gnostic::openapi::v3::_ResponseOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::ResponseOrReference& NamedResponseOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedResponseOrReference.value)
  return _internal_value();
}
inline void NamedResponseOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::ResponseOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedResponseOrReference.value)
}
inline ::gnostic::openapi::v3::ResponseOrReference* NamedResponseOrReference::release_value() {
  
  ::gnostic::openapi::v3::ResponseOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ResponseOrReference* NamedResponseOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedResponseOrReference.value)
  
  ::gnostic::openapi::v3::ResponseOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ResponseOrReference* NamedResponseOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ResponseOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::ResponseOrReference* NamedResponseOrReference::mutable_value() {
  ::gnostic::openapi::v3::ResponseOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedResponseOrReference.value)
  return _msg;
}
inline void NamedResponseOrReference::set_allocated_value(::gnostic::openapi::v3::ResponseOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedResponseOrReference.value)
}

// -------------------------------------------------------------------

// NamedSchemaOrReference

// string name = 1;
inline void NamedSchemaOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedSchemaOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedSchemaOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedSchemaOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedSchemaOrReference.name)
}
inline std::string* NamedSchemaOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedSchemaOrReference.name)
  return _s;
}
inline const std::string& NamedSchemaOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedSchemaOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedSchemaOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedSchemaOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedSchemaOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedSchemaOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedSchemaOrReference.name)
}

// .gnostic.openapi.v3.SchemaOrReference value = 2;
inline bool NamedSchemaOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedSchemaOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedSchemaOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& NamedSchemaOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::SchemaOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::SchemaOrReference&>(
      ::gnostic::openapi::v3::_SchemaOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& NamedSchemaOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedSchemaOrReference.value)
  return _internal_value();
}
inline void NamedSchemaOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::SchemaOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedSchemaOrReference.value)
}
inline ::gnostic::openapi::v3::SchemaOrReference* NamedSchemaOrReference::release_value() {
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* NamedSchemaOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedSchemaOrReference.value)
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* NamedSchemaOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::SchemaOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::SchemaOrReference* NamedSchemaOrReference::mutable_value() {
  ::gnostic::openapi::v3::SchemaOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedSchemaOrReference.value)
  return _msg;
}
inline void NamedSchemaOrReference::set_allocated_value(::gnostic::openapi::v3::SchemaOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedSchemaOrReference.value)
}

// -------------------------------------------------------------------

// NamedSecuritySchemeOrReference

// string name = 1;
inline void NamedSecuritySchemeOrReference::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedSecuritySchemeOrReference::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedSecuritySchemeOrReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedSecuritySchemeOrReference::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedSecuritySchemeOrReference.name)
}
inline std::string* NamedSecuritySchemeOrReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedSecuritySchemeOrReference.name)
  return _s;
}
inline const std::string& NamedSecuritySchemeOrReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedSecuritySchemeOrReference::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedSecuritySchemeOrReference::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedSecuritySchemeOrReference::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedSecuritySchemeOrReference.name)
  return _impl_.name_.Release();
}
inline void NamedSecuritySchemeOrReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedSecuritySchemeOrReference.name)
}

// .gnostic.openapi.v3.SecuritySchemeOrReference value = 2;
inline bool NamedSecuritySchemeOrReference::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedSecuritySchemeOrReference::has_value() const {
  return _internal_has_value();
}
inline void NamedSecuritySchemeOrReference::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::SecuritySchemeOrReference& NamedSecuritySchemeOrReference::_internal_value() const {
  const ::gnostic::openapi::v3::SecuritySchemeOrReference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::SecuritySchemeOrReference&>(
      ::gnostic::openapi::v3::_SecuritySchemeOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::SecuritySchemeOrReference& NamedSecuritySchemeOrReference::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedSecuritySchemeOrReference.value)
  return _internal_value();
}
inline void NamedSecuritySchemeOrReference::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::SecuritySchemeOrReference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedSecuritySchemeOrReference.value)
}
inline ::gnostic::openapi::v3::SecuritySchemeOrReference* NamedSecuritySchemeOrReference::release_value() {
  
  ::gnostic::openapi::v3::SecuritySchemeOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::SecuritySchemeOrReference* NamedSecuritySchemeOrReference::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedSecuritySchemeOrReference.value)
  
  ::gnostic::openapi::v3::SecuritySchemeOrReference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::SecuritySchemeOrReference* NamedSecuritySchemeOrReference::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::SecuritySchemeOrReference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::SecuritySchemeOrReference* NamedSecuritySchemeOrReference::mutable_value() {
  ::gnostic::openapi::v3::SecuritySchemeOrReference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedSecuritySchemeOrReference.value)
  return _msg;
}
inline void NamedSecuritySchemeOrReference::set_allocated_value(::gnostic::openapi::v3::SecuritySchemeOrReference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedSecuritySchemeOrReference.value)
}

// -------------------------------------------------------------------

// NamedServerVariable

// string name = 1;
inline void NamedServerVariable::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedServerVariable::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedServerVariable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedServerVariable::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedServerVariable.name)
}
inline std::string* NamedServerVariable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedServerVariable.name)
  return _s;
}
inline const std::string& NamedServerVariable::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedServerVariable::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedServerVariable::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedServerVariable::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedServerVariable.name)
  return _impl_.name_.Release();
}
inline void NamedServerVariable::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedServerVariable.name)
}

// .gnostic.openapi.v3.ServerVariable value = 2;
inline bool NamedServerVariable::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedServerVariable::has_value() const {
  return _internal_has_value();
}
inline void NamedServerVariable::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::ServerVariable& NamedServerVariable::_internal_value() const {
  const ::gnostic::openapi::v3::ServerVariable* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ServerVariable&>(
      ::gnostic::openapi::v3::_ServerVariable_default_instance_);
}
inline const ::gnostic::openapi::v3::ServerVariable& NamedServerVariable::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedServerVariable.value)
  return _internal_value();
}
inline void NamedServerVariable::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::ServerVariable* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedServerVariable.value)
}
inline ::gnostic::openapi::v3::ServerVariable* NamedServerVariable::release_value() {
  
  ::gnostic::openapi::v3::ServerVariable* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ServerVariable* NamedServerVariable::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedServerVariable.value)
  
  ::gnostic::openapi::v3::ServerVariable* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ServerVariable* NamedServerVariable::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ServerVariable>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::ServerVariable* NamedServerVariable::mutable_value() {
  ::gnostic::openapi::v3::ServerVariable* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedServerVariable.value)
  return _msg;
}
inline void NamedServerVariable::set_allocated_value(::gnostic::openapi::v3::ServerVariable* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedServerVariable.value)
}

// -------------------------------------------------------------------

// NamedString

// string name = 1;
inline void NamedString::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedString::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedString.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedString::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedString.name)
}
inline std::string* NamedString::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedString.name)
  return _s;
}
inline const std::string& NamedString::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedString::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedString::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedString::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedString.name)
  return _impl_.name_.Release();
}
inline void NamedString::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedString.name)
}

// string value = 2;
inline void NamedString::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& NamedString::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedString.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedString::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedString.value)
}
inline std::string* NamedString::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedString.value)
  return _s;
}
inline const std::string& NamedString::_internal_value() const {
  return _impl_.value_.Get();
}
inline void NamedString::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedString::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedString::release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedString.value)
  return _impl_.value_.Release();
}
inline void NamedString::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedString.value)
}

// -------------------------------------------------------------------

// NamedStringArray

// string name = 1;
inline void NamedStringArray::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedStringArray::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedStringArray.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedStringArray::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.NamedStringArray.name)
}
inline std::string* NamedStringArray::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedStringArray.name)
  return _s;
}
inline const std::string& NamedStringArray::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamedStringArray::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedStringArray::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedStringArray::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedStringArray.name)
  return _impl_.name_.Release();
}
inline void NamedStringArray::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedStringArray.name)
}

// .gnostic.openapi.v3.StringArray value = 2;
inline bool NamedStringArray::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool NamedStringArray::has_value() const {
  return _internal_has_value();
}
inline void NamedStringArray::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::gnostic::openapi::v3::StringArray& NamedStringArray::_internal_value() const {
  const ::gnostic::openapi::v3::StringArray* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::StringArray&>(
      ::gnostic::openapi::v3::_StringArray_default_instance_);
}
inline const ::gnostic::openapi::v3::StringArray& NamedStringArray::value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.NamedStringArray.value)
  return _internal_value();
}
inline void NamedStringArray::unsafe_arena_set_allocated_value(
    ::gnostic::openapi::v3::StringArray* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.NamedStringArray.value)
}
inline ::gnostic::openapi::v3::StringArray* NamedStringArray::release_value() {
  
  ::gnostic::openapi::v3::StringArray* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::StringArray* NamedStringArray::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.NamedStringArray.value)
  
  ::gnostic::openapi::v3::StringArray* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::StringArray* NamedStringArray::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::StringArray>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::gnostic::openapi::v3::StringArray* NamedStringArray::mutable_value() {
  ::gnostic::openapi::v3::StringArray* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.NamedStringArray.value)
  return _msg;
}
inline void NamedStringArray::set_allocated_value(::gnostic::openapi::v3::StringArray* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.NamedStringArray.value)
}

// -------------------------------------------------------------------

// OauthFlow

// string authorization_url = 1;
inline void OauthFlow::clear_authorization_url() {
  _impl_.authorization_url_.ClearToEmpty();
}
inline const std::string& OauthFlow::authorization_url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlow.authorization_url)
  return _internal_authorization_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthFlow::set_authorization_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.OauthFlow.authorization_url)
}
inline std::string* OauthFlow::mutable_authorization_url() {
  std::string* _s = _internal_mutable_authorization_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlow.authorization_url)
  return _s;
}
inline const std::string& OauthFlow::_internal_authorization_url() const {
  return _impl_.authorization_url_.Get();
}
inline void OauthFlow::_internal_set_authorization_url(const std::string& value) {
  
  _impl_.authorization_url_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthFlow::_internal_mutable_authorization_url() {
  
  return _impl_.authorization_url_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthFlow::release_authorization_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlow.authorization_url)
  return _impl_.authorization_url_.Release();
}
inline void OauthFlow::set_allocated_authorization_url(std::string* authorization_url) {
  if (authorization_url != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_url_.SetAllocated(authorization_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_url_.IsDefault()) {
    _impl_.authorization_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlow.authorization_url)
}

// string token_url = 2;
inline void OauthFlow::clear_token_url() {
  _impl_.token_url_.ClearToEmpty();
}
inline const std::string& OauthFlow::token_url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlow.token_url)
  return _internal_token_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthFlow::set_token_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.OauthFlow.token_url)
}
inline std::string* OauthFlow::mutable_token_url() {
  std::string* _s = _internal_mutable_token_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlow.token_url)
  return _s;
}
inline const std::string& OauthFlow::_internal_token_url() const {
  return _impl_.token_url_.Get();
}
inline void OauthFlow::_internal_set_token_url(const std::string& value) {
  
  _impl_.token_url_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthFlow::_internal_mutable_token_url() {
  
  return _impl_.token_url_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthFlow::release_token_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlow.token_url)
  return _impl_.token_url_.Release();
}
inline void OauthFlow::set_allocated_token_url(std::string* token_url) {
  if (token_url != nullptr) {
    
  } else {
    
  }
  _impl_.token_url_.SetAllocated(token_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_url_.IsDefault()) {
    _impl_.token_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlow.token_url)
}

// string refresh_url = 3;
inline void OauthFlow::clear_refresh_url() {
  _impl_.refresh_url_.ClearToEmpty();
}
inline const std::string& OauthFlow::refresh_url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlow.refresh_url)
  return _internal_refresh_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthFlow::set_refresh_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.refresh_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.OauthFlow.refresh_url)
}
inline std::string* OauthFlow::mutable_refresh_url() {
  std::string* _s = _internal_mutable_refresh_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlow.refresh_url)
  return _s;
}
inline const std::string& OauthFlow::_internal_refresh_url() const {
  return _impl_.refresh_url_.Get();
}
inline void OauthFlow::_internal_set_refresh_url(const std::string& value) {
  
  _impl_.refresh_url_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthFlow::_internal_mutable_refresh_url() {
  
  return _impl_.refresh_url_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthFlow::release_refresh_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlow.refresh_url)
  return _impl_.refresh_url_.Release();
}
inline void OauthFlow::set_allocated_refresh_url(std::string* refresh_url) {
  if (refresh_url != nullptr) {
    
  } else {
    
  }
  _impl_.refresh_url_.SetAllocated(refresh_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.refresh_url_.IsDefault()) {
    _impl_.refresh_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlow.refresh_url)
}

// .gnostic.openapi.v3.Strings scopes = 4;
inline bool OauthFlow::_internal_has_scopes() const {
  return this != internal_default_instance() && _impl_.scopes_ != nullptr;
}
inline bool OauthFlow::has_scopes() const {
  return _internal_has_scopes();
}
inline void OauthFlow::clear_scopes() {
  if (GetArenaForAllocation() == nullptr && _impl_.scopes_ != nullptr) {
    delete _impl_.scopes_;
  }
  _impl_.scopes_ = nullptr;
}
inline const ::gnostic::openapi::v3::Strings& OauthFlow::_internal_scopes() const {
  const ::gnostic::openapi::v3::Strings* p = _impl_.scopes_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Strings&>(
      ::gnostic::openapi::v3::_Strings_default_instance_);
}
inline const ::gnostic::openapi::v3::Strings& OauthFlow::scopes() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlow.scopes)
  return _internal_scopes();
}
inline void OauthFlow::unsafe_arena_set_allocated_scopes(
    ::gnostic::openapi::v3::Strings* scopes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scopes_);
  }
  _impl_.scopes_ = scopes;
  if (scopes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.OauthFlow.scopes)
}
inline ::gnostic::openapi::v3::Strings* OauthFlow::release_scopes() {
  
  ::gnostic::openapi::v3::Strings* temp = _impl_.scopes_;
  _impl_.scopes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Strings* OauthFlow::unsafe_arena_release_scopes() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlow.scopes)
  
  ::gnostic::openapi::v3::Strings* temp = _impl_.scopes_;
  _impl_.scopes_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Strings* OauthFlow::_internal_mutable_scopes() {
  
  if (_impl_.scopes_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Strings>(GetArenaForAllocation());
    _impl_.scopes_ = p;
  }
  return _impl_.scopes_;
}
inline ::gnostic::openapi::v3::Strings* OauthFlow::mutable_scopes() {
  ::gnostic::openapi::v3::Strings* _msg = _internal_mutable_scopes();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlow.scopes)
  return _msg;
}
inline void OauthFlow::set_allocated_scopes(::gnostic::openapi::v3::Strings* scopes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scopes_;
  }
  if (scopes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scopes);
    if (message_arena != submessage_arena) {
      scopes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scopes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scopes_ = scopes;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlow.scopes)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
inline int OauthFlow::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int OauthFlow::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void OauthFlow::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* OauthFlow::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlow.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
OauthFlow::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.OauthFlow.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& OauthFlow::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& OauthFlow::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlow.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* OauthFlow::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* OauthFlow::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.OauthFlow.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
OauthFlow::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.OauthFlow.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// OauthFlows

// .gnostic.openapi.v3.OauthFlow implicit = 1;
inline bool OauthFlows::_internal_has_implicit() const {
  return this != internal_default_instance() && _impl_.implicit_ != nullptr;
}
inline bool OauthFlows::has_implicit() const {
  return _internal_has_implicit();
}
inline void OauthFlows::clear_implicit() {
  if (GetArenaForAllocation() == nullptr && _impl_.implicit_ != nullptr) {
    delete _impl_.implicit_;
  }
  _impl_.implicit_ = nullptr;
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::_internal_implicit() const {
  const ::gnostic::openapi::v3::OauthFlow* p = _impl_.implicit_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::OauthFlow&>(
      ::gnostic::openapi::v3::_OauthFlow_default_instance_);
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::implicit() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlows.implicit)
  return _internal_implicit();
}
inline void OauthFlows::unsafe_arena_set_allocated_implicit(
    ::gnostic::openapi::v3::OauthFlow* implicit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.implicit_);
  }
  _impl_.implicit_ = implicit;
  if (implicit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.OauthFlows.implicit)
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::release_implicit() {
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.implicit_;
  _impl_.implicit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::unsafe_arena_release_implicit() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlows.implicit)
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.implicit_;
  _impl_.implicit_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::_internal_mutable_implicit() {
  
  if (_impl_.implicit_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::OauthFlow>(GetArenaForAllocation());
    _impl_.implicit_ = p;
  }
  return _impl_.implicit_;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::mutable_implicit() {
  ::gnostic::openapi::v3::OauthFlow* _msg = _internal_mutable_implicit();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlows.implicit)
  return _msg;
}
inline void OauthFlows::set_allocated_implicit(::gnostic::openapi::v3::OauthFlow* implicit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.implicit_;
  }
  if (implicit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(implicit);
    if (message_arena != submessage_arena) {
      implicit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, implicit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.implicit_ = implicit;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlows.implicit)
}

// .gnostic.openapi.v3.OauthFlow password = 2;
inline bool OauthFlows::_internal_has_password() const {
  return this != internal_default_instance() && _impl_.password_ != nullptr;
}
inline bool OauthFlows::has_password() const {
  return _internal_has_password();
}
inline void OauthFlows::clear_password() {
  if (GetArenaForAllocation() == nullptr && _impl_.password_ != nullptr) {
    delete _impl_.password_;
  }
  _impl_.password_ = nullptr;
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::_internal_password() const {
  const ::gnostic::openapi::v3::OauthFlow* p = _impl_.password_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::OauthFlow&>(
      ::gnostic::openapi::v3::_OauthFlow_default_instance_);
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::password() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlows.password)
  return _internal_password();
}
inline void OauthFlows::unsafe_arena_set_allocated_password(
    ::gnostic::openapi::v3::OauthFlow* password) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.password_);
  }
  _impl_.password_ = password;
  if (password) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.OauthFlows.password)
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::release_password() {
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.password_;
  _impl_.password_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::unsafe_arena_release_password() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlows.password)
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.password_;
  _impl_.password_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::_internal_mutable_password() {
  
  if (_impl_.password_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::OauthFlow>(GetArenaForAllocation());
    _impl_.password_ = p;
  }
  return _impl_.password_;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::mutable_password() {
  ::gnostic::openapi::v3::OauthFlow* _msg = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlows.password)
  return _msg;
}
inline void OauthFlows::set_allocated_password(::gnostic::openapi::v3::OauthFlow* password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.password_;
  }
  if (password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(password);
    if (message_arena != submessage_arena) {
      password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, password, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.password_ = password;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlows.password)
}

// .gnostic.openapi.v3.OauthFlow client_credentials = 3;
inline bool OauthFlows::_internal_has_client_credentials() const {
  return this != internal_default_instance() && _impl_.client_credentials_ != nullptr;
}
inline bool OauthFlows::has_client_credentials() const {
  return _internal_has_client_credentials();
}
inline void OauthFlows::clear_client_credentials() {
  if (GetArenaForAllocation() == nullptr && _impl_.client_credentials_ != nullptr) {
    delete _impl_.client_credentials_;
  }
  _impl_.client_credentials_ = nullptr;
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::_internal_client_credentials() const {
  const ::gnostic::openapi::v3::OauthFlow* p = _impl_.client_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::OauthFlow&>(
      ::gnostic::openapi::v3::_OauthFlow_default_instance_);
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::client_credentials() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlows.client_credentials)
  return _internal_client_credentials();
}
inline void OauthFlows::unsafe_arena_set_allocated_client_credentials(
    ::gnostic::openapi::v3::OauthFlow* client_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_credentials_);
  }
  _impl_.client_credentials_ = client_credentials;
  if (client_credentials) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.OauthFlows.client_credentials)
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::release_client_credentials() {
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.client_credentials_;
  _impl_.client_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::unsafe_arena_release_client_credentials() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlows.client_credentials)
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.client_credentials_;
  _impl_.client_credentials_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::_internal_mutable_client_credentials() {
  
  if (_impl_.client_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::OauthFlow>(GetArenaForAllocation());
    _impl_.client_credentials_ = p;
  }
  return _impl_.client_credentials_;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::mutable_client_credentials() {
  ::gnostic::openapi::v3::OauthFlow* _msg = _internal_mutable_client_credentials();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlows.client_credentials)
  return _msg;
}
inline void OauthFlows::set_allocated_client_credentials(::gnostic::openapi::v3::OauthFlow* client_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_credentials_;
  }
  if (client_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_credentials);
    if (message_arena != submessage_arena) {
      client_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_credentials, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.client_credentials_ = client_credentials;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlows.client_credentials)
}

// .gnostic.openapi.v3.OauthFlow authorization_code = 4;
inline bool OauthFlows::_internal_has_authorization_code() const {
  return this != internal_default_instance() && _impl_.authorization_code_ != nullptr;
}
inline bool OauthFlows::has_authorization_code() const {
  return _internal_has_authorization_code();
}
inline void OauthFlows::clear_authorization_code() {
  if (GetArenaForAllocation() == nullptr && _impl_.authorization_code_ != nullptr) {
    delete _impl_.authorization_code_;
  }
  _impl_.authorization_code_ = nullptr;
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::_internal_authorization_code() const {
  const ::gnostic::openapi::v3::OauthFlow* p = _impl_.authorization_code_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::OauthFlow&>(
      ::gnostic::openapi::v3::_OauthFlow_default_instance_);
}
inline const ::gnostic::openapi::v3::OauthFlow& OauthFlows::authorization_code() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlows.authorization_code)
  return _internal_authorization_code();
}
inline void OauthFlows::unsafe_arena_set_allocated_authorization_code(
    ::gnostic::openapi::v3::OauthFlow* authorization_code) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authorization_code_);
  }
  _impl_.authorization_code_ = authorization_code;
  if (authorization_code) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.OauthFlows.authorization_code)
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::release_authorization_code() {
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.authorization_code_;
  _impl_.authorization_code_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::unsafe_arena_release_authorization_code() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.OauthFlows.authorization_code)
  
  ::gnostic::openapi::v3::OauthFlow* temp = _impl_.authorization_code_;
  _impl_.authorization_code_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::_internal_mutable_authorization_code() {
  
  if (_impl_.authorization_code_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::OauthFlow>(GetArenaForAllocation());
    _impl_.authorization_code_ = p;
  }
  return _impl_.authorization_code_;
}
inline ::gnostic::openapi::v3::OauthFlow* OauthFlows::mutable_authorization_code() {
  ::gnostic::openapi::v3::OauthFlow* _msg = _internal_mutable_authorization_code();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlows.authorization_code)
  return _msg;
}
inline void OauthFlows::set_allocated_authorization_code(::gnostic::openapi::v3::OauthFlow* authorization_code) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.authorization_code_;
  }
  if (authorization_code) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorization_code);
    if (message_arena != submessage_arena) {
      authorization_code = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization_code, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.authorization_code_ = authorization_code;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.OauthFlows.authorization_code)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
inline int OauthFlows::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int OauthFlows::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void OauthFlows::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* OauthFlows::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.OauthFlows.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
OauthFlows::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.OauthFlows.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& OauthFlows::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& OauthFlows::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.OauthFlows.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* OauthFlows::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* OauthFlows::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.OauthFlows.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
OauthFlows::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.OauthFlows.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Object

// repeated .gnostic.openapi.v3.NamedAny additional_properties = 1;
inline int Object::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int Object::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void Object::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Object::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Object.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Object::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Object.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedAny& Object::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Object::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Object.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedAny* Object::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Object::add_additional_properties() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Object.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Object::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Object.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Operation

// repeated string tags = 1;
inline int Operation::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int Operation::tags_size() const {
  return _internal_tags_size();
}
inline void Operation::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* Operation::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:gnostic.openapi.v3.Operation.tags)
  return _s;
}
inline const std::string& Operation::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& Operation::tags(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.tags)
  return _internal_tags(index);
}
inline std::string* Operation::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.tags)
  return _impl_.tags_.Mutable(index);
}
inline void Operation::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Operation.tags)
}
inline void Operation::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Operation.tags)
}
inline void Operation::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gnostic.openapi.v3.Operation.tags)
}
inline void Operation::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnostic.openapi.v3.Operation.tags)
}
inline std::string* Operation::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void Operation::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Operation.tags)
}
inline void Operation::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Operation.tags)
}
inline void Operation::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gnostic.openapi.v3.Operation.tags)
}
inline void Operation::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gnostic.openapi.v3.Operation.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Operation::tags() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Operation.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Operation::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Operation.tags)
  return &_impl_.tags_;
}

// string summary = 2;
inline void Operation::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& Operation::summary() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Operation.summary)
}
inline std::string* Operation::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.summary)
  return _s;
}
inline const std::string& Operation::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void Operation::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_summary() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Operation.summary)
  return _impl_.summary_.Release();
}
inline void Operation::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Operation.summary)
}

// string description = 3;
inline void Operation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Operation::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Operation.description)
}
inline std::string* Operation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.description)
  return _s;
}
inline const std::string& Operation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Operation::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Operation.description)
  return _impl_.description_.Release();
}
inline void Operation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Operation.description)
}

// .gnostic.openapi.v3.ExternalDocs external_docs = 4;
inline bool Operation::_internal_has_external_docs() const {
  return this != internal_default_instance() && _impl_.external_docs_ != nullptr;
}
inline bool Operation::has_external_docs() const {
  return _internal_has_external_docs();
}
inline void Operation::clear_external_docs() {
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExternalDocs& Operation::_internal_external_docs() const {
  const ::gnostic::openapi::v3::ExternalDocs* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExternalDocs&>(
      ::gnostic::openapi::v3::_ExternalDocs_default_instance_);
}
inline const ::gnostic::openapi::v3::ExternalDocs& Operation::external_docs() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.external_docs)
  return _internal_external_docs();
}
inline void Operation::unsafe_arena_set_allocated_external_docs(
    ::gnostic::openapi::v3::ExternalDocs* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Operation.external_docs)
}
inline ::gnostic::openapi::v3::ExternalDocs* Operation::release_external_docs() {
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Operation::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Operation.external_docs)
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Operation::_internal_mutable_external_docs() {
  
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExternalDocs>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::gnostic::openapi::v3::ExternalDocs* Operation::mutable_external_docs() {
  ::gnostic::openapi::v3::ExternalDocs* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.external_docs)
  return _msg;
}
inline void Operation::set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Operation.external_docs)
}

// string operation_id = 5;
inline void Operation::clear_operation_id() {
  _impl_.operation_id_.ClearToEmpty();
}
inline const std::string& Operation::operation_id() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.operation_id)
  return _internal_operation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_operation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Operation.operation_id)
}
inline std::string* Operation::mutable_operation_id() {
  std::string* _s = _internal_mutable_operation_id();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.operation_id)
  return _s;
}
inline const std::string& Operation::_internal_operation_id() const {
  return _impl_.operation_id_.Get();
}
inline void Operation::_internal_set_operation_id(const std::string& value) {
  
  _impl_.operation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_operation_id() {
  
  return _impl_.operation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_operation_id() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Operation.operation_id)
  return _impl_.operation_id_.Release();
}
inline void Operation::set_allocated_operation_id(std::string* operation_id) {
  if (operation_id != nullptr) {
    
  } else {
    
  }
  _impl_.operation_id_.SetAllocated(operation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_id_.IsDefault()) {
    _impl_.operation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Operation.operation_id)
}

// repeated .gnostic.openapi.v3.ParameterOrReference parameters = 6;
inline int Operation::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int Operation::parameters_size() const {
  return _internal_parameters_size();
}
inline void Operation::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline ::gnostic::openapi::v3::ParameterOrReference* Operation::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >*
Operation::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Operation.parameters)
  return &_impl_.parameters_;
}
inline const ::gnostic::openapi::v3::ParameterOrReference& Operation::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::gnostic::openapi::v3::ParameterOrReference& Operation::parameters(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.parameters)
  return _internal_parameters(index);
}
inline ::gnostic::openapi::v3::ParameterOrReference* Operation::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::gnostic::openapi::v3::ParameterOrReference* Operation::add_parameters() {
  ::gnostic::openapi::v3::ParameterOrReference* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Operation.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >&
Operation::parameters() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Operation.parameters)
  return _impl_.parameters_;
}

// .gnostic.openapi.v3.RequestBodyOrReference request_body = 7;
inline bool Operation::_internal_has_request_body() const {
  return this != internal_default_instance() && _impl_.request_body_ != nullptr;
}
inline bool Operation::has_request_body() const {
  return _internal_has_request_body();
}
inline void Operation::clear_request_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_body_ != nullptr) {
    delete _impl_.request_body_;
  }
  _impl_.request_body_ = nullptr;
}
inline const ::gnostic::openapi::v3::RequestBodyOrReference& Operation::_internal_request_body() const {
  const ::gnostic::openapi::v3::RequestBodyOrReference* p = _impl_.request_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::RequestBodyOrReference&>(
      ::gnostic::openapi::v3::_RequestBodyOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::RequestBodyOrReference& Operation::request_body() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.request_body)
  return _internal_request_body();
}
inline void Operation::unsafe_arena_set_allocated_request_body(
    ::gnostic::openapi::v3::RequestBodyOrReference* request_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_body_);
  }
  _impl_.request_body_ = request_body;
  if (request_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Operation.request_body)
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* Operation::release_request_body() {
  
  ::gnostic::openapi::v3::RequestBodyOrReference* temp = _impl_.request_body_;
  _impl_.request_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* Operation::unsafe_arena_release_request_body() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Operation.request_body)
  
  ::gnostic::openapi::v3::RequestBodyOrReference* temp = _impl_.request_body_;
  _impl_.request_body_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* Operation::_internal_mutable_request_body() {
  
  if (_impl_.request_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::RequestBodyOrReference>(GetArenaForAllocation());
    _impl_.request_body_ = p;
  }
  return _impl_.request_body_;
}
inline ::gnostic::openapi::v3::RequestBodyOrReference* Operation::mutable_request_body() {
  ::gnostic::openapi::v3::RequestBodyOrReference* _msg = _internal_mutable_request_body();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.request_body)
  return _msg;
}
inline void Operation::set_allocated_request_body(::gnostic::openapi::v3::RequestBodyOrReference* request_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_body_;
  }
  if (request_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_body);
    if (message_arena != submessage_arena) {
      request_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_body_ = request_body;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Operation.request_body)
}

// .gnostic.openapi.v3.Responses responses = 8;
inline bool Operation::_internal_has_responses() const {
  return this != internal_default_instance() && _impl_.responses_ != nullptr;
}
inline bool Operation::has_responses() const {
  return _internal_has_responses();
}
inline void Operation::clear_responses() {
  if (GetArenaForAllocation() == nullptr && _impl_.responses_ != nullptr) {
    delete _impl_.responses_;
  }
  _impl_.responses_ = nullptr;
}
inline const ::gnostic::openapi::v3::Responses& Operation::_internal_responses() const {
  const ::gnostic::openapi::v3::Responses* p = _impl_.responses_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Responses&>(
      ::gnostic::openapi::v3::_Responses_default_instance_);
}
inline const ::gnostic::openapi::v3::Responses& Operation::responses() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.responses)
  return _internal_responses();
}
inline void Operation::unsafe_arena_set_allocated_responses(
    ::gnostic::openapi::v3::Responses* responses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.responses_);
  }
  _impl_.responses_ = responses;
  if (responses) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Operation.responses)
}
inline ::gnostic::openapi::v3::Responses* Operation::release_responses() {
  
  ::gnostic::openapi::v3::Responses* temp = _impl_.responses_;
  _impl_.responses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Responses* Operation::unsafe_arena_release_responses() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Operation.responses)
  
  ::gnostic::openapi::v3::Responses* temp = _impl_.responses_;
  _impl_.responses_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Responses* Operation::_internal_mutable_responses() {
  
  if (_impl_.responses_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Responses>(GetArenaForAllocation());
    _impl_.responses_ = p;
  }
  return _impl_.responses_;
}
inline ::gnostic::openapi::v3::Responses* Operation::mutable_responses() {
  ::gnostic::openapi::v3::Responses* _msg = _internal_mutable_responses();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.responses)
  return _msg;
}
inline void Operation::set_allocated_responses(::gnostic::openapi::v3::Responses* responses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.responses_;
  }
  if (responses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(responses);
    if (message_arena != submessage_arena) {
      responses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responses, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.responses_ = responses;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Operation.responses)
}

// .gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
inline bool Operation::_internal_has_callbacks() const {
  return this != internal_default_instance() && _impl_.callbacks_ != nullptr;
}
inline bool Operation::has_callbacks() const {
  return _internal_has_callbacks();
}
inline void Operation::clear_callbacks() {
  if (GetArenaForAllocation() == nullptr && _impl_.callbacks_ != nullptr) {
    delete _impl_.callbacks_;
  }
  _impl_.callbacks_ = nullptr;
}
inline const ::gnostic::openapi::v3::CallbacksOrReferences& Operation::_internal_callbacks() const {
  const ::gnostic::openapi::v3::CallbacksOrReferences* p = _impl_.callbacks_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::CallbacksOrReferences&>(
      ::gnostic::openapi::v3::_CallbacksOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::CallbacksOrReferences& Operation::callbacks() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.callbacks)
  return _internal_callbacks();
}
inline void Operation::unsafe_arena_set_allocated_callbacks(
    ::gnostic::openapi::v3::CallbacksOrReferences* callbacks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.callbacks_);
  }
  _impl_.callbacks_ = callbacks;
  if (callbacks) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Operation.callbacks)
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Operation::release_callbacks() {
  
  ::gnostic::openapi::v3::CallbacksOrReferences* temp = _impl_.callbacks_;
  _impl_.callbacks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Operation::unsafe_arena_release_callbacks() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Operation.callbacks)
  
  ::gnostic::openapi::v3::CallbacksOrReferences* temp = _impl_.callbacks_;
  _impl_.callbacks_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Operation::_internal_mutable_callbacks() {
  
  if (_impl_.callbacks_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::CallbacksOrReferences>(GetArenaForAllocation());
    _impl_.callbacks_ = p;
  }
  return _impl_.callbacks_;
}
inline ::gnostic::openapi::v3::CallbacksOrReferences* Operation::mutable_callbacks() {
  ::gnostic::openapi::v3::CallbacksOrReferences* _msg = _internal_mutable_callbacks();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.callbacks)
  return _msg;
}
inline void Operation::set_allocated_callbacks(::gnostic::openapi::v3::CallbacksOrReferences* callbacks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.callbacks_;
  }
  if (callbacks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(callbacks);
    if (message_arena != submessage_arena) {
      callbacks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callbacks, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.callbacks_ = callbacks;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Operation.callbacks)
}

// bool deprecated = 10;
inline void Operation::clear_deprecated() {
  _impl_.deprecated_ = false;
}
inline bool Operation::_internal_deprecated() const {
  return _impl_.deprecated_;
}
inline bool Operation::deprecated() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.deprecated)
  return _internal_deprecated();
}
inline void Operation::_internal_set_deprecated(bool value) {
  
  _impl_.deprecated_ = value;
}
inline void Operation::set_deprecated(bool value) {
  _internal_set_deprecated(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Operation.deprecated)
}

// repeated .gnostic.openapi.v3.SecurityRequirement security = 11;
inline int Operation::_internal_security_size() const {
  return _impl_.security_.size();
}
inline int Operation::security_size() const {
  return _internal_security_size();
}
inline void Operation::clear_security() {
  _impl_.security_.Clear();
}
inline ::gnostic::openapi::v3::SecurityRequirement* Operation::mutable_security(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.security)
  return _impl_.security_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >*
Operation::mutable_security() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Operation.security)
  return &_impl_.security_;
}
inline const ::gnostic::openapi::v3::SecurityRequirement& Operation::_internal_security(int index) const {
  return _impl_.security_.Get(index);
}
inline const ::gnostic::openapi::v3::SecurityRequirement& Operation::security(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.security)
  return _internal_security(index);
}
inline ::gnostic::openapi::v3::SecurityRequirement* Operation::_internal_add_security() {
  return _impl_.security_.Add();
}
inline ::gnostic::openapi::v3::SecurityRequirement* Operation::add_security() {
  ::gnostic::openapi::v3::SecurityRequirement* _add = _internal_add_security();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Operation.security)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SecurityRequirement >&
Operation::security() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Operation.security)
  return _impl_.security_;
}

// repeated .gnostic.openapi.v3.Server servers = 12;
inline int Operation::_internal_servers_size() const {
  return _impl_.servers_.size();
}
inline int Operation::servers_size() const {
  return _internal_servers_size();
}
inline void Operation::clear_servers() {
  _impl_.servers_.Clear();
}
inline ::gnostic::openapi::v3::Server* Operation::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.servers)
  return _impl_.servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >*
Operation::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Operation.servers)
  return &_impl_.servers_;
}
inline const ::gnostic::openapi::v3::Server& Operation::_internal_servers(int index) const {
  return _impl_.servers_.Get(index);
}
inline const ::gnostic::openapi::v3::Server& Operation::servers(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.servers)
  return _internal_servers(index);
}
inline ::gnostic::openapi::v3::Server* Operation::_internal_add_servers() {
  return _impl_.servers_.Add();
}
inline ::gnostic::openapi::v3::Server* Operation::add_servers() {
  ::gnostic::openapi::v3::Server* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Operation.servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >&
Operation::servers() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Operation.servers)
  return _impl_.servers_;
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 13;
inline int Operation::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Operation::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Operation::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Operation::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Operation.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Operation::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Operation.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Operation::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Operation::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Operation.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Operation::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Operation::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Operation.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Operation::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Operation.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Parameter

// string name = 1;
inline void Parameter::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Parameter::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameter::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.name)
}
inline std::string* Parameter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.name)
  return _s;
}
inline const std::string& Parameter::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Parameter::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Parameter::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Parameter::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.name)
  return _impl_.name_.Release();
}
inline void Parameter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.name)
}

// string in = 2;
inline void Parameter::clear_in() {
  _impl_.in_.ClearToEmpty();
}
inline const std::string& Parameter::in() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.in)
  return _internal_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameter::set_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.in)
}
inline std::string* Parameter::mutable_in() {
  std::string* _s = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.in)
  return _s;
}
inline const std::string& Parameter::_internal_in() const {
  return _impl_.in_.Get();
}
inline void Parameter::_internal_set_in(const std::string& value) {
  
  _impl_.in_.Set(value, GetArenaForAllocation());
}
inline std::string* Parameter::_internal_mutable_in() {
  
  return _impl_.in_.Mutable(GetArenaForAllocation());
}
inline std::string* Parameter::release_in() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.in)
  return _impl_.in_.Release();
}
inline void Parameter::set_allocated_in(std::string* in) {
  if (in != nullptr) {
    
  } else {
    
  }
  _impl_.in_.SetAllocated(in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.in_.IsDefault()) {
    _impl_.in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.in)
}

// string description = 3;
inline void Parameter::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Parameter::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameter::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.description)
}
inline std::string* Parameter::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.description)
  return _s;
}
inline const std::string& Parameter::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Parameter::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Parameter::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Parameter::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.description)
  return _impl_.description_.Release();
}
inline void Parameter::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.description)
}

// bool required = 4;
inline void Parameter::clear_required() {
  _impl_.required_ = false;
}
inline bool Parameter::_internal_required() const {
  return _impl_.required_;
}
inline bool Parameter::required() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.required)
  return _internal_required();
}
inline void Parameter::_internal_set_required(bool value) {
  
  _impl_.required_ = value;
}
inline void Parameter::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.required)
}

// bool deprecated = 5;
inline void Parameter::clear_deprecated() {
  _impl_.deprecated_ = false;
}
inline bool Parameter::_internal_deprecated() const {
  return _impl_.deprecated_;
}
inline bool Parameter::deprecated() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.deprecated)
  return _internal_deprecated();
}
inline void Parameter::_internal_set_deprecated(bool value) {
  
  _impl_.deprecated_ = value;
}
inline void Parameter::set_deprecated(bool value) {
  _internal_set_deprecated(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.deprecated)
}

// bool allow_empty_value = 6;
inline void Parameter::clear_allow_empty_value() {
  _impl_.allow_empty_value_ = false;
}
inline bool Parameter::_internal_allow_empty_value() const {
  return _impl_.allow_empty_value_;
}
inline bool Parameter::allow_empty_value() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.allow_empty_value)
  return _internal_allow_empty_value();
}
inline void Parameter::_internal_set_allow_empty_value(bool value) {
  
  _impl_.allow_empty_value_ = value;
}
inline void Parameter::set_allow_empty_value(bool value) {
  _internal_set_allow_empty_value(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.allow_empty_value)
}

// string style = 7;
inline void Parameter::clear_style() {
  _impl_.style_.ClearToEmpty();
}
inline const std::string& Parameter::style() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.style)
  return _internal_style();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Parameter::set_style(ArgT0&& arg0, ArgT... args) {
 
 _impl_.style_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.style)
}
inline std::string* Parameter::mutable_style() {
  std::string* _s = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.style)
  return _s;
}
inline const std::string& Parameter::_internal_style() const {
  return _impl_.style_.Get();
}
inline void Parameter::_internal_set_style(const std::string& value) {
  
  _impl_.style_.Set(value, GetArenaForAllocation());
}
inline std::string* Parameter::_internal_mutable_style() {
  
  return _impl_.style_.Mutable(GetArenaForAllocation());
}
inline std::string* Parameter::release_style() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.style)
  return _impl_.style_.Release();
}
inline void Parameter::set_allocated_style(std::string* style) {
  if (style != nullptr) {
    
  } else {
    
  }
  _impl_.style_.SetAllocated(style, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.style_.IsDefault()) {
    _impl_.style_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.style)
}

// bool explode = 8;
inline void Parameter::clear_explode() {
  _impl_.explode_ = false;
}
inline bool Parameter::_internal_explode() const {
  return _impl_.explode_;
}
inline bool Parameter::explode() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.explode)
  return _internal_explode();
}
inline void Parameter::_internal_set_explode(bool value) {
  
  _impl_.explode_ = value;
}
inline void Parameter::set_explode(bool value) {
  _internal_set_explode(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.explode)
}

// bool allow_reserved = 9;
inline void Parameter::clear_allow_reserved() {
  _impl_.allow_reserved_ = false;
}
inline bool Parameter::_internal_allow_reserved() const {
  return _impl_.allow_reserved_;
}
inline bool Parameter::allow_reserved() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.allow_reserved)
  return _internal_allow_reserved();
}
inline void Parameter::_internal_set_allow_reserved(bool value) {
  
  _impl_.allow_reserved_ = value;
}
inline void Parameter::set_allow_reserved(bool value) {
  _internal_set_allow_reserved(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Parameter.allow_reserved)
}

// .gnostic.openapi.v3.SchemaOrReference schema = 10;
inline bool Parameter::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool Parameter::has_schema() const {
  return _internal_has_schema();
}
inline void Parameter::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Parameter::_internal_schema() const {
  const ::gnostic::openapi::v3::SchemaOrReference* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::SchemaOrReference&>(
      ::gnostic::openapi::v3::_SchemaOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Parameter::schema() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.schema)
  return _internal_schema();
}
inline void Parameter::unsafe_arena_set_allocated_schema(
    ::gnostic::openapi::v3::SchemaOrReference* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Parameter.schema)
}
inline ::gnostic::openapi::v3::SchemaOrReference* Parameter::release_schema() {
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* Parameter::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.schema)
  
  ::gnostic::openapi::v3::SchemaOrReference* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::SchemaOrReference* Parameter::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::SchemaOrReference>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::gnostic::openapi::v3::SchemaOrReference* Parameter::mutable_schema() {
  ::gnostic::openapi::v3::SchemaOrReference* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.schema)
  return _msg;
}
inline void Parameter::set_allocated_schema(::gnostic::openapi::v3::SchemaOrReference* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.schema)
}

// .gnostic.openapi.v3.Any example = 11;
inline bool Parameter::_internal_has_example() const {
  return this != internal_default_instance() && _impl_.example_ != nullptr;
}
inline bool Parameter::has_example() const {
  return _internal_has_example();
}
inline void Parameter::clear_example() {
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
}
inline const ::gnostic::openapi::v3::Any& Parameter::_internal_example() const {
  const ::gnostic::openapi::v3::Any* p = _impl_.example_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Any&>(
      ::gnostic::openapi::v3::_Any_default_instance_);
}
inline const ::gnostic::openapi::v3::Any& Parameter::example() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.example)
  return _internal_example();
}
inline void Parameter::unsafe_arena_set_allocated_example(
    ::gnostic::openapi::v3::Any* example) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.example_);
  }
  _impl_.example_ = example;
  if (example) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Parameter.example)
}
inline ::gnostic::openapi::v3::Any* Parameter::release_example() {
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Any* Parameter::unsafe_arena_release_example() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.example)
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Any* Parameter::_internal_mutable_example() {
  
  if (_impl_.example_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Any>(GetArenaForAllocation());
    _impl_.example_ = p;
  }
  return _impl_.example_;
}
inline ::gnostic::openapi::v3::Any* Parameter::mutable_example() {
  ::gnostic::openapi::v3::Any* _msg = _internal_mutable_example();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.example)
  return _msg;
}
inline void Parameter::set_allocated_example(::gnostic::openapi::v3::Any* example) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.example_;
  }
  if (example) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(example);
    if (message_arena != submessage_arena) {
      example = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.example_ = example;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.example)
}

// .gnostic.openapi.v3.ExamplesOrReferences examples = 12;
inline bool Parameter::_internal_has_examples() const {
  return this != internal_default_instance() && _impl_.examples_ != nullptr;
}
inline bool Parameter::has_examples() const {
  return _internal_has_examples();
}
inline void Parameter::clear_examples() {
  if (GetArenaForAllocation() == nullptr && _impl_.examples_ != nullptr) {
    delete _impl_.examples_;
  }
  _impl_.examples_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& Parameter::_internal_examples() const {
  const ::gnostic::openapi::v3::ExamplesOrReferences* p = _impl_.examples_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExamplesOrReferences&>(
      ::gnostic::openapi::v3::_ExamplesOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::ExamplesOrReferences& Parameter::examples() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.examples)
  return _internal_examples();
}
inline void Parameter::unsafe_arena_set_allocated_examples(
    ::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.examples_);
  }
  _impl_.examples_ = examples;
  if (examples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Parameter.examples)
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Parameter::release_examples() {
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Parameter::unsafe_arena_release_examples() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.examples)
  
  ::gnostic::openapi::v3::ExamplesOrReferences* temp = _impl_.examples_;
  _impl_.examples_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Parameter::_internal_mutable_examples() {
  
  if (_impl_.examples_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExamplesOrReferences>(GetArenaForAllocation());
    _impl_.examples_ = p;
  }
  return _impl_.examples_;
}
inline ::gnostic::openapi::v3::ExamplesOrReferences* Parameter::mutable_examples() {
  ::gnostic::openapi::v3::ExamplesOrReferences* _msg = _internal_mutable_examples();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.examples)
  return _msg;
}
inline void Parameter::set_allocated_examples(::gnostic::openapi::v3::ExamplesOrReferences* examples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.examples_;
  }
  if (examples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(examples);
    if (message_arena != submessage_arena) {
      examples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, examples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.examples_ = examples;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.examples)
}

// .gnostic.openapi.v3.MediaTypes content = 13;
inline bool Parameter::_internal_has_content() const {
  return this != internal_default_instance() && _impl_.content_ != nullptr;
}
inline bool Parameter::has_content() const {
  return _internal_has_content();
}
inline void Parameter::clear_content() {
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
}
inline const ::gnostic::openapi::v3::MediaTypes& Parameter::_internal_content() const {
  const ::gnostic::openapi::v3::MediaTypes* p = _impl_.content_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::MediaTypes&>(
      ::gnostic::openapi::v3::_MediaTypes_default_instance_);
}
inline const ::gnostic::openapi::v3::MediaTypes& Parameter::content() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.content)
  return _internal_content();
}
inline void Parameter::unsafe_arena_set_allocated_content(
    ::gnostic::openapi::v3::MediaTypes* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
  }
  _impl_.content_ = content;
  if (content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Parameter.content)
}
inline ::gnostic::openapi::v3::MediaTypes* Parameter::release_content() {
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* Parameter::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Parameter.content)
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* Parameter::_internal_mutable_content() {
  
  if (_impl_.content_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::MediaTypes>(GetArenaForAllocation());
    _impl_.content_ = p;
  }
  return _impl_.content_;
}
inline ::gnostic::openapi::v3::MediaTypes* Parameter::mutable_content() {
  ::gnostic::openapi::v3::MediaTypes* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.content)
  return _msg;
}
inline void Parameter::set_allocated_content(::gnostic::openapi::v3::MediaTypes* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.content_ = content;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Parameter.content)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
inline int Parameter::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Parameter::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Parameter::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Parameter::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Parameter.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Parameter::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Parameter.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Parameter::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Parameter::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Parameter.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Parameter::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Parameter::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Parameter.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Parameter::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Parameter.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// ParameterOrReference

// .gnostic.openapi.v3.Parameter parameter = 1;
inline bool ParameterOrReference::_internal_has_parameter() const {
  return oneof_case() == kParameter;
}
inline bool ParameterOrReference::has_parameter() const {
  return _internal_has_parameter();
}
inline void ParameterOrReference::set_has_parameter() {
  _impl_._oneof_case_[0] = kParameter;
}
inline void ParameterOrReference::clear_parameter() {
  if (_internal_has_parameter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.parameter_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Parameter* ParameterOrReference::release_parameter() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ParameterOrReference.parameter)
  if (_internal_has_parameter()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Parameter* temp = _impl_.oneof_.parameter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Parameter& ParameterOrReference::_internal_parameter() const {
  return _internal_has_parameter()
      ? *_impl_.oneof_.parameter_
      : reinterpret_cast< ::gnostic::openapi::v3::Parameter&>(::gnostic::openapi::v3::_Parameter_default_instance_);
}
inline const ::gnostic::openapi::v3::Parameter& ParameterOrReference::parameter() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ParameterOrReference.parameter)
  return _internal_parameter();
}
inline ::gnostic::openapi::v3::Parameter* ParameterOrReference::unsafe_arena_release_parameter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.ParameterOrReference.parameter)
  if (_internal_has_parameter()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Parameter* temp = _impl_.oneof_.parameter_;
    _impl_.oneof_.parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParameterOrReference::unsafe_arena_set_allocated_parameter(::gnostic::openapi::v3::Parameter* parameter) {
  clear_oneof();
  if (parameter) {
    set_has_parameter();
    _impl_.oneof_.parameter_ = parameter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.ParameterOrReference.parameter)
}
inline ::gnostic::openapi::v3::Parameter* ParameterOrReference::_internal_mutable_parameter() {
  if (!_internal_has_parameter()) {
    clear_oneof();
    set_has_parameter();
    _impl_.oneof_.parameter_ = CreateMaybeMessage< ::gnostic::openapi::v3::Parameter >(GetArenaForAllocation());
  }
  return _impl_.oneof_.parameter_;
}
inline ::gnostic::openapi::v3::Parameter* ParameterOrReference::mutable_parameter() {
  ::gnostic::openapi::v3::Parameter* _msg = _internal_mutable_parameter();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ParameterOrReference.parameter)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool ParameterOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool ParameterOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void ParameterOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void ParameterOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* ParameterOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ParameterOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& ParameterOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& ParameterOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ParameterOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* ParameterOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.ParameterOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParameterOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.ParameterOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* ParameterOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* ParameterOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ParameterOrReference.reference)
  return _msg;
}

inline bool ParameterOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void ParameterOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline ParameterOrReference::OneofCase ParameterOrReference::oneof_case() const {
  return ParameterOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ParametersOrReferences

// repeated .gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1;
inline int ParametersOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int ParametersOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void ParametersOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedParameterOrReference* ParametersOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ParametersOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedParameterOrReference >*
ParametersOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ParametersOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedParameterOrReference& ParametersOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedParameterOrReference& ParametersOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ParametersOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedParameterOrReference* ParametersOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedParameterOrReference* ParametersOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedParameterOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ParametersOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedParameterOrReference >&
ParametersOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ParametersOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// PathItem

// string _ref = 1;
inline void PathItem::clear__ref() {
  _impl_._ref_.ClearToEmpty();
}
inline const std::string& PathItem::_ref() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem._ref)
  return _internal__ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathItem::set__ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_._ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.PathItem._ref)
}
inline std::string* PathItem::mutable__ref() {
  std::string* _s = _internal_mutable__ref();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem._ref)
  return _s;
}
inline const std::string& PathItem::_internal__ref() const {
  return _impl_._ref_.Get();
}
inline void PathItem::_internal_set__ref(const std::string& value) {
  
  _impl_._ref_.Set(value, GetArenaForAllocation());
}
inline std::string* PathItem::_internal_mutable__ref() {
  
  return _impl_._ref_.Mutable(GetArenaForAllocation());
}
inline std::string* PathItem::release__ref() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem._ref)
  return _impl_._ref_.Release();
}
inline void PathItem::set_allocated__ref(std::string* _ref) {
  if (_ref != nullptr) {
    
  } else {
    
  }
  _impl_._ref_.SetAllocated(_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._ref_.IsDefault()) {
    _impl_._ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem._ref)
}

// string summary = 2;
inline void PathItem::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& PathItem::summary() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathItem::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.PathItem.summary)
}
inline std::string* PathItem::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.summary)
  return _s;
}
inline const std::string& PathItem::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void PathItem::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* PathItem::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* PathItem::release_summary() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.summary)
  return _impl_.summary_.Release();
}
inline void PathItem::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.summary)
}

// string description = 3;
inline void PathItem::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& PathItem::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathItem::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.PathItem.description)
}
inline std::string* PathItem::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.description)
  return _s;
}
inline const std::string& PathItem::_internal_description() const {
  return _impl_.description_.Get();
}
inline void PathItem::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* PathItem::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* PathItem::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.description)
  return _impl_.description_.Release();
}
inline void PathItem::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.description)
}

// .gnostic.openapi.v3.Operation get = 4;
inline bool PathItem::_internal_has_get() const {
  return this != internal_default_instance() && _impl_.get_ != nullptr;
}
inline bool PathItem::has_get() const {
  return _internal_has_get();
}
inline void PathItem::clear_get() {
  if (GetArenaForAllocation() == nullptr && _impl_.get_ != nullptr) {
    delete _impl_.get_;
  }
  _impl_.get_ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_get() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.get_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::get() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.get)
  return _internal_get();
}
inline void PathItem::unsafe_arena_set_allocated_get(
    ::gnostic::openapi::v3::Operation* get) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.get_);
  }
  _impl_.get_ = get;
  if (get) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.get)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_get() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.get_;
  _impl_.get_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_get() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.get)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.get_;
  _impl_.get_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_get() {
  
  if (_impl_.get_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.get_ = p;
  }
  return _impl_.get_;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_get() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_get();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.get)
  return _msg;
}
inline void PathItem::set_allocated_get(::gnostic::openapi::v3::Operation* get) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.get_;
  }
  if (get) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get);
    if (message_arena != submessage_arena) {
      get = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.get_ = get;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.get)
}

// .gnostic.openapi.v3.Operation put = 5;
inline bool PathItem::_internal_has_put() const {
  return this != internal_default_instance() && _impl_.put_ != nullptr;
}
inline bool PathItem::has_put() const {
  return _internal_has_put();
}
inline void PathItem::clear_put() {
  if (GetArenaForAllocation() == nullptr && _impl_.put_ != nullptr) {
    delete _impl_.put_;
  }
  _impl_.put_ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_put() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.put_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::put() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.put)
  return _internal_put();
}
inline void PathItem::unsafe_arena_set_allocated_put(
    ::gnostic::openapi::v3::Operation* put) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.put_);
  }
  _impl_.put_ = put;
  if (put) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.put)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_put() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.put_;
  _impl_.put_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_put() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.put)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.put_;
  _impl_.put_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_put() {
  
  if (_impl_.put_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.put_ = p;
  }
  return _impl_.put_;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_put() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_put();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.put)
  return _msg;
}
inline void PathItem::set_allocated_put(::gnostic::openapi::v3::Operation* put) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.put_;
  }
  if (put) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(put);
    if (message_arena != submessage_arena) {
      put = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, put, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.put_ = put;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.put)
}

// .gnostic.openapi.v3.Operation post = 6;
inline bool PathItem::_internal_has_post() const {
  return this != internal_default_instance() && _impl_.post_ != nullptr;
}
inline bool PathItem::has_post() const {
  return _internal_has_post();
}
inline void PathItem::clear_post() {
  if (GetArenaForAllocation() == nullptr && _impl_.post_ != nullptr) {
    delete _impl_.post_;
  }
  _impl_.post_ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_post() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.post_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::post() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.post)
  return _internal_post();
}
inline void PathItem::unsafe_arena_set_allocated_post(
    ::gnostic::openapi::v3::Operation* post) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.post_);
  }
  _impl_.post_ = post;
  if (post) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.post)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_post() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.post_;
  _impl_.post_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_post() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.post)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.post_;
  _impl_.post_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_post() {
  
  if (_impl_.post_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.post_ = p;
  }
  return _impl_.post_;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_post() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_post();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.post)
  return _msg;
}
inline void PathItem::set_allocated_post(::gnostic::openapi::v3::Operation* post) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.post_;
  }
  if (post) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(post);
    if (message_arena != submessage_arena) {
      post = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, post, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.post_ = post;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.post)
}

// .gnostic.openapi.v3.Operation delete = 7;
inline bool PathItem::_internal_has_delete_() const {
  return this != internal_default_instance() && _impl_.delete__ != nullptr;
}
inline bool PathItem::has_delete_() const {
  return _internal_has_delete_();
}
inline void PathItem::clear_delete_() {
  if (GetArenaForAllocation() == nullptr && _impl_.delete__ != nullptr) {
    delete _impl_.delete__;
  }
  _impl_.delete__ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_delete_() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.delete__;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::delete_() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.delete)
  return _internal_delete_();
}
inline void PathItem::unsafe_arena_set_allocated_delete_(
    ::gnostic::openapi::v3::Operation* delete_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delete__);
  }
  _impl_.delete__ = delete_;
  if (delete_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.delete)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_delete_() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.delete__;
  _impl_.delete__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_delete_() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.delete)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.delete__;
  _impl_.delete__ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_delete_() {
  
  if (_impl_.delete__ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.delete__ = p;
  }
  return _impl_.delete__;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_delete_() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_delete_();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.delete)
  return _msg;
}
inline void PathItem::set_allocated_delete_(::gnostic::openapi::v3::Operation* delete_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.delete__;
  }
  if (delete_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delete_);
    if (message_arena != submessage_arena) {
      delete_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.delete__ = delete_;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.delete)
}

// .gnostic.openapi.v3.Operation options = 8;
inline bool PathItem::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool PathItem::has_options() const {
  return _internal_has_options();
}
inline void PathItem::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_options() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::options() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.options)
  return _internal_options();
}
inline void PathItem::unsafe_arena_set_allocated_options(
    ::gnostic::openapi::v3::Operation* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.options)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_options() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.options)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_options() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.options)
  return _msg;
}
inline void PathItem::set_allocated_options(::gnostic::openapi::v3::Operation* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.options)
}

// .gnostic.openapi.v3.Operation head = 9;
inline bool PathItem::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool PathItem::has_head() const {
  return _internal_has_head();
}
inline void PathItem::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_head() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::head() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.head)
  return _internal_head();
}
inline void PathItem::unsafe_arena_set_allocated_head(
    ::gnostic::openapi::v3::Operation* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.head)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_head() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.head)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_head() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.head)
  return _msg;
}
inline void PathItem::set_allocated_head(::gnostic::openapi::v3::Operation* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.head)
}

// .gnostic.openapi.v3.Operation patch = 10;
inline bool PathItem::_internal_has_patch() const {
  return this != internal_default_instance() && _impl_.patch_ != nullptr;
}
inline bool PathItem::has_patch() const {
  return _internal_has_patch();
}
inline void PathItem::clear_patch() {
  if (GetArenaForAllocation() == nullptr && _impl_.patch_ != nullptr) {
    delete _impl_.patch_;
  }
  _impl_.patch_ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_patch() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.patch_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::patch() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.patch)
  return _internal_patch();
}
inline void PathItem::unsafe_arena_set_allocated_patch(
    ::gnostic::openapi::v3::Operation* patch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.patch_);
  }
  _impl_.patch_ = patch;
  if (patch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.patch)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_patch() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.patch_;
  _impl_.patch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_patch() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.patch)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.patch_;
  _impl_.patch_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_patch() {
  
  if (_impl_.patch_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.patch_ = p;
  }
  return _impl_.patch_;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_patch() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_patch();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.patch)
  return _msg;
}
inline void PathItem::set_allocated_patch(::gnostic::openapi::v3::Operation* patch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.patch_;
  }
  if (patch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(patch);
    if (message_arena != submessage_arena) {
      patch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, patch, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.patch_ = patch;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.patch)
}

// .gnostic.openapi.v3.Operation trace = 11;
inline bool PathItem::_internal_has_trace() const {
  return this != internal_default_instance() && _impl_.trace_ != nullptr;
}
inline bool PathItem::has_trace() const {
  return _internal_has_trace();
}
inline void PathItem::clear_trace() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_ != nullptr) {
    delete _impl_.trace_;
  }
  _impl_.trace_ = nullptr;
}
inline const ::gnostic::openapi::v3::Operation& PathItem::_internal_trace() const {
  const ::gnostic::openapi::v3::Operation* p = _impl_.trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Operation&>(
      ::gnostic::openapi::v3::_Operation_default_instance_);
}
inline const ::gnostic::openapi::v3::Operation& PathItem::trace() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.trace)
  return _internal_trace();
}
inline void PathItem::unsafe_arena_set_allocated_trace(
    ::gnostic::openapi::v3::Operation* trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_);
  }
  _impl_.trace_ = trace;
  if (trace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.PathItem.trace)
}
inline ::gnostic::openapi::v3::Operation* PathItem::release_trace() {
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.trace_;
  _impl_.trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::unsafe_arena_release_trace() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.PathItem.trace)
  
  ::gnostic::openapi::v3::Operation* temp = _impl_.trace_;
  _impl_.trace_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Operation* PathItem::_internal_mutable_trace() {
  
  if (_impl_.trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Operation>(GetArenaForAllocation());
    _impl_.trace_ = p;
  }
  return _impl_.trace_;
}
inline ::gnostic::openapi::v3::Operation* PathItem::mutable_trace() {
  ::gnostic::openapi::v3::Operation* _msg = _internal_mutable_trace();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.trace)
  return _msg;
}
inline void PathItem::set_allocated_trace(::gnostic::openapi::v3::Operation* trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_;
  }
  if (trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace);
    if (message_arena != submessage_arena) {
      trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_ = trace;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.PathItem.trace)
}

// repeated .gnostic.openapi.v3.Server servers = 12;
inline int PathItem::_internal_servers_size() const {
  return _impl_.servers_.size();
}
inline int PathItem::servers_size() const {
  return _internal_servers_size();
}
inline void PathItem::clear_servers() {
  _impl_.servers_.Clear();
}
inline ::gnostic::openapi::v3::Server* PathItem::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.servers)
  return _impl_.servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >*
PathItem::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.PathItem.servers)
  return &_impl_.servers_;
}
inline const ::gnostic::openapi::v3::Server& PathItem::_internal_servers(int index) const {
  return _impl_.servers_.Get(index);
}
inline const ::gnostic::openapi::v3::Server& PathItem::servers(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.servers)
  return _internal_servers(index);
}
inline ::gnostic::openapi::v3::Server* PathItem::_internal_add_servers() {
  return _impl_.servers_.Add();
}
inline ::gnostic::openapi::v3::Server* PathItem::add_servers() {
  ::gnostic::openapi::v3::Server* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.PathItem.servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Server >&
PathItem::servers() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.PathItem.servers)
  return _impl_.servers_;
}

// repeated .gnostic.openapi.v3.ParameterOrReference parameters = 13;
inline int PathItem::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int PathItem::parameters_size() const {
  return _internal_parameters_size();
}
inline void PathItem::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline ::gnostic::openapi::v3::ParameterOrReference* PathItem::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >*
PathItem::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.PathItem.parameters)
  return &_impl_.parameters_;
}
inline const ::gnostic::openapi::v3::ParameterOrReference& PathItem::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::gnostic::openapi::v3::ParameterOrReference& PathItem::parameters(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.parameters)
  return _internal_parameters(index);
}
inline ::gnostic::openapi::v3::ParameterOrReference* PathItem::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::gnostic::openapi::v3::ParameterOrReference* PathItem::add_parameters() {
  ::gnostic::openapi::v3::ParameterOrReference* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.PathItem.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::ParameterOrReference >&
PathItem::parameters() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.PathItem.parameters)
  return _impl_.parameters_;
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 14;
inline int PathItem::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int PathItem::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void PathItem::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* PathItem::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.PathItem.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
PathItem::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.PathItem.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& PathItem::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& PathItem::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.PathItem.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* PathItem::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* PathItem::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.PathItem.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
PathItem::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.PathItem.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Paths

// repeated .gnostic.openapi.v3.NamedPathItem path = 1;
inline int Paths::_internal_path_size() const {
  return _impl_.path_.size();
}
inline int Paths::path_size() const {
  return _internal_path_size();
}
inline void Paths::clear_path() {
  _impl_.path_.Clear();
}
inline ::gnostic::openapi::v3::NamedPathItem* Paths::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Paths.path)
  return _impl_.path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >*
Paths::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Paths.path)
  return &_impl_.path_;
}
inline const ::gnostic::openapi::v3::NamedPathItem& Paths::_internal_path(int index) const {
  return _impl_.path_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedPathItem& Paths::path(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Paths.path)
  return _internal_path(index);
}
inline ::gnostic::openapi::v3::NamedPathItem* Paths::_internal_add_path() {
  return _impl_.path_.Add();
}
inline ::gnostic::openapi::v3::NamedPathItem* Paths::add_path() {
  ::gnostic::openapi::v3::NamedPathItem* _add = _internal_add_path();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Paths.path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedPathItem >&
Paths::path() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Paths.path)
  return _impl_.path_;
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 2;
inline int Paths::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Paths::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Paths::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Paths::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Paths.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Paths::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Paths.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Paths::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Paths::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Paths.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Paths::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Paths::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Paths.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Paths::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Paths.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Properties

// repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
inline int Properties::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int Properties::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void Properties::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedSchemaOrReference* Properties::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Properties.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >*
Properties::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Properties.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedSchemaOrReference& Properties::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedSchemaOrReference& Properties::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Properties.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedSchemaOrReference* Properties::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedSchemaOrReference* Properties::add_additional_properties() {
  ::gnostic::openapi::v3::NamedSchemaOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Properties.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >&
Properties::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Properties.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Reference

// string _ref = 1;
inline void Reference::clear__ref() {
  _impl_._ref_.ClearToEmpty();
}
inline const std::string& Reference::_ref() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Reference._ref)
  return _internal__ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reference::set__ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_._ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Reference._ref)
}
inline std::string* Reference::mutable__ref() {
  std::string* _s = _internal_mutable__ref();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Reference._ref)
  return _s;
}
inline const std::string& Reference::_internal__ref() const {
  return _impl_._ref_.Get();
}
inline void Reference::_internal_set__ref(const std::string& value) {
  
  _impl_._ref_.Set(value, GetArenaForAllocation());
}
inline std::string* Reference::_internal_mutable__ref() {
  
  return _impl_._ref_.Mutable(GetArenaForAllocation());
}
inline std::string* Reference::release__ref() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Reference._ref)
  return _impl_._ref_.Release();
}
inline void Reference::set_allocated__ref(std::string* _ref) {
  if (_ref != nullptr) {
    
  } else {
    
  }
  _impl_._ref_.SetAllocated(_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._ref_.IsDefault()) {
    _impl_._ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Reference._ref)
}

// string summary = 2;
inline void Reference::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& Reference::summary() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Reference.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reference::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Reference.summary)
}
inline std::string* Reference::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Reference.summary)
  return _s;
}
inline const std::string& Reference::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void Reference::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* Reference::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* Reference::release_summary() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Reference.summary)
  return _impl_.summary_.Release();
}
inline void Reference::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Reference.summary)
}

// string description = 3;
inline void Reference::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Reference::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Reference.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reference::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Reference.description)
}
inline std::string* Reference::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Reference.description)
  return _s;
}
inline const std::string& Reference::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Reference::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Reference::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Reference::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Reference.description)
  return _impl_.description_.Release();
}
inline void Reference::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Reference.description)
}

// -------------------------------------------------------------------

// RequestBodiesOrReferences

// repeated .gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1;
inline int RequestBodiesOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int RequestBodiesOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void RequestBodiesOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedRequestBodyOrReference* RequestBodiesOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.RequestBodiesOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedRequestBodyOrReference >*
RequestBodiesOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.RequestBodiesOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedRequestBodyOrReference& RequestBodiesOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedRequestBodyOrReference& RequestBodiesOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.RequestBodiesOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedRequestBodyOrReference* RequestBodiesOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedRequestBodyOrReference* RequestBodiesOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedRequestBodyOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.RequestBodiesOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedRequestBodyOrReference >&
RequestBodiesOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.RequestBodiesOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// RequestBody

// string description = 1;
inline void RequestBody::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RequestBody::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.RequestBody.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestBody::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.RequestBody.description)
}
inline std::string* RequestBody::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.RequestBody.description)
  return _s;
}
inline const std::string& RequestBody::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RequestBody::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestBody::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestBody::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.RequestBody.description)
  return _impl_.description_.Release();
}
inline void RequestBody::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.RequestBody.description)
}

// .gnostic.openapi.v3.MediaTypes content = 2;
inline bool RequestBody::_internal_has_content() const {
  return this != internal_default_instance() && _impl_.content_ != nullptr;
}
inline bool RequestBody::has_content() const {
  return _internal_has_content();
}
inline void RequestBody::clear_content() {
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
}
inline const ::gnostic::openapi::v3::MediaTypes& RequestBody::_internal_content() const {
  const ::gnostic::openapi::v3::MediaTypes* p = _impl_.content_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::MediaTypes&>(
      ::gnostic::openapi::v3::_MediaTypes_default_instance_);
}
inline const ::gnostic::openapi::v3::MediaTypes& RequestBody::content() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.RequestBody.content)
  return _internal_content();
}
inline void RequestBody::unsafe_arena_set_allocated_content(
    ::gnostic::openapi::v3::MediaTypes* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
  }
  _impl_.content_ = content;
  if (content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.RequestBody.content)
}
inline ::gnostic::openapi::v3::MediaTypes* RequestBody::release_content() {
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* RequestBody::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.RequestBody.content)
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* RequestBody::_internal_mutable_content() {
  
  if (_impl_.content_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::MediaTypes>(GetArenaForAllocation());
    _impl_.content_ = p;
  }
  return _impl_.content_;
}
inline ::gnostic::openapi::v3::MediaTypes* RequestBody::mutable_content() {
  ::gnostic::openapi::v3::MediaTypes* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.RequestBody.content)
  return _msg;
}
inline void RequestBody::set_allocated_content(::gnostic::openapi::v3::MediaTypes* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.content_ = content;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.RequestBody.content)
}

// bool required = 3;
inline void RequestBody::clear_required() {
  _impl_.required_ = false;
}
inline bool RequestBody::_internal_required() const {
  return _impl_.required_;
}
inline bool RequestBody::required() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.RequestBody.required)
  return _internal_required();
}
inline void RequestBody::_internal_set_required(bool value) {
  
  _impl_.required_ = value;
}
inline void RequestBody::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.RequestBody.required)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
inline int RequestBody::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int RequestBody::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void RequestBody::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* RequestBody::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.RequestBody.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
RequestBody::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.RequestBody.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& RequestBody::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& RequestBody::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.RequestBody.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* RequestBody::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* RequestBody::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.RequestBody.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
RequestBody::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.RequestBody.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// RequestBodyOrReference

// .gnostic.openapi.v3.RequestBody request_body = 1;
inline bool RequestBodyOrReference::_internal_has_request_body() const {
  return oneof_case() == kRequestBody;
}
inline bool RequestBodyOrReference::has_request_body() const {
  return _internal_has_request_body();
}
inline void RequestBodyOrReference::set_has_request_body() {
  _impl_._oneof_case_[0] = kRequestBody;
}
inline void RequestBodyOrReference::clear_request_body() {
  if (_internal_has_request_body()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.request_body_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::RequestBody* RequestBodyOrReference::release_request_body() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.RequestBodyOrReference.request_body)
  if (_internal_has_request_body()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::RequestBody* temp = _impl_.oneof_.request_body_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.request_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::RequestBody& RequestBodyOrReference::_internal_request_body() const {
  return _internal_has_request_body()
      ? *_impl_.oneof_.request_body_
      : reinterpret_cast< ::gnostic::openapi::v3::RequestBody&>(::gnostic::openapi::v3::_RequestBody_default_instance_);
}
inline const ::gnostic::openapi::v3::RequestBody& RequestBodyOrReference::request_body() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.RequestBodyOrReference.request_body)
  return _internal_request_body();
}
inline ::gnostic::openapi::v3::RequestBody* RequestBodyOrReference::unsafe_arena_release_request_body() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.RequestBodyOrReference.request_body)
  if (_internal_has_request_body()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::RequestBody* temp = _impl_.oneof_.request_body_;
    _impl_.oneof_.request_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestBodyOrReference::unsafe_arena_set_allocated_request_body(::gnostic::openapi::v3::RequestBody* request_body) {
  clear_oneof();
  if (request_body) {
    set_has_request_body();
    _impl_.oneof_.request_body_ = request_body;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.RequestBodyOrReference.request_body)
}
inline ::gnostic::openapi::v3::RequestBody* RequestBodyOrReference::_internal_mutable_request_body() {
  if (!_internal_has_request_body()) {
    clear_oneof();
    set_has_request_body();
    _impl_.oneof_.request_body_ = CreateMaybeMessage< ::gnostic::openapi::v3::RequestBody >(GetArenaForAllocation());
  }
  return _impl_.oneof_.request_body_;
}
inline ::gnostic::openapi::v3::RequestBody* RequestBodyOrReference::mutable_request_body() {
  ::gnostic::openapi::v3::RequestBody* _msg = _internal_mutable_request_body();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.RequestBodyOrReference.request_body)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool RequestBodyOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool RequestBodyOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void RequestBodyOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void RequestBodyOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* RequestBodyOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.RequestBodyOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& RequestBodyOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& RequestBodyOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.RequestBodyOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* RequestBodyOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.RequestBodyOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestBodyOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.RequestBodyOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* RequestBodyOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* RequestBodyOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.RequestBodyOrReference.reference)
  return _msg;
}

inline bool RequestBodyOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void RequestBodyOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline RequestBodyOrReference::OneofCase RequestBodyOrReference::oneof_case() const {
  return RequestBodyOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// string description = 1;
inline void Response::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Response::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Response.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Response.description)
}
inline std::string* Response::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Response.description)
  return _s;
}
inline const std::string& Response::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Response::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Response::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Response.description)
  return _impl_.description_.Release();
}
inline void Response::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Response.description)
}

// .gnostic.openapi.v3.HeadersOrReferences headers = 2;
inline bool Response::_internal_has_headers() const {
  return this != internal_default_instance() && _impl_.headers_ != nullptr;
}
inline bool Response::has_headers() const {
  return _internal_has_headers();
}
inline void Response::clear_headers() {
  if (GetArenaForAllocation() == nullptr && _impl_.headers_ != nullptr) {
    delete _impl_.headers_;
  }
  _impl_.headers_ = nullptr;
}
inline const ::gnostic::openapi::v3::HeadersOrReferences& Response::_internal_headers() const {
  const ::gnostic::openapi::v3::HeadersOrReferences* p = _impl_.headers_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::HeadersOrReferences&>(
      ::gnostic::openapi::v3::_HeadersOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::HeadersOrReferences& Response::headers() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Response.headers)
  return _internal_headers();
}
inline void Response::unsafe_arena_set_allocated_headers(
    ::gnostic::openapi::v3::HeadersOrReferences* headers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.headers_);
  }
  _impl_.headers_ = headers;
  if (headers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Response.headers)
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Response::release_headers() {
  
  ::gnostic::openapi::v3::HeadersOrReferences* temp = _impl_.headers_;
  _impl_.headers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Response::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Response.headers)
  
  ::gnostic::openapi::v3::HeadersOrReferences* temp = _impl_.headers_;
  _impl_.headers_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Response::_internal_mutable_headers() {
  
  if (_impl_.headers_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::HeadersOrReferences>(GetArenaForAllocation());
    _impl_.headers_ = p;
  }
  return _impl_.headers_;
}
inline ::gnostic::openapi::v3::HeadersOrReferences* Response::mutable_headers() {
  ::gnostic::openapi::v3::HeadersOrReferences* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Response.headers)
  return _msg;
}
inline void Response::set_allocated_headers(::gnostic::openapi::v3::HeadersOrReferences* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.headers_;
  }
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(headers);
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.headers_ = headers;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Response.headers)
}

// .gnostic.openapi.v3.MediaTypes content = 3;
inline bool Response::_internal_has_content() const {
  return this != internal_default_instance() && _impl_.content_ != nullptr;
}
inline bool Response::has_content() const {
  return _internal_has_content();
}
inline void Response::clear_content() {
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
}
inline const ::gnostic::openapi::v3::MediaTypes& Response::_internal_content() const {
  const ::gnostic::openapi::v3::MediaTypes* p = _impl_.content_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::MediaTypes&>(
      ::gnostic::openapi::v3::_MediaTypes_default_instance_);
}
inline const ::gnostic::openapi::v3::MediaTypes& Response::content() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Response.content)
  return _internal_content();
}
inline void Response::unsafe_arena_set_allocated_content(
    ::gnostic::openapi::v3::MediaTypes* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
  }
  _impl_.content_ = content;
  if (content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Response.content)
}
inline ::gnostic::openapi::v3::MediaTypes* Response::release_content() {
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* Response::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Response.content)
  
  ::gnostic::openapi::v3::MediaTypes* temp = _impl_.content_;
  _impl_.content_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::MediaTypes* Response::_internal_mutable_content() {
  
  if (_impl_.content_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::MediaTypes>(GetArenaForAllocation());
    _impl_.content_ = p;
  }
  return _impl_.content_;
}
inline ::gnostic::openapi::v3::MediaTypes* Response::mutable_content() {
  ::gnostic::openapi::v3::MediaTypes* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Response.content)
  return _msg;
}
inline void Response::set_allocated_content(::gnostic::openapi::v3::MediaTypes* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.content_ = content;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Response.content)
}

// .gnostic.openapi.v3.LinksOrReferences links = 4;
inline bool Response::_internal_has_links() const {
  return this != internal_default_instance() && _impl_.links_ != nullptr;
}
inline bool Response::has_links() const {
  return _internal_has_links();
}
inline void Response::clear_links() {
  if (GetArenaForAllocation() == nullptr && _impl_.links_ != nullptr) {
    delete _impl_.links_;
  }
  _impl_.links_ = nullptr;
}
inline const ::gnostic::openapi::v3::LinksOrReferences& Response::_internal_links() const {
  const ::gnostic::openapi::v3::LinksOrReferences* p = _impl_.links_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::LinksOrReferences&>(
      ::gnostic::openapi::v3::_LinksOrReferences_default_instance_);
}
inline const ::gnostic::openapi::v3::LinksOrReferences& Response::links() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Response.links)
  return _internal_links();
}
inline void Response::unsafe_arena_set_allocated_links(
    ::gnostic::openapi::v3::LinksOrReferences* links) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.links_);
  }
  _impl_.links_ = links;
  if (links) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Response.links)
}
inline ::gnostic::openapi::v3::LinksOrReferences* Response::release_links() {
  
  ::gnostic::openapi::v3::LinksOrReferences* temp = _impl_.links_;
  _impl_.links_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::LinksOrReferences* Response::unsafe_arena_release_links() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Response.links)
  
  ::gnostic::openapi::v3::LinksOrReferences* temp = _impl_.links_;
  _impl_.links_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::LinksOrReferences* Response::_internal_mutable_links() {
  
  if (_impl_.links_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::LinksOrReferences>(GetArenaForAllocation());
    _impl_.links_ = p;
  }
  return _impl_.links_;
}
inline ::gnostic::openapi::v3::LinksOrReferences* Response::mutable_links() {
  ::gnostic::openapi::v3::LinksOrReferences* _msg = _internal_mutable_links();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Response.links)
  return _msg;
}
inline void Response::set_allocated_links(::gnostic::openapi::v3::LinksOrReferences* links) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.links_;
  }
  if (links) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(links);
    if (message_arena != submessage_arena) {
      links = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, links, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.links_ = links;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Response.links)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 5;
inline int Response::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Response::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Response::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Response::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Response.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Response::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Response.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Response::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Response::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Response.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Response::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Response::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Response.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Response::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Response.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// ResponseOrReference

// .gnostic.openapi.v3.Response response = 1;
inline bool ResponseOrReference::_internal_has_response() const {
  return oneof_case() == kResponse;
}
inline bool ResponseOrReference::has_response() const {
  return _internal_has_response();
}
inline void ResponseOrReference::set_has_response() {
  _impl_._oneof_case_[0] = kResponse;
}
inline void ResponseOrReference::clear_response() {
  if (_internal_has_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.response_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Response* ResponseOrReference::release_response() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ResponseOrReference.response)
  if (_internal_has_response()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Response* temp = _impl_.oneof_.response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Response& ResponseOrReference::_internal_response() const {
  return _internal_has_response()
      ? *_impl_.oneof_.response_
      : reinterpret_cast< ::gnostic::openapi::v3::Response&>(::gnostic::openapi::v3::_Response_default_instance_);
}
inline const ::gnostic::openapi::v3::Response& ResponseOrReference::response() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ResponseOrReference.response)
  return _internal_response();
}
inline ::gnostic::openapi::v3::Response* ResponseOrReference::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.ResponseOrReference.response)
  if (_internal_has_response()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Response* temp = _impl_.oneof_.response_;
    _impl_.oneof_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseOrReference::unsafe_arena_set_allocated_response(::gnostic::openapi::v3::Response* response) {
  clear_oneof();
  if (response) {
    set_has_response();
    _impl_.oneof_.response_ = response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.ResponseOrReference.response)
}
inline ::gnostic::openapi::v3::Response* ResponseOrReference::_internal_mutable_response() {
  if (!_internal_has_response()) {
    clear_oneof();
    set_has_response();
    _impl_.oneof_.response_ = CreateMaybeMessage< ::gnostic::openapi::v3::Response >(GetArenaForAllocation());
  }
  return _impl_.oneof_.response_;
}
inline ::gnostic::openapi::v3::Response* ResponseOrReference::mutable_response() {
  ::gnostic::openapi::v3::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ResponseOrReference.response)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool ResponseOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool ResponseOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void ResponseOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void ResponseOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* ResponseOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ResponseOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& ResponseOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& ResponseOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ResponseOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* ResponseOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.ResponseOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.ResponseOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* ResponseOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* ResponseOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ResponseOrReference.reference)
  return _msg;
}

inline bool ResponseOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void ResponseOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline ResponseOrReference::OneofCase ResponseOrReference::oneof_case() const {
  return ResponseOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Responses

// .gnostic.openapi.v3.ResponseOrReference default = 1;
inline bool Responses::_internal_has_default_() const {
  return this != internal_default_instance() && _impl_.default__ != nullptr;
}
inline bool Responses::has_default_() const {
  return _internal_has_default_();
}
inline void Responses::clear_default_() {
  if (GetArenaForAllocation() == nullptr && _impl_.default__ != nullptr) {
    delete _impl_.default__;
  }
  _impl_.default__ = nullptr;
}
inline const ::gnostic::openapi::v3::ResponseOrReference& Responses::_internal_default_() const {
  const ::gnostic::openapi::v3::ResponseOrReference* p = _impl_.default__;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ResponseOrReference&>(
      ::gnostic::openapi::v3::_ResponseOrReference_default_instance_);
}
inline const ::gnostic::openapi::v3::ResponseOrReference& Responses::default_() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Responses.default)
  return _internal_default_();
}
inline void Responses::unsafe_arena_set_allocated_default_(
    ::gnostic::openapi::v3::ResponseOrReference* default_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default__);
  }
  _impl_.default__ = default_;
  if (default_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Responses.default)
}
inline ::gnostic::openapi::v3::ResponseOrReference* Responses::release_default_() {
  
  ::gnostic::openapi::v3::ResponseOrReference* temp = _impl_.default__;
  _impl_.default__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ResponseOrReference* Responses::unsafe_arena_release_default_() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Responses.default)
  
  ::gnostic::openapi::v3::ResponseOrReference* temp = _impl_.default__;
  _impl_.default__ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ResponseOrReference* Responses::_internal_mutable_default_() {
  
  if (_impl_.default__ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ResponseOrReference>(GetArenaForAllocation());
    _impl_.default__ = p;
  }
  return _impl_.default__;
}
inline ::gnostic::openapi::v3::ResponseOrReference* Responses::mutable_default_() {
  ::gnostic::openapi::v3::ResponseOrReference* _msg = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Responses.default)
  return _msg;
}
inline void Responses::set_allocated_default_(::gnostic::openapi::v3::ResponseOrReference* default_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default__;
  }
  if (default_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_);
    if (message_arena != submessage_arena) {
      default_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default__ = default_;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Responses.default)
}

// repeated .gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2;
inline int Responses::_internal_response_or_reference_size() const {
  return _impl_.response_or_reference_.size();
}
inline int Responses::response_or_reference_size() const {
  return _internal_response_or_reference_size();
}
inline void Responses::clear_response_or_reference() {
  _impl_.response_or_reference_.Clear();
}
inline ::gnostic::openapi::v3::NamedResponseOrReference* Responses::mutable_response_or_reference(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Responses.response_or_reference)
  return _impl_.response_or_reference_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >*
Responses::mutable_response_or_reference() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Responses.response_or_reference)
  return &_impl_.response_or_reference_;
}
inline const ::gnostic::openapi::v3::NamedResponseOrReference& Responses::_internal_response_or_reference(int index) const {
  return _impl_.response_or_reference_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedResponseOrReference& Responses::response_or_reference(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Responses.response_or_reference)
  return _internal_response_or_reference(index);
}
inline ::gnostic::openapi::v3::NamedResponseOrReference* Responses::_internal_add_response_or_reference() {
  return _impl_.response_or_reference_.Add();
}
inline ::gnostic::openapi::v3::NamedResponseOrReference* Responses::add_response_or_reference() {
  ::gnostic::openapi::v3::NamedResponseOrReference* _add = _internal_add_response_or_reference();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Responses.response_or_reference)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >&
Responses::response_or_reference() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Responses.response_or_reference)
  return _impl_.response_or_reference_;
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 3;
inline int Responses::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Responses::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Responses::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Responses::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Responses.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Responses::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Responses.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Responses::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Responses::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Responses.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Responses::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Responses::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Responses.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Responses::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Responses.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// ResponsesOrReferences

// repeated .gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1;
inline int ResponsesOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int ResponsesOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void ResponsesOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedResponseOrReference* ResponsesOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ResponsesOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >*
ResponsesOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ResponsesOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedResponseOrReference& ResponsesOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedResponseOrReference& ResponsesOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ResponsesOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedResponseOrReference* ResponsesOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedResponseOrReference* ResponsesOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedResponseOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ResponsesOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedResponseOrReference >&
ResponsesOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ResponsesOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Schema

// bool nullable = 1;
inline void Schema::clear_nullable() {
  _impl_.nullable_ = false;
}
inline bool Schema::_internal_nullable() const {
  return _impl_.nullable_;
}
inline bool Schema::nullable() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.nullable)
  return _internal_nullable();
}
inline void Schema::_internal_set_nullable(bool value) {
  
  _impl_.nullable_ = value;
}
inline void Schema::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.nullable)
}

// .gnostic.openapi.v3.Discriminator discriminator = 2;
inline bool Schema::_internal_has_discriminator() const {
  return this != internal_default_instance() && _impl_.discriminator_ != nullptr;
}
inline bool Schema::has_discriminator() const {
  return _internal_has_discriminator();
}
inline void Schema::clear_discriminator() {
  if (GetArenaForAllocation() == nullptr && _impl_.discriminator_ != nullptr) {
    delete _impl_.discriminator_;
  }
  _impl_.discriminator_ = nullptr;
}
inline const ::gnostic::openapi::v3::Discriminator& Schema::_internal_discriminator() const {
  const ::gnostic::openapi::v3::Discriminator* p = _impl_.discriminator_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Discriminator&>(
      ::gnostic::openapi::v3::_Discriminator_default_instance_);
}
inline const ::gnostic::openapi::v3::Discriminator& Schema::discriminator() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.discriminator)
  return _internal_discriminator();
}
inline void Schema::unsafe_arena_set_allocated_discriminator(
    ::gnostic::openapi::v3::Discriminator* discriminator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.discriminator_);
  }
  _impl_.discriminator_ = discriminator;
  if (discriminator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.discriminator)
}
inline ::gnostic::openapi::v3::Discriminator* Schema::release_discriminator() {
  
  ::gnostic::openapi::v3::Discriminator* temp = _impl_.discriminator_;
  _impl_.discriminator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Discriminator* Schema::unsafe_arena_release_discriminator() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.discriminator)
  
  ::gnostic::openapi::v3::Discriminator* temp = _impl_.discriminator_;
  _impl_.discriminator_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Discriminator* Schema::_internal_mutable_discriminator() {
  
  if (_impl_.discriminator_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Discriminator>(GetArenaForAllocation());
    _impl_.discriminator_ = p;
  }
  return _impl_.discriminator_;
}
inline ::gnostic::openapi::v3::Discriminator* Schema::mutable_discriminator() {
  ::gnostic::openapi::v3::Discriminator* _msg = _internal_mutable_discriminator();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.discriminator)
  return _msg;
}
inline void Schema::set_allocated_discriminator(::gnostic::openapi::v3::Discriminator* discriminator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.discriminator_;
  }
  if (discriminator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(discriminator);
    if (message_arena != submessage_arena) {
      discriminator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, discriminator, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.discriminator_ = discriminator;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.discriminator)
}

// bool read_only = 3;
inline void Schema::clear_read_only() {
  _impl_.read_only_ = false;
}
inline bool Schema::_internal_read_only() const {
  return _impl_.read_only_;
}
inline bool Schema::read_only() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.read_only)
  return _internal_read_only();
}
inline void Schema::_internal_set_read_only(bool value) {
  
  _impl_.read_only_ = value;
}
inline void Schema::set_read_only(bool value) {
  _internal_set_read_only(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.read_only)
}

// bool write_only = 4;
inline void Schema::clear_write_only() {
  _impl_.write_only_ = false;
}
inline bool Schema::_internal_write_only() const {
  return _impl_.write_only_;
}
inline bool Schema::write_only() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.write_only)
  return _internal_write_only();
}
inline void Schema::_internal_set_write_only(bool value) {
  
  _impl_.write_only_ = value;
}
inline void Schema::set_write_only(bool value) {
  _internal_set_write_only(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.write_only)
}

// .gnostic.openapi.v3.Xml xml = 5;
inline bool Schema::_internal_has_xml() const {
  return this != internal_default_instance() && _impl_.xml_ != nullptr;
}
inline bool Schema::has_xml() const {
  return _internal_has_xml();
}
inline void Schema::clear_xml() {
  if (GetArenaForAllocation() == nullptr && _impl_.xml_ != nullptr) {
    delete _impl_.xml_;
  }
  _impl_.xml_ = nullptr;
}
inline const ::gnostic::openapi::v3::Xml& Schema::_internal_xml() const {
  const ::gnostic::openapi::v3::Xml* p = _impl_.xml_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Xml&>(
      ::gnostic::openapi::v3::_Xml_default_instance_);
}
inline const ::gnostic::openapi::v3::Xml& Schema::xml() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.xml)
  return _internal_xml();
}
inline void Schema::unsafe_arena_set_allocated_xml(
    ::gnostic::openapi::v3::Xml* xml) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.xml_);
  }
  _impl_.xml_ = xml;
  if (xml) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.xml)
}
inline ::gnostic::openapi::v3::Xml* Schema::release_xml() {
  
  ::gnostic::openapi::v3::Xml* temp = _impl_.xml_;
  _impl_.xml_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Xml* Schema::unsafe_arena_release_xml() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.xml)
  
  ::gnostic::openapi::v3::Xml* temp = _impl_.xml_;
  _impl_.xml_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Xml* Schema::_internal_mutable_xml() {
  
  if (_impl_.xml_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Xml>(GetArenaForAllocation());
    _impl_.xml_ = p;
  }
  return _impl_.xml_;
}
inline ::gnostic::openapi::v3::Xml* Schema::mutable_xml() {
  ::gnostic::openapi::v3::Xml* _msg = _internal_mutable_xml();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.xml)
  return _msg;
}
inline void Schema::set_allocated_xml(::gnostic::openapi::v3::Xml* xml) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.xml_;
  }
  if (xml) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(xml);
    if (message_arena != submessage_arena) {
      xml = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xml, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.xml_ = xml;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.xml)
}

// .gnostic.openapi.v3.ExternalDocs external_docs = 6;
inline bool Schema::_internal_has_external_docs() const {
  return this != internal_default_instance() && _impl_.external_docs_ != nullptr;
}
inline bool Schema::has_external_docs() const {
  return _internal_has_external_docs();
}
inline void Schema::clear_external_docs() {
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExternalDocs& Schema::_internal_external_docs() const {
  const ::gnostic::openapi::v3::ExternalDocs* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExternalDocs&>(
      ::gnostic::openapi::v3::_ExternalDocs_default_instance_);
}
inline const ::gnostic::openapi::v3::ExternalDocs& Schema::external_docs() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.external_docs)
  return _internal_external_docs();
}
inline void Schema::unsafe_arena_set_allocated_external_docs(
    ::gnostic::openapi::v3::ExternalDocs* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.external_docs)
}
inline ::gnostic::openapi::v3::ExternalDocs* Schema::release_external_docs() {
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Schema::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.external_docs)
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Schema::_internal_mutable_external_docs() {
  
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExternalDocs>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::gnostic::openapi::v3::ExternalDocs* Schema::mutable_external_docs() {
  ::gnostic::openapi::v3::ExternalDocs* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.external_docs)
  return _msg;
}
inline void Schema::set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.external_docs)
}

// .gnostic.openapi.v3.Any example = 7;
inline bool Schema::_internal_has_example() const {
  return this != internal_default_instance() && _impl_.example_ != nullptr;
}
inline bool Schema::has_example() const {
  return _internal_has_example();
}
inline void Schema::clear_example() {
  if (GetArenaForAllocation() == nullptr && _impl_.example_ != nullptr) {
    delete _impl_.example_;
  }
  _impl_.example_ = nullptr;
}
inline const ::gnostic::openapi::v3::Any& Schema::_internal_example() const {
  const ::gnostic::openapi::v3::Any* p = _impl_.example_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Any&>(
      ::gnostic::openapi::v3::_Any_default_instance_);
}
inline const ::gnostic::openapi::v3::Any& Schema::example() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.example)
  return _internal_example();
}
inline void Schema::unsafe_arena_set_allocated_example(
    ::gnostic::openapi::v3::Any* example) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.example_);
  }
  _impl_.example_ = example;
  if (example) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.example)
}
inline ::gnostic::openapi::v3::Any* Schema::release_example() {
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Any* Schema::unsafe_arena_release_example() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.example)
  
  ::gnostic::openapi::v3::Any* temp = _impl_.example_;
  _impl_.example_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Any* Schema::_internal_mutable_example() {
  
  if (_impl_.example_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Any>(GetArenaForAllocation());
    _impl_.example_ = p;
  }
  return _impl_.example_;
}
inline ::gnostic::openapi::v3::Any* Schema::mutable_example() {
  ::gnostic::openapi::v3::Any* _msg = _internal_mutable_example();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.example)
  return _msg;
}
inline void Schema::set_allocated_example(::gnostic::openapi::v3::Any* example) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.example_;
  }
  if (example) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(example);
    if (message_arena != submessage_arena) {
      example = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, example, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.example_ = example;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.example)
}

// bool deprecated = 8;
inline void Schema::clear_deprecated() {
  _impl_.deprecated_ = false;
}
inline bool Schema::_internal_deprecated() const {
  return _impl_.deprecated_;
}
inline bool Schema::deprecated() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.deprecated)
  return _internal_deprecated();
}
inline void Schema::_internal_set_deprecated(bool value) {
  
  _impl_.deprecated_ = value;
}
inline void Schema::set_deprecated(bool value) {
  _internal_set_deprecated(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.deprecated)
}

// string title = 9;
inline void Schema::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Schema::title() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.title)
}
inline std::string* Schema::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.title)
  return _s;
}
inline const std::string& Schema::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Schema::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_title() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.title)
  return _impl_.title_.Release();
}
inline void Schema::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.title)
}

// double multiple_of = 10;
inline void Schema::clear_multiple_of() {
  _impl_.multiple_of_ = 0;
}
inline double Schema::_internal_multiple_of() const {
  return _impl_.multiple_of_;
}
inline double Schema::multiple_of() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.multiple_of)
  return _internal_multiple_of();
}
inline void Schema::_internal_set_multiple_of(double value) {
  
  _impl_.multiple_of_ = value;
}
inline void Schema::set_multiple_of(double value) {
  _internal_set_multiple_of(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.multiple_of)
}

// double maximum = 11;
inline void Schema::clear_maximum() {
  _impl_.maximum_ = 0;
}
inline double Schema::_internal_maximum() const {
  return _impl_.maximum_;
}
inline double Schema::maximum() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.maximum)
  return _internal_maximum();
}
inline void Schema::_internal_set_maximum(double value) {
  
  _impl_.maximum_ = value;
}
inline void Schema::set_maximum(double value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.maximum)
}

// bool exclusive_maximum = 12;
inline void Schema::clear_exclusive_maximum() {
  _impl_.exclusive_maximum_ = false;
}
inline bool Schema::_internal_exclusive_maximum() const {
  return _impl_.exclusive_maximum_;
}
inline bool Schema::exclusive_maximum() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.exclusive_maximum)
  return _internal_exclusive_maximum();
}
inline void Schema::_internal_set_exclusive_maximum(bool value) {
  
  _impl_.exclusive_maximum_ = value;
}
inline void Schema::set_exclusive_maximum(bool value) {
  _internal_set_exclusive_maximum(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.exclusive_maximum)
}

// double minimum = 13;
inline void Schema::clear_minimum() {
  _impl_.minimum_ = 0;
}
inline double Schema::_internal_minimum() const {
  return _impl_.minimum_;
}
inline double Schema::minimum() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.minimum)
  return _internal_minimum();
}
inline void Schema::_internal_set_minimum(double value) {
  
  _impl_.minimum_ = value;
}
inline void Schema::set_minimum(double value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.minimum)
}

// bool exclusive_minimum = 14;
inline void Schema::clear_exclusive_minimum() {
  _impl_.exclusive_minimum_ = false;
}
inline bool Schema::_internal_exclusive_minimum() const {
  return _impl_.exclusive_minimum_;
}
inline bool Schema::exclusive_minimum() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.exclusive_minimum)
  return _internal_exclusive_minimum();
}
inline void Schema::_internal_set_exclusive_minimum(bool value) {
  
  _impl_.exclusive_minimum_ = value;
}
inline void Schema::set_exclusive_minimum(bool value) {
  _internal_set_exclusive_minimum(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.exclusive_minimum)
}

// int64 max_length = 15;
inline void Schema::clear_max_length() {
  _impl_.max_length_ = int64_t{0};
}
inline int64_t Schema::_internal_max_length() const {
  return _impl_.max_length_;
}
inline int64_t Schema::max_length() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.max_length)
  return _internal_max_length();
}
inline void Schema::_internal_set_max_length(int64_t value) {
  
  _impl_.max_length_ = value;
}
inline void Schema::set_max_length(int64_t value) {
  _internal_set_max_length(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.max_length)
}

// int64 min_length = 16;
inline void Schema::clear_min_length() {
  _impl_.min_length_ = int64_t{0};
}
inline int64_t Schema::_internal_min_length() const {
  return _impl_.min_length_;
}
inline int64_t Schema::min_length() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.min_length)
  return _internal_min_length();
}
inline void Schema::_internal_set_min_length(int64_t value) {
  
  _impl_.min_length_ = value;
}
inline void Schema::set_min_length(int64_t value) {
  _internal_set_min_length(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.min_length)
}

// string pattern = 17;
inline void Schema::clear_pattern() {
  _impl_.pattern_.ClearToEmpty();
}
inline const std::string& Schema::pattern() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.pattern)
  return _internal_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_pattern(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pattern_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.pattern)
}
inline std::string* Schema::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.pattern)
  return _s;
}
inline const std::string& Schema::_internal_pattern() const {
  return _impl_.pattern_.Get();
}
inline void Schema::_internal_set_pattern(const std::string& value) {
  
  _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_pattern() {
  
  return _impl_.pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_pattern() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.pattern)
  return _impl_.pattern_.Release();
}
inline void Schema::set_allocated_pattern(std::string* pattern) {
  if (pattern != nullptr) {
    
  } else {
    
  }
  _impl_.pattern_.SetAllocated(pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pattern_.IsDefault()) {
    _impl_.pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.pattern)
}

// int64 max_items = 18;
inline void Schema::clear_max_items() {
  _impl_.max_items_ = int64_t{0};
}
inline int64_t Schema::_internal_max_items() const {
  return _impl_.max_items_;
}
inline int64_t Schema::max_items() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.max_items)
  return _internal_max_items();
}
inline void Schema::_internal_set_max_items(int64_t value) {
  
  _impl_.max_items_ = value;
}
inline void Schema::set_max_items(int64_t value) {
  _internal_set_max_items(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.max_items)
}

// int64 min_items = 19;
inline void Schema::clear_min_items() {
  _impl_.min_items_ = int64_t{0};
}
inline int64_t Schema::_internal_min_items() const {
  return _impl_.min_items_;
}
inline int64_t Schema::min_items() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.min_items)
  return _internal_min_items();
}
inline void Schema::_internal_set_min_items(int64_t value) {
  
  _impl_.min_items_ = value;
}
inline void Schema::set_min_items(int64_t value) {
  _internal_set_min_items(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.min_items)
}

// bool unique_items = 20;
inline void Schema::clear_unique_items() {
  _impl_.unique_items_ = false;
}
inline bool Schema::_internal_unique_items() const {
  return _impl_.unique_items_;
}
inline bool Schema::unique_items() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.unique_items)
  return _internal_unique_items();
}
inline void Schema::_internal_set_unique_items(bool value) {
  
  _impl_.unique_items_ = value;
}
inline void Schema::set_unique_items(bool value) {
  _internal_set_unique_items(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.unique_items)
}

// int64 max_properties = 21;
inline void Schema::clear_max_properties() {
  _impl_.max_properties_ = int64_t{0};
}
inline int64_t Schema::_internal_max_properties() const {
  return _impl_.max_properties_;
}
inline int64_t Schema::max_properties() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.max_properties)
  return _internal_max_properties();
}
inline void Schema::_internal_set_max_properties(int64_t value) {
  
  _impl_.max_properties_ = value;
}
inline void Schema::set_max_properties(int64_t value) {
  _internal_set_max_properties(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.max_properties)
}

// int64 min_properties = 22;
inline void Schema::clear_min_properties() {
  _impl_.min_properties_ = int64_t{0};
}
inline int64_t Schema::_internal_min_properties() const {
  return _impl_.min_properties_;
}
inline int64_t Schema::min_properties() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.min_properties)
  return _internal_min_properties();
}
inline void Schema::_internal_set_min_properties(int64_t value) {
  
  _impl_.min_properties_ = value;
}
inline void Schema::set_min_properties(int64_t value) {
  _internal_set_min_properties(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.min_properties)
}

// repeated string required = 23;
inline int Schema::_internal_required_size() const {
  return _impl_.required_.size();
}
inline int Schema::required_size() const {
  return _internal_required_size();
}
inline void Schema::clear_required() {
  _impl_.required_.Clear();
}
inline std::string* Schema::add_required() {
  std::string* _s = _internal_add_required();
  // @@protoc_insertion_point(field_add_mutable:gnostic.openapi.v3.Schema.required)
  return _s;
}
inline const std::string& Schema::_internal_required(int index) const {
  return _impl_.required_.Get(index);
}
inline const std::string& Schema::required(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.required)
  return _internal_required(index);
}
inline std::string* Schema::mutable_required(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.required)
  return _impl_.required_.Mutable(index);
}
inline void Schema::set_required(int index, const std::string& value) {
  _impl_.required_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.required)
}
inline void Schema::set_required(int index, std::string&& value) {
  _impl_.required_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.required)
}
inline void Schema::set_required(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gnostic.openapi.v3.Schema.required)
}
inline void Schema::set_required(int index, const char* value, size_t size) {
  _impl_.required_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnostic.openapi.v3.Schema.required)
}
inline std::string* Schema::_internal_add_required() {
  return _impl_.required_.Add();
}
inline void Schema::add_required(const std::string& value) {
  _impl_.required_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Schema.required)
}
inline void Schema::add_required(std::string&& value) {
  _impl_.required_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Schema.required)
}
inline void Schema::add_required(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gnostic.openapi.v3.Schema.required)
}
inline void Schema::add_required(const char* value, size_t size) {
  _impl_.required_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gnostic.openapi.v3.Schema.required)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Schema::required() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Schema.required)
  return _impl_.required_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Schema::mutable_required() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Schema.required)
  return &_impl_.required_;
}

// repeated .gnostic.openapi.v3.Any enum = 24;
inline int Schema::_internal_enum__size() const {
  return _impl_.enum__.size();
}
inline int Schema::enum__size() const {
  return _internal_enum__size();
}
inline void Schema::clear_enum_() {
  _impl_.enum__.Clear();
}
inline ::gnostic::openapi::v3::Any* Schema::mutable_enum_(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.enum)
  return _impl_.enum__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Any >*
Schema::mutable_enum_() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Schema.enum)
  return &_impl_.enum__;
}
inline const ::gnostic::openapi::v3::Any& Schema::_internal_enum_(int index) const {
  return _impl_.enum__.Get(index);
}
inline const ::gnostic::openapi::v3::Any& Schema::enum_(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.enum)
  return _internal_enum_(index);
}
inline ::gnostic::openapi::v3::Any* Schema::_internal_add_enum_() {
  return _impl_.enum__.Add();
}
inline ::gnostic::openapi::v3::Any* Schema::add_enum_() {
  ::gnostic::openapi::v3::Any* _add = _internal_add_enum_();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Schema.enum)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::Any >&
Schema::enum_() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Schema.enum)
  return _impl_.enum__;
}

// string type = 25;
inline void Schema::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Schema::type() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.type)
}
inline std::string* Schema::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.type)
  return _s;
}
inline const std::string& Schema::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Schema::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_type() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.type)
  return _impl_.type_.Release();
}
inline void Schema::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.type)
}

// repeated .gnostic.openapi.v3.SchemaOrReference all_of = 26;
inline int Schema::_internal_all_of_size() const {
  return _impl_.all_of_.size();
}
inline int Schema::all_of_size() const {
  return _internal_all_of_size();
}
inline void Schema::clear_all_of() {
  _impl_.all_of_.Clear();
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::mutable_all_of(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.all_of)
  return _impl_.all_of_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
Schema::mutable_all_of() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Schema.all_of)
  return &_impl_.all_of_;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Schema::_internal_all_of(int index) const {
  return _impl_.all_of_.Get(index);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Schema::all_of(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.all_of)
  return _internal_all_of(index);
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::_internal_add_all_of() {
  return _impl_.all_of_.Add();
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::add_all_of() {
  ::gnostic::openapi::v3::SchemaOrReference* _add = _internal_add_all_of();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Schema.all_of)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
Schema::all_of() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Schema.all_of)
  return _impl_.all_of_;
}

// repeated .gnostic.openapi.v3.SchemaOrReference one_of = 27;
inline int Schema::_internal_one_of_size() const {
  return _impl_.one_of_.size();
}
inline int Schema::one_of_size() const {
  return _internal_one_of_size();
}
inline void Schema::clear_one_of() {
  _impl_.one_of_.Clear();
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::mutable_one_of(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.one_of)
  return _impl_.one_of_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
Schema::mutable_one_of() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Schema.one_of)
  return &_impl_.one_of_;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Schema::_internal_one_of(int index) const {
  return _impl_.one_of_.Get(index);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Schema::one_of(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.one_of)
  return _internal_one_of(index);
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::_internal_add_one_of() {
  return _impl_.one_of_.Add();
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::add_one_of() {
  ::gnostic::openapi::v3::SchemaOrReference* _add = _internal_add_one_of();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Schema.one_of)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
Schema::one_of() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Schema.one_of)
  return _impl_.one_of_;
}

// repeated .gnostic.openapi.v3.SchemaOrReference any_of = 28;
inline int Schema::_internal_any_of_size() const {
  return _impl_.any_of_.size();
}
inline int Schema::any_of_size() const {
  return _internal_any_of_size();
}
inline void Schema::clear_any_of() {
  _impl_.any_of_.Clear();
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::mutable_any_of(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.any_of)
  return _impl_.any_of_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >*
Schema::mutable_any_of() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Schema.any_of)
  return &_impl_.any_of_;
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Schema::_internal_any_of(int index) const {
  return _impl_.any_of_.Get(index);
}
inline const ::gnostic::openapi::v3::SchemaOrReference& Schema::any_of(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.any_of)
  return _internal_any_of(index);
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::_internal_add_any_of() {
  return _impl_.any_of_.Add();
}
inline ::gnostic::openapi::v3::SchemaOrReference* Schema::add_any_of() {
  ::gnostic::openapi::v3::SchemaOrReference* _add = _internal_add_any_of();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Schema.any_of)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::SchemaOrReference >&
Schema::any_of() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Schema.any_of)
  return _impl_.any_of_;
}

// .gnostic.openapi.v3.Schema not = 29;
inline bool Schema::_internal_has_not_() const {
  return this != internal_default_instance() && _impl_.not__ != nullptr;
}
inline bool Schema::has_not_() const {
  return _internal_has_not_();
}
inline void Schema::clear_not_() {
  if (GetArenaForAllocation() == nullptr && _impl_.not__ != nullptr) {
    delete _impl_.not__;
  }
  _impl_.not__ = nullptr;
}
inline const ::gnostic::openapi::v3::Schema& Schema::_internal_not_() const {
  const ::gnostic::openapi::v3::Schema* p = _impl_.not__;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Schema&>(
      ::gnostic::openapi::v3::_Schema_default_instance_);
}
inline const ::gnostic::openapi::v3::Schema& Schema::not_() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.not)
  return _internal_not_();
}
inline void Schema::unsafe_arena_set_allocated_not_(
    ::gnostic::openapi::v3::Schema* not_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.not__);
  }
  _impl_.not__ = not_;
  if (not_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.not)
}
inline ::gnostic::openapi::v3::Schema* Schema::release_not_() {
  
  ::gnostic::openapi::v3::Schema* temp = _impl_.not__;
  _impl_.not__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Schema* Schema::unsafe_arena_release_not_() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.not)
  
  ::gnostic::openapi::v3::Schema* temp = _impl_.not__;
  _impl_.not__ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Schema* Schema::_internal_mutable_not_() {
  
  if (_impl_.not__ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Schema>(GetArenaForAllocation());
    _impl_.not__ = p;
  }
  return _impl_.not__;
}
inline ::gnostic::openapi::v3::Schema* Schema::mutable_not_() {
  ::gnostic::openapi::v3::Schema* _msg = _internal_mutable_not_();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.not)
  return _msg;
}
inline void Schema::set_allocated_not_(::gnostic::openapi::v3::Schema* not_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.not__;
  }
  if (not_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(not_);
    if (message_arena != submessage_arena) {
      not_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, not_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.not__ = not_;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.not)
}

// .gnostic.openapi.v3.ItemsItem items = 30;
inline bool Schema::_internal_has_items() const {
  return this != internal_default_instance() && _impl_.items_ != nullptr;
}
inline bool Schema::has_items() const {
  return _internal_has_items();
}
inline void Schema::clear_items() {
  if (GetArenaForAllocation() == nullptr && _impl_.items_ != nullptr) {
    delete _impl_.items_;
  }
  _impl_.items_ = nullptr;
}
inline const ::gnostic::openapi::v3::ItemsItem& Schema::_internal_items() const {
  const ::gnostic::openapi::v3::ItemsItem* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ItemsItem&>(
      ::gnostic::openapi::v3::_ItemsItem_default_instance_);
}
inline const ::gnostic::openapi::v3::ItemsItem& Schema::items() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.items)
  return _internal_items();
}
inline void Schema::unsafe_arena_set_allocated_items(
    ::gnostic::openapi::v3::ItemsItem* items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = items;
  if (items) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.items)
}
inline ::gnostic::openapi::v3::ItemsItem* Schema::release_items() {
  
  ::gnostic::openapi::v3::ItemsItem* temp = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ItemsItem* Schema::unsafe_arena_release_items() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.items)
  
  ::gnostic::openapi::v3::ItemsItem* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ItemsItem* Schema::_internal_mutable_items() {
  
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ItemsItem>(GetArenaForAllocation());
    _impl_.items_ = p;
  }
  return _impl_.items_;
}
inline ::gnostic::openapi::v3::ItemsItem* Schema::mutable_items() {
  ::gnostic::openapi::v3::ItemsItem* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.items)
  return _msg;
}
inline void Schema::set_allocated_items(::gnostic::openapi::v3::ItemsItem* items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.items_;
  }
  if (items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(items);
    if (message_arena != submessage_arena) {
      items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.items_ = items;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.items)
}

// .gnostic.openapi.v3.Properties properties = 31;
inline bool Schema::_internal_has_properties() const {
  return this != internal_default_instance() && _impl_.properties_ != nullptr;
}
inline bool Schema::has_properties() const {
  return _internal_has_properties();
}
inline void Schema::clear_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.properties_ != nullptr) {
    delete _impl_.properties_;
  }
  _impl_.properties_ = nullptr;
}
inline const ::gnostic::openapi::v3::Properties& Schema::_internal_properties() const {
  const ::gnostic::openapi::v3::Properties* p = _impl_.properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::Properties&>(
      ::gnostic::openapi::v3::_Properties_default_instance_);
}
inline const ::gnostic::openapi::v3::Properties& Schema::properties() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.properties)
  return _internal_properties();
}
inline void Schema::unsafe_arena_set_allocated_properties(
    ::gnostic::openapi::v3::Properties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  _impl_.properties_ = properties;
  if (properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.properties)
}
inline ::gnostic::openapi::v3::Properties* Schema::release_properties() {
  
  ::gnostic::openapi::v3::Properties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::Properties* Schema::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.properties)
  
  ::gnostic::openapi::v3::Properties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::Properties* Schema::_internal_mutable_properties() {
  
  if (_impl_.properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::Properties>(GetArenaForAllocation());
    _impl_.properties_ = p;
  }
  return _impl_.properties_;
}
inline ::gnostic::openapi::v3::Properties* Schema::mutable_properties() {
  ::gnostic::openapi::v3::Properties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.properties)
  return _msg;
}
inline void Schema::set_allocated_properties(::gnostic::openapi::v3::Properties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.properties_;
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(properties);
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.properties)
}

// .gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32;
inline bool Schema::_internal_has_additional_properties() const {
  return this != internal_default_instance() && _impl_.additional_properties_ != nullptr;
}
inline bool Schema::has_additional_properties() const {
  return _internal_has_additional_properties();
}
inline void Schema::clear_additional_properties() {
  if (GetArenaForAllocation() == nullptr && _impl_.additional_properties_ != nullptr) {
    delete _impl_.additional_properties_;
  }
  _impl_.additional_properties_ = nullptr;
}
inline const ::gnostic::openapi::v3::AdditionalPropertiesItem& Schema::_internal_additional_properties() const {
  const ::gnostic::openapi::v3::AdditionalPropertiesItem* p = _impl_.additional_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::AdditionalPropertiesItem&>(
      ::gnostic::openapi::v3::_AdditionalPropertiesItem_default_instance_);
}
inline const ::gnostic::openapi::v3::AdditionalPropertiesItem& Schema::additional_properties() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.additional_properties)
  return _internal_additional_properties();
}
inline void Schema::unsafe_arena_set_allocated_additional_properties(
    ::gnostic::openapi::v3::AdditionalPropertiesItem* additional_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.additional_properties_);
  }
  _impl_.additional_properties_ = additional_properties;
  if (additional_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.additional_properties)
}
inline ::gnostic::openapi::v3::AdditionalPropertiesItem* Schema::release_additional_properties() {
  
  ::gnostic::openapi::v3::AdditionalPropertiesItem* temp = _impl_.additional_properties_;
  _impl_.additional_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::AdditionalPropertiesItem* Schema::unsafe_arena_release_additional_properties() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.additional_properties)
  
  ::gnostic::openapi::v3::AdditionalPropertiesItem* temp = _impl_.additional_properties_;
  _impl_.additional_properties_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::AdditionalPropertiesItem* Schema::_internal_mutable_additional_properties() {
  
  if (_impl_.additional_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::AdditionalPropertiesItem>(GetArenaForAllocation());
    _impl_.additional_properties_ = p;
  }
  return _impl_.additional_properties_;
}
inline ::gnostic::openapi::v3::AdditionalPropertiesItem* Schema::mutable_additional_properties() {
  ::gnostic::openapi::v3::AdditionalPropertiesItem* _msg = _internal_mutable_additional_properties();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.additional_properties)
  return _msg;
}
inline void Schema::set_allocated_additional_properties(::gnostic::openapi::v3::AdditionalPropertiesItem* additional_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.additional_properties_;
  }
  if (additional_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(additional_properties);
    if (message_arena != submessage_arena) {
      additional_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, additional_properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.additional_properties_ = additional_properties;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.additional_properties)
}

// .gnostic.openapi.v3.DefaultType default = 33;
inline bool Schema::_internal_has_default_() const {
  return this != internal_default_instance() && _impl_.default__ != nullptr;
}
inline bool Schema::has_default_() const {
  return _internal_has_default_();
}
inline void Schema::clear_default_() {
  if (GetArenaForAllocation() == nullptr && _impl_.default__ != nullptr) {
    delete _impl_.default__;
  }
  _impl_.default__ = nullptr;
}
inline const ::gnostic::openapi::v3::DefaultType& Schema::_internal_default_() const {
  const ::gnostic::openapi::v3::DefaultType* p = _impl_.default__;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::DefaultType&>(
      ::gnostic::openapi::v3::_DefaultType_default_instance_);
}
inline const ::gnostic::openapi::v3::DefaultType& Schema::default_() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.default)
  return _internal_default_();
}
inline void Schema::unsafe_arena_set_allocated_default_(
    ::gnostic::openapi::v3::DefaultType* default_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default__);
  }
  _impl_.default__ = default_;
  if (default_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Schema.default)
}
inline ::gnostic::openapi::v3::DefaultType* Schema::release_default_() {
  
  ::gnostic::openapi::v3::DefaultType* temp = _impl_.default__;
  _impl_.default__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::DefaultType* Schema::unsafe_arena_release_default_() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.default)
  
  ::gnostic::openapi::v3::DefaultType* temp = _impl_.default__;
  _impl_.default__ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::DefaultType* Schema::_internal_mutable_default_() {
  
  if (_impl_.default__ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::DefaultType>(GetArenaForAllocation());
    _impl_.default__ = p;
  }
  return _impl_.default__;
}
inline ::gnostic::openapi::v3::DefaultType* Schema::mutable_default_() {
  ::gnostic::openapi::v3::DefaultType* _msg = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.default)
  return _msg;
}
inline void Schema::set_allocated_default_(::gnostic::openapi::v3::DefaultType* default_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default__;
  }
  if (default_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_);
    if (message_arena != submessage_arena) {
      default_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default__ = default_;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.default)
}

// string description = 34;
inline void Schema::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Schema::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.description)
}
inline std::string* Schema::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.description)
  return _s;
}
inline const std::string& Schema::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Schema::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.description)
  return _impl_.description_.Release();
}
inline void Schema::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.description)
}

// string format = 35;
inline void Schema::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& Schema::format() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Schema.format)
}
inline std::string* Schema::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.format)
  return _s;
}
inline const std::string& Schema::_internal_format() const {
  return _impl_.format_.Get();
}
inline void Schema::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_format() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Schema.format)
  return _impl_.format_.Release();
}
inline void Schema::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Schema.format)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 36;
inline int Schema::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Schema::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Schema::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Schema::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Schema.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Schema::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Schema.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Schema::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Schema::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Schema.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Schema::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Schema::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Schema.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Schema::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Schema.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// SchemaOrReference

// .gnostic.openapi.v3.Schema schema = 1;
inline bool SchemaOrReference::_internal_has_schema() const {
  return oneof_case() == kSchema;
}
inline bool SchemaOrReference::has_schema() const {
  return _internal_has_schema();
}
inline void SchemaOrReference::set_has_schema() {
  _impl_._oneof_case_[0] = kSchema;
}
inline void SchemaOrReference::clear_schema() {
  if (_internal_has_schema()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.schema_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Schema* SchemaOrReference::release_schema() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SchemaOrReference.schema)
  if (_internal_has_schema()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Schema* temp = _impl_.oneof_.schema_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Schema& SchemaOrReference::_internal_schema() const {
  return _internal_has_schema()
      ? *_impl_.oneof_.schema_
      : reinterpret_cast< ::gnostic::openapi::v3::Schema&>(::gnostic::openapi::v3::_Schema_default_instance_);
}
inline const ::gnostic::openapi::v3::Schema& SchemaOrReference::schema() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SchemaOrReference.schema)
  return _internal_schema();
}
inline ::gnostic::openapi::v3::Schema* SchemaOrReference::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.SchemaOrReference.schema)
  if (_internal_has_schema()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Schema* temp = _impl_.oneof_.schema_;
    _impl_.oneof_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchemaOrReference::unsafe_arena_set_allocated_schema(::gnostic::openapi::v3::Schema* schema) {
  clear_oneof();
  if (schema) {
    set_has_schema();
    _impl_.oneof_.schema_ = schema;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.SchemaOrReference.schema)
}
inline ::gnostic::openapi::v3::Schema* SchemaOrReference::_internal_mutable_schema() {
  if (!_internal_has_schema()) {
    clear_oneof();
    set_has_schema();
    _impl_.oneof_.schema_ = CreateMaybeMessage< ::gnostic::openapi::v3::Schema >(GetArenaForAllocation());
  }
  return _impl_.oneof_.schema_;
}
inline ::gnostic::openapi::v3::Schema* SchemaOrReference::mutable_schema() {
  ::gnostic::openapi::v3::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SchemaOrReference.schema)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool SchemaOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool SchemaOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void SchemaOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void SchemaOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* SchemaOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SchemaOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& SchemaOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& SchemaOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SchemaOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* SchemaOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.SchemaOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchemaOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.SchemaOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* SchemaOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* SchemaOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SchemaOrReference.reference)
  return _msg;
}

inline bool SchemaOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void SchemaOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline SchemaOrReference::OneofCase SchemaOrReference::oneof_case() const {
  return SchemaOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SchemasOrReferences

// repeated .gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
inline int SchemasOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int SchemasOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void SchemasOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedSchemaOrReference* SchemasOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SchemasOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >*
SchemasOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.SchemasOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedSchemaOrReference& SchemasOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedSchemaOrReference& SchemasOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SchemasOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedSchemaOrReference* SchemasOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedSchemaOrReference* SchemasOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedSchemaOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.SchemasOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSchemaOrReference >&
SchemasOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.SchemasOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// SecurityRequirement

// repeated .gnostic.openapi.v3.NamedStringArray additional_properties = 1;
inline int SecurityRequirement::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int SecurityRequirement::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void SecurityRequirement::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedStringArray* SecurityRequirement::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityRequirement.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedStringArray >*
SecurityRequirement::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.SecurityRequirement.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedStringArray& SecurityRequirement::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedStringArray& SecurityRequirement::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityRequirement.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedStringArray* SecurityRequirement::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedStringArray* SecurityRequirement::add_additional_properties() {
  ::gnostic::openapi::v3::NamedStringArray* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.SecurityRequirement.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedStringArray >&
SecurityRequirement::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.SecurityRequirement.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// SecurityScheme

// string type = 1;
inline void SecurityScheme::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& SecurityScheme::type() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityScheme::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SecurityScheme.type)
}
inline std::string* SecurityScheme::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.type)
  return _s;
}
inline const std::string& SecurityScheme::_internal_type() const {
  return _impl_.type_.Get();
}
inline void SecurityScheme::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_type() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.type)
  return _impl_.type_.Release();
}
inline void SecurityScheme::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.type)
}

// string description = 2;
inline void SecurityScheme::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SecurityScheme::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityScheme::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SecurityScheme.description)
}
inline std::string* SecurityScheme::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.description)
  return _s;
}
inline const std::string& SecurityScheme::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SecurityScheme::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.description)
  return _impl_.description_.Release();
}
inline void SecurityScheme::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.description)
}

// string name = 3;
inline void SecurityScheme::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SecurityScheme::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityScheme::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SecurityScheme.name)
}
inline std::string* SecurityScheme::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.name)
  return _s;
}
inline const std::string& SecurityScheme::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SecurityScheme::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.name)
  return _impl_.name_.Release();
}
inline void SecurityScheme::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.name)
}

// string in = 4;
inline void SecurityScheme::clear_in() {
  _impl_.in_.ClearToEmpty();
}
inline const std::string& SecurityScheme::in() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.in)
  return _internal_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityScheme::set_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SecurityScheme.in)
}
inline std::string* SecurityScheme::mutable_in() {
  std::string* _s = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.in)
  return _s;
}
inline const std::string& SecurityScheme::_internal_in() const {
  return _impl_.in_.Get();
}
inline void SecurityScheme::_internal_set_in(const std::string& value) {
  
  _impl_.in_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_in() {
  
  return _impl_.in_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_in() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.in)
  return _impl_.in_.Release();
}
inline void SecurityScheme::set_allocated_in(std::string* in) {
  if (in != nullptr) {
    
  } else {
    
  }
  _impl_.in_.SetAllocated(in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.in_.IsDefault()) {
    _impl_.in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.in)
}

// string scheme = 5;
inline void SecurityScheme::clear_scheme() {
  _impl_.scheme_.ClearToEmpty();
}
inline const std::string& SecurityScheme::scheme() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.scheme)
  return _internal_scheme();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityScheme::set_scheme(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scheme_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SecurityScheme.scheme)
}
inline std::string* SecurityScheme::mutable_scheme() {
  std::string* _s = _internal_mutable_scheme();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.scheme)
  return _s;
}
inline const std::string& SecurityScheme::_internal_scheme() const {
  return _impl_.scheme_.Get();
}
inline void SecurityScheme::_internal_set_scheme(const std::string& value) {
  
  _impl_.scheme_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_scheme() {
  
  return _impl_.scheme_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_scheme() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.scheme)
  return _impl_.scheme_.Release();
}
inline void SecurityScheme::set_allocated_scheme(std::string* scheme) {
  if (scheme != nullptr) {
    
  } else {
    
  }
  _impl_.scheme_.SetAllocated(scheme, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scheme_.IsDefault()) {
    _impl_.scheme_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.scheme)
}

// string bearer_format = 6;
inline void SecurityScheme::clear_bearer_format() {
  _impl_.bearer_format_.ClearToEmpty();
}
inline const std::string& SecurityScheme::bearer_format() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.bearer_format)
  return _internal_bearer_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityScheme::set_bearer_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bearer_format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SecurityScheme.bearer_format)
}
inline std::string* SecurityScheme::mutable_bearer_format() {
  std::string* _s = _internal_mutable_bearer_format();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.bearer_format)
  return _s;
}
inline const std::string& SecurityScheme::_internal_bearer_format() const {
  return _impl_.bearer_format_.Get();
}
inline void SecurityScheme::_internal_set_bearer_format(const std::string& value) {
  
  _impl_.bearer_format_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_bearer_format() {
  
  return _impl_.bearer_format_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_bearer_format() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.bearer_format)
  return _impl_.bearer_format_.Release();
}
inline void SecurityScheme::set_allocated_bearer_format(std::string* bearer_format) {
  if (bearer_format != nullptr) {
    
  } else {
    
  }
  _impl_.bearer_format_.SetAllocated(bearer_format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bearer_format_.IsDefault()) {
    _impl_.bearer_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.bearer_format)
}

// .gnostic.openapi.v3.OauthFlows flows = 7;
inline bool SecurityScheme::_internal_has_flows() const {
  return this != internal_default_instance() && _impl_.flows_ != nullptr;
}
inline bool SecurityScheme::has_flows() const {
  return _internal_has_flows();
}
inline void SecurityScheme::clear_flows() {
  if (GetArenaForAllocation() == nullptr && _impl_.flows_ != nullptr) {
    delete _impl_.flows_;
  }
  _impl_.flows_ = nullptr;
}
inline const ::gnostic::openapi::v3::OauthFlows& SecurityScheme::_internal_flows() const {
  const ::gnostic::openapi::v3::OauthFlows* p = _impl_.flows_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::OauthFlows&>(
      ::gnostic::openapi::v3::_OauthFlows_default_instance_);
}
inline const ::gnostic::openapi::v3::OauthFlows& SecurityScheme::flows() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.flows)
  return _internal_flows();
}
inline void SecurityScheme::unsafe_arena_set_allocated_flows(
    ::gnostic::openapi::v3::OauthFlows* flows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flows_);
  }
  _impl_.flows_ = flows;
  if (flows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.SecurityScheme.flows)
}
inline ::gnostic::openapi::v3::OauthFlows* SecurityScheme::release_flows() {
  
  ::gnostic::openapi::v3::OauthFlows* temp = _impl_.flows_;
  _impl_.flows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlows* SecurityScheme::unsafe_arena_release_flows() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.flows)
  
  ::gnostic::openapi::v3::OauthFlows* temp = _impl_.flows_;
  _impl_.flows_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::OauthFlows* SecurityScheme::_internal_mutable_flows() {
  
  if (_impl_.flows_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::OauthFlows>(GetArenaForAllocation());
    _impl_.flows_ = p;
  }
  return _impl_.flows_;
}
inline ::gnostic::openapi::v3::OauthFlows* SecurityScheme::mutable_flows() {
  ::gnostic::openapi::v3::OauthFlows* _msg = _internal_mutable_flows();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.flows)
  return _msg;
}
inline void SecurityScheme::set_allocated_flows(::gnostic::openapi::v3::OauthFlows* flows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flows_;
  }
  if (flows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flows);
    if (message_arena != submessage_arena) {
      flows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flows_ = flows;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.flows)
}

// string open_id_connect_url = 8;
inline void SecurityScheme::clear_open_id_connect_url() {
  _impl_.open_id_connect_url_.ClearToEmpty();
}
inline const std::string& SecurityScheme::open_id_connect_url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.open_id_connect_url)
  return _internal_open_id_connect_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityScheme::set_open_id_connect_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.open_id_connect_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SecurityScheme.open_id_connect_url)
}
inline std::string* SecurityScheme::mutable_open_id_connect_url() {
  std::string* _s = _internal_mutable_open_id_connect_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.open_id_connect_url)
  return _s;
}
inline const std::string& SecurityScheme::_internal_open_id_connect_url() const {
  return _impl_.open_id_connect_url_.Get();
}
inline void SecurityScheme::_internal_set_open_id_connect_url(const std::string& value) {
  
  _impl_.open_id_connect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_open_id_connect_url() {
  
  return _impl_.open_id_connect_url_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_open_id_connect_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecurityScheme.open_id_connect_url)
  return _impl_.open_id_connect_url_.Release();
}
inline void SecurityScheme::set_allocated_open_id_connect_url(std::string* open_id_connect_url) {
  if (open_id_connect_url != nullptr) {
    
  } else {
    
  }
  _impl_.open_id_connect_url_.SetAllocated(open_id_connect_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.open_id_connect_url_.IsDefault()) {
    _impl_.open_id_connect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SecurityScheme.open_id_connect_url)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 9;
inline int SecurityScheme::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int SecurityScheme::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void SecurityScheme::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* SecurityScheme::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecurityScheme.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
SecurityScheme::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.SecurityScheme.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& SecurityScheme::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& SecurityScheme::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecurityScheme.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* SecurityScheme::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* SecurityScheme::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.SecurityScheme.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
SecurityScheme::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.SecurityScheme.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// SecuritySchemeOrReference

// .gnostic.openapi.v3.SecurityScheme security_scheme = 1;
inline bool SecuritySchemeOrReference::_internal_has_security_scheme() const {
  return oneof_case() == kSecurityScheme;
}
inline bool SecuritySchemeOrReference::has_security_scheme() const {
  return _internal_has_security_scheme();
}
inline void SecuritySchemeOrReference::set_has_security_scheme() {
  _impl_._oneof_case_[0] = kSecurityScheme;
}
inline void SecuritySchemeOrReference::clear_security_scheme() {
  if (_internal_has_security_scheme()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.security_scheme_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::SecurityScheme* SecuritySchemeOrReference::release_security_scheme() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecuritySchemeOrReference.security_scheme)
  if (_internal_has_security_scheme()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::SecurityScheme* temp = _impl_.oneof_.security_scheme_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.security_scheme_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::SecurityScheme& SecuritySchemeOrReference::_internal_security_scheme() const {
  return _internal_has_security_scheme()
      ? *_impl_.oneof_.security_scheme_
      : reinterpret_cast< ::gnostic::openapi::v3::SecurityScheme&>(::gnostic::openapi::v3::_SecurityScheme_default_instance_);
}
inline const ::gnostic::openapi::v3::SecurityScheme& SecuritySchemeOrReference::security_scheme() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecuritySchemeOrReference.security_scheme)
  return _internal_security_scheme();
}
inline ::gnostic::openapi::v3::SecurityScheme* SecuritySchemeOrReference::unsafe_arena_release_security_scheme() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.SecuritySchemeOrReference.security_scheme)
  if (_internal_has_security_scheme()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::SecurityScheme* temp = _impl_.oneof_.security_scheme_;
    _impl_.oneof_.security_scheme_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SecuritySchemeOrReference::unsafe_arena_set_allocated_security_scheme(::gnostic::openapi::v3::SecurityScheme* security_scheme) {
  clear_oneof();
  if (security_scheme) {
    set_has_security_scheme();
    _impl_.oneof_.security_scheme_ = security_scheme;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.SecuritySchemeOrReference.security_scheme)
}
inline ::gnostic::openapi::v3::SecurityScheme* SecuritySchemeOrReference::_internal_mutable_security_scheme() {
  if (!_internal_has_security_scheme()) {
    clear_oneof();
    set_has_security_scheme();
    _impl_.oneof_.security_scheme_ = CreateMaybeMessage< ::gnostic::openapi::v3::SecurityScheme >(GetArenaForAllocation());
  }
  return _impl_.oneof_.security_scheme_;
}
inline ::gnostic::openapi::v3::SecurityScheme* SecuritySchemeOrReference::mutable_security_scheme() {
  ::gnostic::openapi::v3::SecurityScheme* _msg = _internal_mutable_security_scheme();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecuritySchemeOrReference.security_scheme)
  return _msg;
}

// .gnostic.openapi.v3.Reference reference = 2;
inline bool SecuritySchemeOrReference::_internal_has_reference() const {
  return oneof_case() == kReference;
}
inline bool SecuritySchemeOrReference::has_reference() const {
  return _internal_has_reference();
}
inline void SecuritySchemeOrReference::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void SecuritySchemeOrReference::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_.reference_;
    }
    clear_has_oneof();
  }
}
inline ::gnostic::openapi::v3::Reference* SecuritySchemeOrReference::release_reference() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SecuritySchemeOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnostic::openapi::v3::Reference& SecuritySchemeOrReference::_internal_reference() const {
  return _internal_has_reference()
      ? *_impl_.oneof_.reference_
      : reinterpret_cast< ::gnostic::openapi::v3::Reference&>(::gnostic::openapi::v3::_Reference_default_instance_);
}
inline const ::gnostic::openapi::v3::Reference& SecuritySchemeOrReference::reference() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecuritySchemeOrReference.reference)
  return _internal_reference();
}
inline ::gnostic::openapi::v3::Reference* SecuritySchemeOrReference::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnostic.openapi.v3.SecuritySchemeOrReference.reference)
  if (_internal_has_reference()) {
    clear_has_oneof();
    ::gnostic::openapi::v3::Reference* temp = _impl_.oneof_.reference_;
    _impl_.oneof_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SecuritySchemeOrReference::unsafe_arena_set_allocated_reference(::gnostic::openapi::v3::Reference* reference) {
  clear_oneof();
  if (reference) {
    set_has_reference();
    _impl_.oneof_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.SecuritySchemeOrReference.reference)
}
inline ::gnostic::openapi::v3::Reference* SecuritySchemeOrReference::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_oneof();
    set_has_reference();
    _impl_.oneof_.reference_ = CreateMaybeMessage< ::gnostic::openapi::v3::Reference >(GetArenaForAllocation());
  }
  return _impl_.oneof_.reference_;
}
inline ::gnostic::openapi::v3::Reference* SecuritySchemeOrReference::mutable_reference() {
  ::gnostic::openapi::v3::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecuritySchemeOrReference.reference)
  return _msg;
}

inline bool SecuritySchemeOrReference::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void SecuritySchemeOrReference::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline SecuritySchemeOrReference::OneofCase SecuritySchemeOrReference::oneof_case() const {
  return SecuritySchemeOrReference::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SecuritySchemesOrReferences

// repeated .gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1;
inline int SecuritySchemesOrReferences::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int SecuritySchemesOrReferences::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void SecuritySchemesOrReferences::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* SecuritySchemesOrReferences::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SecuritySchemesOrReferences.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSecuritySchemeOrReference >*
SecuritySchemesOrReferences::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.SecuritySchemesOrReferences.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedSecuritySchemeOrReference& SecuritySchemesOrReferences::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedSecuritySchemeOrReference& SecuritySchemesOrReferences::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SecuritySchemesOrReferences.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* SecuritySchemesOrReferences::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* SecuritySchemesOrReferences::add_additional_properties() {
  ::gnostic::openapi::v3::NamedSecuritySchemeOrReference* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.SecuritySchemesOrReferences.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedSecuritySchemeOrReference >&
SecuritySchemesOrReferences::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.SecuritySchemesOrReferences.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Server

// string url = 1;
inline void Server::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Server::url() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Server.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Server.url)
}
inline std::string* Server::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Server.url)
  return _s;
}
inline const std::string& Server::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Server::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Server::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Server::release_url() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Server.url)
  return _impl_.url_.Release();
}
inline void Server::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Server.url)
}

// string description = 2;
inline void Server::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Server::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Server.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Server.description)
}
inline std::string* Server::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Server.description)
  return _s;
}
inline const std::string& Server::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Server::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Server::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Server::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Server.description)
  return _impl_.description_.Release();
}
inline void Server::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Server.description)
}

// .gnostic.openapi.v3.ServerVariables variables = 3;
inline bool Server::_internal_has_variables() const {
  return this != internal_default_instance() && _impl_.variables_ != nullptr;
}
inline bool Server::has_variables() const {
  return _internal_has_variables();
}
inline void Server::clear_variables() {
  if (GetArenaForAllocation() == nullptr && _impl_.variables_ != nullptr) {
    delete _impl_.variables_;
  }
  _impl_.variables_ = nullptr;
}
inline const ::gnostic::openapi::v3::ServerVariables& Server::_internal_variables() const {
  const ::gnostic::openapi::v3::ServerVariables* p = _impl_.variables_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ServerVariables&>(
      ::gnostic::openapi::v3::_ServerVariables_default_instance_);
}
inline const ::gnostic::openapi::v3::ServerVariables& Server::variables() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Server.variables)
  return _internal_variables();
}
inline void Server::unsafe_arena_set_allocated_variables(
    ::gnostic::openapi::v3::ServerVariables* variables) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.variables_);
  }
  _impl_.variables_ = variables;
  if (variables) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Server.variables)
}
inline ::gnostic::openapi::v3::ServerVariables* Server::release_variables() {
  
  ::gnostic::openapi::v3::ServerVariables* temp = _impl_.variables_;
  _impl_.variables_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ServerVariables* Server::unsafe_arena_release_variables() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Server.variables)
  
  ::gnostic::openapi::v3::ServerVariables* temp = _impl_.variables_;
  _impl_.variables_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ServerVariables* Server::_internal_mutable_variables() {
  
  if (_impl_.variables_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ServerVariables>(GetArenaForAllocation());
    _impl_.variables_ = p;
  }
  return _impl_.variables_;
}
inline ::gnostic::openapi::v3::ServerVariables* Server::mutable_variables() {
  ::gnostic::openapi::v3::ServerVariables* _msg = _internal_mutable_variables();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Server.variables)
  return _msg;
}
inline void Server::set_allocated_variables(::gnostic::openapi::v3::ServerVariables* variables) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.variables_;
  }
  if (variables) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(variables);
    if (message_arena != submessage_arena) {
      variables = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, variables, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.variables_ = variables;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Server.variables)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
inline int Server::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Server::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Server::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Server::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Server.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Server::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Server.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Server::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Server::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Server.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Server::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Server::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Server.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Server::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Server.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// ServerVariable

// repeated string enum = 1;
inline int ServerVariable::_internal_enum__size() const {
  return _impl_.enum__.size();
}
inline int ServerVariable::enum__size() const {
  return _internal_enum__size();
}
inline void ServerVariable::clear_enum_() {
  _impl_.enum__.Clear();
}
inline std::string* ServerVariable::add_enum_() {
  std::string* _s = _internal_add_enum_();
  // @@protoc_insertion_point(field_add_mutable:gnostic.openapi.v3.ServerVariable.enum)
  return _s;
}
inline const std::string& ServerVariable::_internal_enum_(int index) const {
  return _impl_.enum__.Get(index);
}
inline const std::string& ServerVariable::enum_(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ServerVariable.enum)
  return _internal_enum_(index);
}
inline std::string* ServerVariable::mutable_enum_(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ServerVariable.enum)
  return _impl_.enum__.Mutable(index);
}
inline void ServerVariable::set_enum_(int index, const std::string& value) {
  _impl_.enum__.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.ServerVariable.enum)
}
inline void ServerVariable::set_enum_(int index, std::string&& value) {
  _impl_.enum__.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.ServerVariable.enum)
}
inline void ServerVariable::set_enum_(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.enum__.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gnostic.openapi.v3.ServerVariable.enum)
}
inline void ServerVariable::set_enum_(int index, const char* value, size_t size) {
  _impl_.enum__.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnostic.openapi.v3.ServerVariable.enum)
}
inline std::string* ServerVariable::_internal_add_enum_() {
  return _impl_.enum__.Add();
}
inline void ServerVariable::add_enum_(const std::string& value) {
  _impl_.enum__.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ServerVariable.enum)
}
inline void ServerVariable::add_enum_(std::string&& value) {
  _impl_.enum__.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ServerVariable.enum)
}
inline void ServerVariable::add_enum_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.enum__.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gnostic.openapi.v3.ServerVariable.enum)
}
inline void ServerVariable::add_enum_(const char* value, size_t size) {
  _impl_.enum__.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gnostic.openapi.v3.ServerVariable.enum)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerVariable::enum_() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ServerVariable.enum)
  return _impl_.enum__;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServerVariable::mutable_enum_() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ServerVariable.enum)
  return &_impl_.enum__;
}

// string default = 2;
inline void ServerVariable::clear_default_() {
  _impl_.default__.ClearToEmpty();
}
inline const std::string& ServerVariable::default_() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ServerVariable.default)
  return _internal_default_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerVariable::set_default_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.ServerVariable.default)
}
inline std::string* ServerVariable::mutable_default_() {
  std::string* _s = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ServerVariable.default)
  return _s;
}
inline const std::string& ServerVariable::_internal_default_() const {
  return _impl_.default__.Get();
}
inline void ServerVariable::_internal_set_default_(const std::string& value) {
  
  _impl_.default__.Set(value, GetArenaForAllocation());
}
inline std::string* ServerVariable::_internal_mutable_default_() {
  
  return _impl_.default__.Mutable(GetArenaForAllocation());
}
inline std::string* ServerVariable::release_default_() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ServerVariable.default)
  return _impl_.default__.Release();
}
inline void ServerVariable::set_allocated_default_(std::string* default_) {
  if (default_ != nullptr) {
    
  } else {
    
  }
  _impl_.default__.SetAllocated(default_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default__.IsDefault()) {
    _impl_.default__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ServerVariable.default)
}

// string description = 3;
inline void ServerVariable::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ServerVariable::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ServerVariable.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerVariable::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.ServerVariable.description)
}
inline std::string* ServerVariable::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ServerVariable.description)
  return _s;
}
inline const std::string& ServerVariable::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ServerVariable::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerVariable::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerVariable::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.ServerVariable.description)
  return _impl_.description_.Release();
}
inline void ServerVariable::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.ServerVariable.description)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
inline int ServerVariable::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int ServerVariable::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void ServerVariable::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* ServerVariable::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ServerVariable.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
ServerVariable::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ServerVariable.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& ServerVariable::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& ServerVariable::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ServerVariable.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* ServerVariable::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* ServerVariable::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ServerVariable.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
ServerVariable::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ServerVariable.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// ServerVariables

// repeated .gnostic.openapi.v3.NamedServerVariable additional_properties = 1;
inline int ServerVariables::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int ServerVariables::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void ServerVariables::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedServerVariable* ServerVariables::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.ServerVariables.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedServerVariable >*
ServerVariables::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.ServerVariables.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedServerVariable& ServerVariables::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedServerVariable& ServerVariables::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.ServerVariables.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedServerVariable* ServerVariables::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedServerVariable* ServerVariables::add_additional_properties() {
  ::gnostic::openapi::v3::NamedServerVariable* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.ServerVariables.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedServerVariable >&
ServerVariables::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.ServerVariables.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// SpecificationExtension

// double number = 1;
inline bool SpecificationExtension::_internal_has_number() const {
  return oneof_case() == kNumber;
}
inline bool SpecificationExtension::has_number() const {
  return _internal_has_number();
}
inline void SpecificationExtension::set_has_number() {
  _impl_._oneof_case_[0] = kNumber;
}
inline void SpecificationExtension::clear_number() {
  if (_internal_has_number()) {
    _impl_.oneof_.number_ = 0;
    clear_has_oneof();
  }
}
inline double SpecificationExtension::_internal_number() const {
  if (_internal_has_number()) {
    return _impl_.oneof_.number_;
  }
  return 0;
}
inline void SpecificationExtension::_internal_set_number(double value) {
  if (!_internal_has_number()) {
    clear_oneof();
    set_has_number();
  }
  _impl_.oneof_.number_ = value;
}
inline double SpecificationExtension::number() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SpecificationExtension.number)
  return _internal_number();
}
inline void SpecificationExtension::set_number(double value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SpecificationExtension.number)
}

// bool boolean = 2;
inline bool SpecificationExtension::_internal_has_boolean() const {
  return oneof_case() == kBoolean;
}
inline bool SpecificationExtension::has_boolean() const {
  return _internal_has_boolean();
}
inline void SpecificationExtension::set_has_boolean() {
  _impl_._oneof_case_[0] = kBoolean;
}
inline void SpecificationExtension::clear_boolean() {
  if (_internal_has_boolean()) {
    _impl_.oneof_.boolean_ = false;
    clear_has_oneof();
  }
}
inline bool SpecificationExtension::_internal_boolean() const {
  if (_internal_has_boolean()) {
    return _impl_.oneof_.boolean_;
  }
  return false;
}
inline void SpecificationExtension::_internal_set_boolean(bool value) {
  if (!_internal_has_boolean()) {
    clear_oneof();
    set_has_boolean();
  }
  _impl_.oneof_.boolean_ = value;
}
inline bool SpecificationExtension::boolean() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SpecificationExtension.boolean)
  return _internal_boolean();
}
inline void SpecificationExtension::set_boolean(bool value) {
  _internal_set_boolean(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SpecificationExtension.boolean)
}

// string string = 3;
inline bool SpecificationExtension::_internal_has_string() const {
  return oneof_case() == kString;
}
inline bool SpecificationExtension::has_string() const {
  return _internal_has_string();
}
inline void SpecificationExtension::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void SpecificationExtension::clear_string() {
  if (_internal_has_string()) {
    _impl_.oneof_.string_.Destroy();
    clear_has_oneof();
  }
}
inline const std::string& SpecificationExtension::string() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.SpecificationExtension.string)
  return _internal_string();
}
template <typename ArgT0, typename... ArgT>
inline void SpecificationExtension::set_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string()) {
    clear_oneof();
    set_has_string();
    _impl_.oneof_.string_.InitDefault();
  }
  _impl_.oneof_.string_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.SpecificationExtension.string)
}
inline std::string* SpecificationExtension::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.SpecificationExtension.string)
  return _s;
}
inline const std::string& SpecificationExtension::_internal_string() const {
  if (_internal_has_string()) {
    return _impl_.oneof_.string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SpecificationExtension::_internal_set_string(const std::string& value) {
  if (!_internal_has_string()) {
    clear_oneof();
    set_has_string();
    _impl_.oneof_.string_.InitDefault();
  }
  _impl_.oneof_.string_.Set(value, GetArenaForAllocation());
}
inline std::string* SpecificationExtension::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_oneof();
    set_has_string();
    _impl_.oneof_.string_.InitDefault();
  }
  return _impl_.oneof_.string_.Mutable(      GetArenaForAllocation());
}
inline std::string* SpecificationExtension::release_string() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.SpecificationExtension.string)
  if (_internal_has_string()) {
    clear_has_oneof();
    return _impl_.oneof_.string_.Release();
  } else {
    return nullptr;
  }
}
inline void SpecificationExtension::set_allocated_string(std::string* string) {
  if (has_oneof()) {
    clear_oneof();
  }
  if (string != nullptr) {
    set_has_string();
    _impl_.oneof_.string_.InitAllocated(string, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.SpecificationExtension.string)
}

inline bool SpecificationExtension::has_oneof() const {
  return oneof_case() != ONEOF_NOT_SET;
}
inline void SpecificationExtension::clear_has_oneof() {
  _impl_._oneof_case_[0] = ONEOF_NOT_SET;
}
inline SpecificationExtension::OneofCase SpecificationExtension::oneof_case() const {
  return SpecificationExtension::OneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StringArray

// repeated string value = 1;
inline int StringArray::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int StringArray::value_size() const {
  return _internal_value_size();
}
inline void StringArray::clear_value() {
  _impl_.value_.Clear();
}
inline std::string* StringArray::add_value() {
  std::string* _s = _internal_add_value();
  // @@protoc_insertion_point(field_add_mutable:gnostic.openapi.v3.StringArray.value)
  return _s;
}
inline const std::string& StringArray::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const std::string& StringArray::value(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.StringArray.value)
  return _internal_value(index);
}
inline std::string* StringArray::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.StringArray.value)
  return _impl_.value_.Mutable(index);
}
inline void StringArray::set_value(int index, const std::string& value) {
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.StringArray.value)
}
inline void StringArray::set_value(int index, std::string&& value) {
  _impl_.value_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.StringArray.value)
}
inline void StringArray::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gnostic.openapi.v3.StringArray.value)
}
inline void StringArray::set_value(int index, const char* value, size_t size) {
  _impl_.value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnostic.openapi.v3.StringArray.value)
}
inline std::string* StringArray::_internal_add_value() {
  return _impl_.value_.Add();
}
inline void StringArray::add_value(const std::string& value) {
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.StringArray.value)
}
inline void StringArray::add_value(std::string&& value) {
  _impl_.value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.StringArray.value)
}
inline void StringArray::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gnostic.openapi.v3.StringArray.value)
}
inline void StringArray::add_value(const char* value, size_t size) {
  _impl_.value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gnostic.openapi.v3.StringArray.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StringArray::value() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.StringArray.value)
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StringArray::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.StringArray.value)
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// Strings

// repeated .gnostic.openapi.v3.NamedString additional_properties = 1;
inline int Strings::_internal_additional_properties_size() const {
  return _impl_.additional_properties_.size();
}
inline int Strings::additional_properties_size() const {
  return _internal_additional_properties_size();
}
inline void Strings::clear_additional_properties() {
  _impl_.additional_properties_.Clear();
}
inline ::gnostic::openapi::v3::NamedString* Strings::mutable_additional_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Strings.additional_properties)
  return _impl_.additional_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedString >*
Strings::mutable_additional_properties() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Strings.additional_properties)
  return &_impl_.additional_properties_;
}
inline const ::gnostic::openapi::v3::NamedString& Strings::_internal_additional_properties(int index) const {
  return _impl_.additional_properties_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedString& Strings::additional_properties(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Strings.additional_properties)
  return _internal_additional_properties(index);
}
inline ::gnostic::openapi::v3::NamedString* Strings::_internal_add_additional_properties() {
  return _impl_.additional_properties_.Add();
}
inline ::gnostic::openapi::v3::NamedString* Strings::add_additional_properties() {
  ::gnostic::openapi::v3::NamedString* _add = _internal_add_additional_properties();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Strings.additional_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedString >&
Strings::additional_properties() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Strings.additional_properties)
  return _impl_.additional_properties_;
}

// -------------------------------------------------------------------

// Tag

// string name = 1;
inline void Tag::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Tag::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Tag.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tag::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Tag.name)
}
inline std::string* Tag::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Tag.name)
  return _s;
}
inline const std::string& Tag::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Tag::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Tag::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Tag::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Tag.name)
  return _impl_.name_.Release();
}
inline void Tag::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Tag.name)
}

// string description = 2;
inline void Tag::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Tag::description() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Tag.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tag::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Tag.description)
}
inline std::string* Tag::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Tag.description)
  return _s;
}
inline const std::string& Tag::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Tag::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Tag::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Tag::release_description() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Tag.description)
  return _impl_.description_.Release();
}
inline void Tag::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Tag.description)
}

// .gnostic.openapi.v3.ExternalDocs external_docs = 3;
inline bool Tag::_internal_has_external_docs() const {
  return this != internal_default_instance() && _impl_.external_docs_ != nullptr;
}
inline bool Tag::has_external_docs() const {
  return _internal_has_external_docs();
}
inline void Tag::clear_external_docs() {
  if (GetArenaForAllocation() == nullptr && _impl_.external_docs_ != nullptr) {
    delete _impl_.external_docs_;
  }
  _impl_.external_docs_ = nullptr;
}
inline const ::gnostic::openapi::v3::ExternalDocs& Tag::_internal_external_docs() const {
  const ::gnostic::openapi::v3::ExternalDocs* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnostic::openapi::v3::ExternalDocs&>(
      ::gnostic::openapi::v3::_ExternalDocs_default_instance_);
}
inline const ::gnostic::openapi::v3::ExternalDocs& Tag::external_docs() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Tag.external_docs)
  return _internal_external_docs();
}
inline void Tag::unsafe_arena_set_allocated_external_docs(
    ::gnostic::openapi::v3::ExternalDocs* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnostic.openapi.v3.Tag.external_docs)
}
inline ::gnostic::openapi::v3::ExternalDocs* Tag::release_external_docs() {
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Tag::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Tag.external_docs)
  
  ::gnostic::openapi::v3::ExternalDocs* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::gnostic::openapi::v3::ExternalDocs* Tag::_internal_mutable_external_docs() {
  
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnostic::openapi::v3::ExternalDocs>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::gnostic::openapi::v3::ExternalDocs* Tag::mutable_external_docs() {
  ::gnostic::openapi::v3::ExternalDocs* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Tag.external_docs)
  return _msg;
}
inline void Tag::set_allocated_external_docs(::gnostic::openapi::v3::ExternalDocs* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Tag.external_docs)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 4;
inline int Tag::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Tag::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Tag::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Tag::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Tag.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Tag::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Tag.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Tag::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Tag::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Tag.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Tag::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Tag::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Tag.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Tag::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Tag.specification_extension)
  return _impl_.specification_extension_;
}

// -------------------------------------------------------------------

// Xml

// string name = 1;
inline void Xml::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Xml::name() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Xml.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Xml::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Xml.name)
}
inline std::string* Xml::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Xml.name)
  return _s;
}
inline const std::string& Xml::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Xml::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Xml::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Xml::release_name() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Xml.name)
  return _impl_.name_.Release();
}
inline void Xml::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Xml.name)
}

// string namespace = 2;
inline void Xml::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& Xml::namespace_() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Xml.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Xml::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Xml.namespace)
}
inline std::string* Xml::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Xml.namespace)
  return _s;
}
inline const std::string& Xml::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void Xml::_internal_set_namespace_(const std::string& value) {
  
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* Xml::_internal_mutable_namespace_() {
  
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* Xml::release_namespace_() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Xml.namespace)
  return _impl_.namespace__.Release();
}
inline void Xml::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Xml.namespace)
}

// string prefix = 3;
inline void Xml::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& Xml::prefix() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Xml.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Xml::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Xml.prefix)
}
inline std::string* Xml::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Xml.prefix)
  return _s;
}
inline const std::string& Xml::_internal_prefix() const {
  return _impl_.prefix_.Get();
}
inline void Xml::_internal_set_prefix(const std::string& value) {
  
  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* Xml::_internal_mutable_prefix() {
  
  return _impl_.prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* Xml::release_prefix() {
  // @@protoc_insertion_point(field_release:gnostic.openapi.v3.Xml.prefix)
  return _impl_.prefix_.Release();
}
inline void Xml::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  _impl_.prefix_.SetAllocated(prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnostic.openapi.v3.Xml.prefix)
}

// bool attribute = 4;
inline void Xml::clear_attribute() {
  _impl_.attribute_ = false;
}
inline bool Xml::_internal_attribute() const {
  return _impl_.attribute_;
}
inline bool Xml::attribute() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Xml.attribute)
  return _internal_attribute();
}
inline void Xml::_internal_set_attribute(bool value) {
  
  _impl_.attribute_ = value;
}
inline void Xml::set_attribute(bool value) {
  _internal_set_attribute(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Xml.attribute)
}

// bool wrapped = 5;
inline void Xml::clear_wrapped() {
  _impl_.wrapped_ = false;
}
inline bool Xml::_internal_wrapped() const {
  return _impl_.wrapped_;
}
inline bool Xml::wrapped() const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Xml.wrapped)
  return _internal_wrapped();
}
inline void Xml::_internal_set_wrapped(bool value) {
  
  _impl_.wrapped_ = value;
}
inline void Xml::set_wrapped(bool value) {
  _internal_set_wrapped(value);
  // @@protoc_insertion_point(field_set:gnostic.openapi.v3.Xml.wrapped)
}

// repeated .gnostic.openapi.v3.NamedAny specification_extension = 6;
inline int Xml::_internal_specification_extension_size() const {
  return _impl_.specification_extension_.size();
}
inline int Xml::specification_extension_size() const {
  return _internal_specification_extension_size();
}
inline void Xml::clear_specification_extension() {
  _impl_.specification_extension_.Clear();
}
inline ::gnostic::openapi::v3::NamedAny* Xml::mutable_specification_extension(int index) {
  // @@protoc_insertion_point(field_mutable:gnostic.openapi.v3.Xml.specification_extension)
  return _impl_.specification_extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >*
Xml::mutable_specification_extension() {
  // @@protoc_insertion_point(field_mutable_list:gnostic.openapi.v3.Xml.specification_extension)
  return &_impl_.specification_extension_;
}
inline const ::gnostic::openapi::v3::NamedAny& Xml::_internal_specification_extension(int index) const {
  return _impl_.specification_extension_.Get(index);
}
inline const ::gnostic::openapi::v3::NamedAny& Xml::specification_extension(int index) const {
  // @@protoc_insertion_point(field_get:gnostic.openapi.v3.Xml.specification_extension)
  return _internal_specification_extension(index);
}
inline ::gnostic::openapi::v3::NamedAny* Xml::_internal_add_specification_extension() {
  return _impl_.specification_extension_.Add();
}
inline ::gnostic::openapi::v3::NamedAny* Xml::add_specification_extension() {
  ::gnostic::openapi::v3::NamedAny* _add = _internal_add_specification_extension();
  // @@protoc_insertion_point(field_add:gnostic.openapi.v3.Xml.specification_extension)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gnostic::openapi::v3::NamedAny >&
Xml::specification_extension() const {
  // @@protoc_insertion_point(field_list:gnostic.openapi.v3.Xml.specification_extension)
  return _impl_.specification_extension_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3
}  // namespace openapi
}  // namespace gnostic

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gnostic_2fopenapi_2fv3_2fopenapiv3_2eproto
